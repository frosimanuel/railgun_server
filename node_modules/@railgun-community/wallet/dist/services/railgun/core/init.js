"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.POIListType = exports.stopRailgunEngine = exports.startRailgunEngineForPOINode = exports.startRailgunEngine = exports.resumePPOIBatching = exports.pausePPOIBatchingForChain = exports.setBatchListCallback = exports.setOnTXIDMerkletreeScanCallback = exports.setOnUTXOMerkletreeScanCallback = void 0;
const engine_1 = require("@railgun-community/engine");
Object.defineProperty(exports, "POIListType", { enumerable: true, get: function () { return engine_1.POIListType; } });
const shared_models_1 = require("@railgun-community/shared-models");
const logger_1 = require("../../../utils/logger");
const artifacts_1 = require("./artifacts");
const error_1 = require("../../../utils/error");
const quick_sync_events_1 = require("../quick-sync/quick-sync-events");
const railgun_txid_sync_graph_v2_1 = require("../railgun-txids/railgun-txid-sync-graph-v2");
const wallet_poi_1 = require("../../poi/wallet-poi");
const wallet_poi_node_interface_1 = require("../../poi/wallet-poi-node-interface");
const engine_2 = require("./engine");
const balance_update_1 = require("../wallets/balance-update");
const poi_1 = require("../../poi");
const createEngineDebugger = (verboseScanLogging) => {
    return {
        log: (msg) => (0, logger_1.sendMessage)(msg),
        error: (error) => (0, logger_1.sendErrorMessage)(error),
        verboseScanLogging,
    };
};
const setOnUTXOMerkletreeScanCallback = (onUTXOMerkletreeScanCallback) => {
    const engine = (0, engine_2.getEngine)();
    engine.on(engine_1.EngineEvent.UTXOMerkletreeHistoryScanUpdate, ({ chain, scanStatus, progress }) => onUTXOMerkletreeScanCallback({
        scanStatus,
        chain,
        progress: progress ?? 0.0,
    }));
};
exports.setOnUTXOMerkletreeScanCallback = setOnUTXOMerkletreeScanCallback;
const setOnTXIDMerkletreeScanCallback = (onTXIDMerkletreeScanCallback) => {
    const engine = (0, engine_2.getEngine)();
    engine.on(engine_1.EngineEvent.TXIDMerkletreeHistoryScanUpdate, ({ chain, scanStatus, progress }) => onTXIDMerkletreeScanCallback({
        scanStatus,
        chain,
        progress: progress ?? 0.0,
    }));
};
exports.setOnTXIDMerkletreeScanCallback = setOnTXIDMerkletreeScanCallback;
const setOnUTXOScanDecryptBalancesCompleteListener = () => {
    const engine = (0, engine_2.getEngine)();
    engine.on(engine_1.EngineEvent.UTXOScanDecryptBalancesComplete, ({ txidVersion, chain, walletIdFilter, }) => {
        const updateWalletBalances = async () => {
            let walletsToUpdate = Object.values(engine.wallets);
            if ((0, shared_models_1.isDefined)(walletIdFilter)) {
                walletsToUpdate = walletsToUpdate.filter(wallet => walletIdFilter.includes(wallet.id));
            }
            // await onBalancesUpdate calls for each wallet
            await Promise.all(walletsToUpdate.map(wallet => (0, balance_update_1.onBalancesUpdate)(txidVersion, wallet, chain)));
            // emit event to notify listeners that UTXOMerkletreeHistoryScan is complete
            engine.emitScanEventHistoryComplete(txidVersion, chain);
        };
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        updateWalletBalances();
    });
};
const setBatchListCallback = (onBatchListCallback) => {
    wallet_poi_node_interface_1.WalletPOINodeInterface.setListBatchCallback(onBatchListCallback);
};
exports.setBatchListCallback = setBatchListCallback;
const pausePPOIBatchingForChain = (chain) => {
    wallet_poi_node_interface_1.WalletPOINodeInterface.pause(chain);
};
exports.pausePPOIBatchingForChain = pausePPOIBatchingForChain;
const resumePPOIBatching = (chain) => {
    wallet_poi_node_interface_1.WalletPOINodeInterface.unpause(chain);
};
exports.resumePPOIBatching = resumePPOIBatching;
/**
 *
 * @param walletSource - Name for your wallet implementation. Encrypted and viewable in private transaction history. Maximum of 16 characters, lowercase.
 * @param db - LevelDOWN compatible database for storing encrypted wallets.
 * @param shouldDebug - Whether to forward Engine debug logs to Logger.
 * @param artifactStore - Persistent store for downloading large artifact files. See Wallet SDK Developer Guide for platform implementations.
 * @param useNativeArtifacts - Whether to download native C++ or web-assembly artifacts. TRUE for mobile. FALSE for nodejs and browser.
 * @param skipMerkletreeScans - Whether to skip merkletree syncs and private balance scans. Only set to TRUE in shield-only applications that don't load private wallets or balances.
 * @param poiNodeURLs - List of POI aggregator node URLs, in order of priority.
 * @param customPOILists - POI lists to use for additional wallet protections after default lists.
 * @returns
 */
const startRailgunEngine = async (walletSource, db, shouldDebug, artifactStore, useNativeArtifacts, skipMerkletreeScans, poiNodeURLs, customPOILists, verboseScanLogging = false) => {
    if ((0, engine_2.hasEngine)()) {
        return;
    }
    try {
        (0, artifacts_1.setArtifactStore)(artifactStore);
        (0, artifacts_1.setUseNativeArtifacts)(useNativeArtifacts);
        const engine = await engine_1.RailgunEngine.initForWallet(walletSource, db, artifacts_1.artifactGetterDownloadJustInTime, quick_sync_events_1.quickSyncEventsGraph, railgun_txid_sync_graph_v2_1.quickSyncRailgunTransactionsV2, wallet_poi_1.WalletPOI.getPOITxidMerklerootValidator(poiNodeURLs), wallet_poi_1.WalletPOI.getPOILatestValidatedRailgunTxid(poiNodeURLs), shouldDebug ? createEngineDebugger(verboseScanLogging) : undefined, skipMerkletreeScans);
        (0, engine_2.setEngine)(engine);
        setOnUTXOScanDecryptBalancesCompleteListener();
        if ((0, shared_models_1.isDefined)(poiNodeURLs)) {
            const poiNodeInterface = new wallet_poi_node_interface_1.WalletPOINodeInterface(poiNodeURLs);
            wallet_poi_1.WalletPOI.init(poiNodeInterface, customPOILists ?? []);
        }
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.startRailgunEngine.name, err);
    }
};
exports.startRailgunEngine = startRailgunEngine;
const startRailgunEngineForPOINode = async (db, shouldDebug, artifactStore, validatePOIMerkleroots) => {
    if ((0, engine_2.hasEngine)()) {
        return;
    }
    try {
        (0, artifacts_1.setArtifactStore)(artifactStore);
        (0, artifacts_1.setUseNativeArtifacts)(false);
        poi_1.POIValidator.initForPOINode(validatePOIMerkleroots);
        const engine = await engine_1.RailgunEngine.initForPOINode(db, artifacts_1.artifactGetterDownloadJustInTime, quick_sync_events_1.quickSyncEventsGraph, railgun_txid_sync_graph_v2_1.quickSyncRailgunTransactionsV2, shouldDebug
            ? createEngineDebugger(false)
            : undefined);
        (0, engine_2.setEngine)(engine);
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.startRailgunEngineForPOINode.name, err);
    }
};
exports.startRailgunEngineForPOINode = startRailgunEngineForPOINode;
const stopRailgunEngine = async () => {
    if (!(0, engine_2.hasEngine)()) {
        return;
    }
    await (0, engine_2.getEngine)()?.unload();
    (0, engine_2.setEngine)(undefined);
};
exports.stopRailgunEngine = stopRailgunEngine;
//# sourceMappingURL=init.js.map