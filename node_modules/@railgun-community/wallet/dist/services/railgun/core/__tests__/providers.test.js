"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = __importDefault(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const shared_models_1 = require("@railgun-community/shared-models");
const mocks_test_1 = require("../../../../tests/mocks.test");
const setup_test_1 = require("../../../../tests/setup.test");
const providers_1 = require("../providers");
const load_provider_1 = require("../load-provider");
const wallets_1 = require("../../wallets/wallets");
const merkletree_1 = require("../merkletree");
const engine_1 = require("@railgun-community/engine");
const helper_test_1 = require("../../../../tests/helper.test");
chai_1.default.use(chai_as_promised_1.default);
const { expect } = chai_1.default;
const MOCK_MNEMONIC_PROVIDERS_ONLY = 'pause crystal tornado alcohol genre cement fade large song like bag where';
const txidVersion = (0, helper_test_1.getTestTXIDVersion)();
describe('providers', () => {
    before(async () => {
        await (0, setup_test_1.closeTestEngine)();
        await (0, setup_test_1.initTestEngine)();
    });
    after(async () => {
        await (0, setup_test_1.closeTestEngine)();
    });
    it('Should load provider with json, pull fees, and check created objects', async () => {
        const response = await (0, load_provider_1.loadProvider)(mocks_test_1.MOCK_FALLBACK_PROVIDER_JSON_CONFIG_SEPOLIA, shared_models_1.NetworkName.EthereumSepolia, 10000);
        expect(response.feesSerialized).to.deep.equal({
            shieldFeeV2: '25',
            unshieldFeeV2: '25',
            shieldFeeV3: undefined,
            unshieldFeeV3: undefined,
        });
        expect((0, providers_1.getFallbackProviderForNetwork)(shared_models_1.NetworkName.EthereumSepolia)).to.not.be
            .undefined;
        expect(() => (0, providers_1.getFallbackProviderForNetwork)(shared_models_1.NetworkName.EthereumRopsten_DEPRECATED)).to.throw;
        expect((0, merkletree_1.getUTXOMerkletreeForNetwork)(txidVersion, shared_models_1.NetworkName.EthereumSepolia))
            .to.not.be.undefined;
        expect(() => (0, merkletree_1.getUTXOMerkletreeForNetwork)(txidVersion, shared_models_1.NetworkName.EthereumRopsten_DEPRECATED)).to.throw;
        // expect(getTXIDMerkletreeForNetwork(txidVersion, NetworkName.EthereumSepolia))
        //   .to.be.undefined; // Until poi.launchBlock is defined.
        expect(() => (0, merkletree_1.getTXIDMerkletreeForNetwork)(txidVersion, shared_models_1.NetworkName.EthereumRopsten_DEPRECATED)).to.throw;
        const { chain } = shared_models_1.NETWORK_CONFIG[shared_models_1.NetworkName.EthereumSepolia];
        expect(engine_1.RailgunVersionedSmartContracts.getShieldApprovalContract(txidVersion, chain)).to.not.be.undefined;
        if ((0, helper_test_1.isV2Test)()) {
            // TODO-V3: Remove when ready
            expect(engine_1.RelayAdaptVersionedSmartContracts.getRelayAdaptContract(txidVersion, chain)).to.not.be.undefined;
        }
        const { chain: chainEthereumRopsten } = shared_models_1.NETWORK_CONFIG[shared_models_1.NetworkName.EthereumRopsten_DEPRECATED];
        expect(() => engine_1.RelayAdaptVersionedSmartContracts.getRelayAdaptContract(txidVersion, chainEthereumRopsten)).to.throw;
        // Check that new wallet has merkletree.
        const railgunWalletInfo = await (0, wallets_1.createRailgunWallet)(mocks_test_1.MOCK_DB_ENCRYPTION_KEY, MOCK_MNEMONIC_PROVIDERS_ONLY, undefined);
        if (!(0, shared_models_1.isDefined)(railgunWalletInfo)) {
            throw new Error('Expected railgunWalletInfo.');
        }
        const wallet = (0, wallets_1.walletForID)(railgunWalletInfo.id);
        expect(wallet.getUTXOMerkletree(txidVersion, shared_models_1.NETWORK_CONFIG[shared_models_1.NetworkName.EthereumSepolia].chain)).to.not.be.undefined;
    }).timeout(15000);
    it('Should fail with invalid chain ID', async () => {
        await expect((0, load_provider_1.loadProvider)({ chainId: 55 }, shared_models_1.NetworkName.BNBChain, 10000)).rejectedWith('Invalid chain ID');
    });
    it('Should fail with invalid json', async () => {
        await expect((0, load_provider_1.loadProvider)({ chainId: 56 }, shared_models_1.NetworkName.BNBChain, 10000)).rejectedWith('Invalid fallback provider config for chain 56');
    });
});
//# sourceMappingURL=providers.test.js.map