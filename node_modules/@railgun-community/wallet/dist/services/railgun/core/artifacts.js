"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearArtifactCache = exports.overrideArtifact = exports.artifactGetterDownloadJustInTime = exports.getArtifacts = exports.setUseNativeArtifacts = exports.setArtifactStore = exports.artifactCache = void 0;
const shared_models_1 = require("@railgun-community/shared-models");
const artifact_downloader_1 = require("../../artifacts/artifact-downloader");
const artifact_util_1 = require("../../artifacts/artifact-util");
let artifactStore;
let useNativeArtifacts;
exports.artifactCache = {};
const setArtifactStore = (store) => {
    artifactStore = store;
};
exports.setArtifactStore = setArtifactStore;
const setUseNativeArtifacts = (useNative) => {
    useNativeArtifacts = useNative;
};
exports.setUseNativeArtifacts = setUseNativeArtifacts;
const getArtifacts = async (inputs) => {
    const nullifiers = inputs.nullifiers.length;
    const commitments = inputs.commitmentsOut.length;
    (0, shared_models_1.assertArtifactExists)(nullifiers, commitments);
    if (useNativeArtifacts) {
        if (commitments > 3) {
            // native-prover-small only has INPUTS (1-10) and OUTPUTS (1-3)
            throw new Error(`Native artifacts (small) only support up to 3 circuit outputs. Cannot get artifacts for circuit: ${nullifiers}x${commitments}.`);
        }
    }
    const artifactVariantString = (0, artifact_util_1.getArtifactVariantString)(nullifiers, commitments);
    return downloadAndCacheArtifact(artifactVariantString);
};
exports.getArtifacts = getArtifacts;
const downloadAndCacheArtifact = async (artifactVariantString) => {
    // Use artifact in cache if available.
    const cachedArtifact = exports.artifactCache[artifactVariantString];
    if ((0, shared_models_1.isDefined)(cachedArtifact)) {
        return cachedArtifact;
    }
    const downloader = new artifact_downloader_1.ArtifactDownloader(artifactStore, useNativeArtifacts);
    // Try to pull previously downloaded from storage.
    try {
        const downloadedArtifacts = await downloader.getDownloadedArtifacts(artifactVariantString);
        exports.artifactCache[artifactVariantString] = downloadedArtifacts;
        return downloadedArtifacts;
    }
    catch (err) {
        // No op. Artifacts not yet downloaded.
    }
    // Download anew. Throws upon error.
    await downloader.downloadArtifacts(artifactVariantString);
    const downloadedArtifacts = await downloader.getDownloadedArtifacts(artifactVariantString);
    exports.artifactCache[artifactVariantString] = downloadedArtifacts;
    return downloadedArtifacts;
};
const getArtifactsPOI = (maxInputs, maxOutputs) => {
    const artifactVariant = (0, artifact_util_1.getArtifactVariantStringPOI)(maxInputs, maxOutputs);
    return downloadAndCacheArtifact(artifactVariant);
};
exports.artifactGetterDownloadJustInTime = {
    assertArtifactExists: shared_models_1.assertArtifactExists,
    getArtifacts: exports.getArtifacts,
    getArtifactsPOI,
};
const overrideArtifact = (artifactVariant, artifact) => {
    exports.artifactCache[artifactVariant] = artifact;
};
exports.overrideArtifact = overrideArtifact;
const clearArtifactCache = () => {
    for (const key in exports.artifactCache) {
        if ((0, shared_models_1.isDefined)(exports.artifactCache[key])) {
            delete exports.artifactCache[key];
        }
    }
};
exports.clearArtifactCache = clearArtifactCache;
//# sourceMappingURL=artifacts.js.map