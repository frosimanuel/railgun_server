"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resumeIsolatedPollingProviderForNetwork = exports.pauseAllPollingProviders = exports.unloadProvider = exports.loadProvider = void 0;
const shared_models_1 = require("@railgun-community/shared-models");
const utils_1 = require("../../../utils");
const error_1 = require("../../../utils/error");
const wallet_poi_1 = require("../../poi/wallet-poi");
const engine_1 = require("./engine");
const engine_2 = require("@railgun-community/engine");
const providers_1 = require("./providers");
const wallet_poi_node_interface_1 = require("../../poi/wallet-poi-node-interface");
const createFallbackProviderForNetwork = async (networkName, fallbackProviderJsonConfig) => {
    const existingProvider = providers_1.fallbackProviderMap[networkName];
    if (existingProvider) {
        return existingProvider;
    }
    const fallbackProvider = (0, shared_models_1.createFallbackProviderFromJsonConfig)(fallbackProviderJsonConfig);
    (0, providers_1.setFallbackProviderForNetwork)(networkName, fallbackProvider);
    return fallbackProvider;
};
const createPollingProviderForNetwork = async (networkName, fallbackProvider, pollingInterval) => {
    const existingProvider = providers_1.pollingProviderMap[networkName];
    if (existingProvider) {
        return existingProvider;
    }
    const network = shared_models_1.NETWORK_CONFIG[networkName];
    if (!(0, shared_models_1.isDefined)(network)) {
        throw new Error('No network found');
    }
    const pollingProvider = await (0, engine_2.createPollingJsonRpcProviderForListeners)(fallbackProvider, network.chain.id, pollingInterval);
    (0, providers_1.setPollingProviderForNetwork)(networkName, pollingProvider);
    return pollingProvider;
};
const loadProviderForNetwork = async (chain, networkName, fallbackProviderJsonConfig, pollingInterval) => {
    (0, utils_1.sendMessage)(`Load provider for network: ${networkName}`);
    const fallbackProvider = await createFallbackProviderForNetwork(networkName, fallbackProviderJsonConfig);
    const pollingProvider = await createPollingProviderForNetwork(networkName, fallbackProvider, pollingInterval);
    const network = shared_models_1.NETWORK_CONFIG[networkName];
    const { proxyContract, relayAdaptContract, poseidonMerkleAccumulatorV3Contract, poseidonMerkleVerifierV3Contract, tokenVaultV3Contract, deploymentBlockPoseidonMerkleAccumulatorV3, deploymentBlock, publicName, poi, supportsV3, } = network;
    if (!proxyContract) {
        throw new Error(`Could not find Proxy contract for network: ${publicName}`);
    }
    if (!relayAdaptContract) {
        throw new Error(`Could not find Relay Adapt contract for network: ${publicName}`);
    }
    const engine = (0, engine_1.getEngine)();
    if (!engine.isPOINode && (0, shared_models_1.isDefined)(poi) && !wallet_poi_1.WalletPOI.started) {
        throw new Error('This network requires Proof Of Innocence. Pass "poiNodeURL" to startRailgunEngine to initialize POI before loading this provider.');
    }
    const deploymentBlocks = {
        [shared_models_1.TXIDVersion.V2_PoseidonMerkle]: deploymentBlock ?? 0,
        [shared_models_1.TXIDVersion.V3_PoseidonMerkle]: deploymentBlockPoseidonMerkleAccumulatorV3 ?? 0,
    };
    // This function will set up the contracts for this chain.
    // Throws if provider does not respond.
    await engine.loadNetwork(chain, proxyContract, relayAdaptContract, poseidonMerkleAccumulatorV3Contract, poseidonMerkleVerifierV3Contract, tokenVaultV3Contract, fallbackProvider, pollingProvider, deploymentBlocks, poi?.launchBlock, supportsV3);
};
/**
 * Note: The first provider listed in your fallback provider config is used as a polling provider
 * for new RAILGUN events (balance updates).
 */
const loadProvider = async (fallbackProviderJsonConfig, networkName, pollingInterval = 15000) => {
    try {
        delete providers_1.fallbackProviderMap[networkName];
        const { chain, supportsV3 } = shared_models_1.NETWORK_CONFIG[networkName];
        if (fallbackProviderJsonConfig.chainId !== chain.id) {
            throw new Error('Invalid chain ID');
        }
        await loadProviderForNetwork(chain, networkName, fallbackProviderJsonConfig, pollingInterval);
        wallet_poi_node_interface_1.WalletPOINodeInterface.unpause(chain);
        const { shield: shieldFeeV2, unshield: unshieldFeeV2 } = await engine_2.RailgunVersionedSmartContracts.fees(shared_models_1.TXIDVersion.V2_PoseidonMerkle, chain);
        if (supportsV3) {
            const { shield: shieldFeeV3, unshield: unshieldFeeV3 } = await engine_2.RailgunVersionedSmartContracts.fees(shared_models_1.TXIDVersion.V3_PoseidonMerkle, chain);
            const feesSerialized = {
                shieldFeeV2: shieldFeeV2.toString(),
                unshieldFeeV2: unshieldFeeV2.toString(),
                shieldFeeV3: shieldFeeV3?.toString(),
                unshieldFeeV3: unshieldFeeV3?.toString(),
            };
            return { feesSerialized };
        }
        // Note: Shield and Unshield fees are in basis points.
        // NFT fee is in wei (though currently 0).
        const feesSerialized = {
            shieldFeeV2: shieldFeeV2.toString(),
            unshieldFeeV2: unshieldFeeV2.toString(),
            shieldFeeV3: undefined,
            unshieldFeeV3: undefined,
        };
        return { feesSerialized };
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.loadProvider.name, err);
    }
};
exports.loadProvider = loadProvider;
const unloadProvider = async (networkName) => {
    wallet_poi_node_interface_1.WalletPOINodeInterface.pause(shared_models_1.NETWORK_CONFIG[networkName].chain);
    await providers_1.fallbackProviderMap[networkName]?.destroy();
    providers_1.pollingProviderMap[networkName]?.destroy();
    delete providers_1.fallbackProviderMap[networkName];
    delete providers_1.pollingProviderMap[networkName];
};
exports.unloadProvider = unloadProvider;
const pauseAllPollingProviders = (excludeNetworkName) => {
    Object.keys(providers_1.pollingProviderMap).forEach(networkName => {
        if (networkName === excludeNetworkName) {
            return;
        }
        const pollingProvider = providers_1.pollingProviderMap[networkName];
        if ((0, shared_models_1.isDefined)(pollingProvider) && !pollingProvider.paused) {
            pollingProvider.pause();
        }
    });
};
exports.pauseAllPollingProviders = pauseAllPollingProviders;
const resumeIsolatedPollingProviderForNetwork = (networkName) => {
    (0, exports.pauseAllPollingProviders)(networkName);
    const pollingProviderForNetwork = providers_1.pollingProviderMap[networkName];
    if ((0, shared_models_1.isDefined)(pollingProviderForNetwork) &&
        pollingProviderForNetwork.paused) {
        pollingProviderForNetwork.resume();
    }
};
exports.resumeIsolatedPollingProviderForNetwork = resumeIsolatedPollingProviderForNetwork;
//# sourceMappingURL=load-provider.js.map