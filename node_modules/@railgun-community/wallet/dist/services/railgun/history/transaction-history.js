"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWalletTransactionHistory = exports.categoryForTransactionHistoryItem = void 0;
const engine_1 = require("@railgun-community/engine");
const shared_models_1 = require("@railgun-community/shared-models");
const bytes_1 = require("../util/bytes");
const error_1 = require("../../../utils/error");
const wallets_1 = require("../wallets/wallets");
const getRailgunBalanceBucketFromEngineBalanceBucket = (balanceBucket) => {
    switch (balanceBucket) {
        case engine_1.WalletBalanceBucket.Spendable:
            return shared_models_1.RailgunWalletBalanceBucket.Spendable;
        case engine_1.WalletBalanceBucket.ShieldBlocked:
            return shared_models_1.RailgunWalletBalanceBucket.ShieldBlocked;
        case engine_1.WalletBalanceBucket.ShieldPending:
            return shared_models_1.RailgunWalletBalanceBucket.ShieldPending;
        case engine_1.WalletBalanceBucket.ProofSubmitted:
            return shared_models_1.RailgunWalletBalanceBucket.ProofSubmitted;
        case engine_1.WalletBalanceBucket.MissingInternalPOI:
            return shared_models_1.RailgunWalletBalanceBucket.MissingInternalPOI;
        case engine_1.WalletBalanceBucket.MissingExternalPOI:
            return shared_models_1.RailgunWalletBalanceBucket.MissingExternalPOI;
        case engine_1.WalletBalanceBucket.Spent:
            return shared_models_1.RailgunWalletBalanceBucket.Spent;
    }
    throw new Error('Unrecognized WalletBalanceBucket');
};
const transactionHistoryReceiveTokenAmountToRailgunERC20Amount = (transactionHistoryReceiveTokenAmount) => {
    return {
        ...transactionHistoryTokenAmountToRailgunERC20Amount(transactionHistoryReceiveTokenAmount),
        memoText: transactionHistoryReceiveTokenAmount.memoText,
        senderAddress: transactionHistoryReceiveTokenAmount.senderAddress,
        shieldFee: transactionHistoryReceiveTokenAmount.shieldFee,
        hasValidPOIForActiveLists: transactionHistoryReceiveTokenAmount.hasValidPOIForActiveLists,
        balanceBucket: getRailgunBalanceBucketFromEngineBalanceBucket(transactionHistoryReceiveTokenAmount.balanceBucket),
    };
};
const transactionHistoryReceiveNFTToRailgunNFTAmount = (transactionHistoryReceiveTokenAmount) => {
    return {
        ...transactionHistoryNFTToRailgunNFTAmount(transactionHistoryReceiveTokenAmount),
        memoText: transactionHistoryReceiveTokenAmount.memoText,
        senderAddress: transactionHistoryReceiveTokenAmount.senderAddress,
        shieldFee: transactionHistoryReceiveTokenAmount.shieldFee,
        hasValidPOIForActiveLists: transactionHistoryReceiveTokenAmount.hasValidPOIForActiveLists,
        balanceBucket: getRailgunBalanceBucketFromEngineBalanceBucket(transactionHistoryReceiveTokenAmount.balanceBucket),
    };
};
const transactionHistoryTransferTokenAmountToRailgunERC20Amount = (transactionHistoryTokenAmount) => {
    return {
        ...transactionHistoryTokenAmountToRailgunERC20Amount(transactionHistoryTokenAmount),
        recipientAddress: transactionHistoryTokenAmount.recipientAddress,
        memoText: transactionHistoryTokenAmount.memoText,
        walletSource: transactionHistoryTokenAmount.walletSource,
        hasValidPOIForActiveLists: transactionHistoryTokenAmount.hasValidPOIForActiveLists,
    };
};
const transactionHistoryUnshieldTokenAmountToRailgunERC20Amount = (transactionHistoryUnshieldTokenAmount) => {
    return {
        ...transactionHistoryTransferTokenAmountToRailgunERC20Amount(transactionHistoryUnshieldTokenAmount),
        unshieldFee: transactionHistoryUnshieldTokenAmount.unshieldFee,
        hasValidPOIForActiveLists: transactionHistoryUnshieldTokenAmount.hasValidPOIForActiveLists,
    };
};
const transactionHistoryTransferNFTToRailgunNFTAmount = (transactionHistoryNFT) => {
    return {
        ...transactionHistoryNFTToRailgunNFTAmount(transactionHistoryNFT),
        memoText: transactionHistoryNFT.memoText,
        walletSource: transactionHistoryNFT.walletSource,
        recipientAddress: transactionHistoryNFT.recipientAddress,
        hasValidPOIForActiveLists: transactionHistoryNFT.hasValidPOIForActiveLists,
    };
};
const transactionHistoryUnshieldNFTToRailgunNFTAmount = (transactionHistoryNFT) => {
    return {
        ...transactionHistoryTransferNFTToRailgunNFTAmount(transactionHistoryNFT),
        unshieldFee: transactionHistoryNFT.unshieldFee,
        hasValidPOIForActiveLists: transactionHistoryNFT.hasValidPOIForActiveLists,
    };
};
const transactionHistoryTokenAmountToRailgunERC20Amount = (transactionHistoryTokenAmount) => {
    return {
        tokenAddress: (0, bytes_1.parseRailgunTokenAddress)(transactionHistoryTokenAmount.tokenData.tokenAddress).toLowerCase(),
        amount: transactionHistoryTokenAmount.amount,
        hasValidPOIForActiveLists: transactionHistoryTokenAmount.hasValidPOIForActiveLists,
    };
};
const transactionHistoryNFTToRailgunNFTAmount = (transactionHistoryNFT) => {
    return {
        nftAddress: (0, bytes_1.parseRailgunTokenAddress)(transactionHistoryNFT.tokenData.tokenAddress).toLowerCase(),
        nftTokenType: transactionHistoryNFT.tokenData.tokenType,
        tokenSubID: transactionHistoryNFT.tokenData.tokenSubID,
        amount: transactionHistoryNFT.amount,
        hasValidPOIForActiveLists: transactionHistoryNFT.hasValidPOIForActiveLists,
    };
};
const filterERC20 = (tokenAmount) => {
    return tokenAmount.tokenData.tokenType === engine_1.TokenType.ERC20;
};
const filterNFT = (tokenAmount) => {
    switch (tokenAmount.tokenData.tokenType) {
        case engine_1.TokenType.ERC20:
            return false;
        case engine_1.TokenType.ERC721:
        case engine_1.TokenType.ERC1155:
            return tokenAmount.amount > BigInt(0);
    }
};
const receiveERC20AmountsHaveShieldFee = (receiveERC20Amounts) => {
    return receiveERC20Amounts.find(amount => amount.shieldFee) != null;
};
const categoryForTransactionHistoryItem = (historyItem) => {
    const hasTransferNFTs = historyItem.transferNFTAmounts.length > 0;
    const hasReceiveNFTs = historyItem.receiveNFTAmounts.length > 0;
    const hasUnshieldNFTs = historyItem.unshieldNFTAmounts.length > 0;
    if (hasTransferNFTs || hasReceiveNFTs || hasUnshieldNFTs) {
        // Some kind of NFT Transfer. Unhandled case.
        return shared_models_1.TransactionHistoryItemCategory.Unknown;
    }
    const hasTransferERC20s = historyItem.transferERC20Amounts.length > 0;
    const hasReceiveERC20s = historyItem.receiveERC20Amounts.length > 0;
    const hasUnshieldERC20s = historyItem.unshieldERC20Amounts.length > 0;
    if (hasTransferERC20s && !hasReceiveERC20s && !hasUnshieldERC20s) {
        // Only transfer erc20s.
        return shared_models_1.TransactionHistoryItemCategory.TransferSendERC20s;
    }
    if (!hasTransferERC20s && hasReceiveERC20s && !hasUnshieldERC20s) {
        // Only receive erc20s.
        const hasShieldFee = receiveERC20AmountsHaveShieldFee(historyItem.receiveERC20Amounts);
        if (hasShieldFee) {
            // Note: Shield fees were added to contract events in Mar 2023.
            // Prior shields will show as TransferReceiveERC20s without fees.
            return shared_models_1.TransactionHistoryItemCategory.ShieldERC20s;
        }
        return shared_models_1.TransactionHistoryItemCategory.TransferReceiveERC20s;
    }
    if (!hasTransferERC20s && !hasReceiveERC20s && hasUnshieldERC20s) {
        // Only unshield erc20s.
        return shared_models_1.TransactionHistoryItemCategory.UnshieldERC20s;
    }
    return shared_models_1.TransactionHistoryItemCategory.Unknown;
};
exports.categoryForTransactionHistoryItem = categoryForTransactionHistoryItem;
const serializeTransactionHistory = (transactionHistory) => {
    const historyItemsUncategorized = transactionHistory.map(historyEntry => ({
        txidVersion: historyEntry.txidVersion,
        txid: engine_1.ByteUtils.formatToByteLength(historyEntry.txid, engine_1.ByteLength.UINT_256, true),
        blockNumber: historyEntry.blockNumber,
        timestamp: historyEntry.timestamp,
        transferERC20Amounts: historyEntry.transferTokenAmounts
            .filter(filterERC20)
            .map(transactionHistoryTransferTokenAmountToRailgunERC20Amount),
        broadcasterFeeERC20Amount: historyEntry.broadcasterFeeTokenAmount
            ? transactionHistoryTokenAmountToRailgunERC20Amount(historyEntry.broadcasterFeeTokenAmount)
            : undefined,
        changeERC20Amounts: historyEntry.changeTokenAmounts
            .filter(filterERC20)
            .map(transactionHistoryTokenAmountToRailgunERC20Amount),
        receiveERC20Amounts: historyEntry.receiveTokenAmounts
            .filter(filterERC20)
            .map(transactionHistoryReceiveTokenAmountToRailgunERC20Amount),
        unshieldERC20Amounts: historyEntry.unshieldTokenAmounts
            .filter(filterERC20)
            .map(transactionHistoryUnshieldTokenAmountToRailgunERC20Amount),
        receiveNFTAmounts: historyEntry.receiveTokenAmounts
            .filter(filterNFT)
            .map(transactionHistoryReceiveNFTToRailgunNFTAmount),
        transferNFTAmounts: historyEntry.transferTokenAmounts
            .filter(filterNFT)
            .map(transactionHistoryTransferNFTToRailgunNFTAmount),
        unshieldNFTAmounts: historyEntry.unshieldTokenAmounts
            .filter(filterNFT)
            .map(transactionHistoryUnshieldNFTToRailgunNFTAmount),
        version: historyEntry.version,
        category: shared_models_1.TransactionHistoryItemCategory.Unknown,
    }));
    // Add category for items based on token types.
    return historyItemsUncategorized.map(historyItem => ({
        ...historyItem,
        category: (0, exports.categoryForTransactionHistoryItem)(historyItem),
    }));
};
const getWalletTransactionHistory = async (chain, railgunWalletID, startingBlock) => {
    try {
        const wallet = (0, wallets_1.walletForID)(railgunWalletID);
        const transactionHistory = await wallet.getTransactionHistory(chain, startingBlock);
        return serializeTransactionHistory(transactionHistory);
    }
    catch (err) {
        (0, error_1.reportAndSanitizeError)(exports.getWalletTransactionHistory.name, err);
        throw new Error('Could not load RAILGUN wallet transaction history.', {
            cause: err,
        });
    }
};
exports.getWalletTransactionHistory = getWalletTransactionHistory;
//# sourceMappingURL=transaction-history.js.map