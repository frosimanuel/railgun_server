{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../../src/services/railgun/quick-sync/V3/graphql/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * TO UPDATE:\n * 1. Find all places that are \"MODIFIED\", move them into the new built index.ts (in .graphclient)\n * 2. add these comments (including eslint disables)\n * 3. move the modified index file to quick-sync/graphql/\n */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable import/no-duplicates */\n/* eslint-disable @typescript-eslint/ban-types */\n/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\n/* eslint-disable import/newline-after-import */\n/* eslint-disable prefer-template */\n/* eslint-disable @typescript-eslint/no-unsafe-return */\n\n// @ts-nocheck\nimport {\n  GraphQLResolveInfo,\n  SelectionSetNode,\n  FieldNode,\n  GraphQLScalarType,\n  GraphQLScalarTypeConfig,\n} from 'graphql';\nimport { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\nimport { gql } from '@graphql-mesh/utils';\n\nimport type { GetMeshOptions } from '@graphql-mesh/runtime';\nimport type { YamlConfig } from '@graphql-mesh/types';\nimport { PubSub } from '@graphql-mesh/utils';\nimport { DefaultLogger } from '@graphql-mesh/utils';\nimport MeshCache from '@graphql-mesh/cache-localforage';\nimport { fetch as fetchFn } from '@whatwg-node/fetch';\n\nimport { MeshResolvedSource } from '@graphql-mesh/runtime';\nimport { MeshTransform, MeshPlugin } from '@graphql-mesh/types';\nimport GraphqlHandler from '@graphql-mesh/graphql';\nimport BareMerger from '@graphql-mesh/merger-bare';\nimport { printWithCache } from '@graphql-mesh/utils';\nimport { createMeshHTTPHandler, MeshHTTPHandler } from '@graphql-mesh/http';\nimport {\n  getMesh,\n  ExecuteMeshFn,\n  SubscribeMeshFn,\n  MeshContext as BaseMeshContext,\n  MeshInstance,\n} from '@graphql-mesh/runtime';\nimport { MeshStore, FsStoreStorageAdapter } from '@graphql-mesh/store';\nimport { path as pathModule } from '@graphql-mesh/cross-helpers';\nimport { ImportFn } from '@graphql-mesh/types';\nimport type { MumbaiTypes } from './.graphclient/sources/mumbai/types';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = {\n  [K in keyof T]: T[K];\n};\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & {\n  [SubKey in K]?: Maybe<T[SubKey]>;\n};\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {\n  [SubKey in K]: Maybe<T[SubKey]>;\n};\nexport type RequireFields<T, K extends keyof T> = Omit<T, K> & {\n  [P in K]-?: NonNullable<T[P]>;\n};\n\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  BigDecimal: string; // MODIFIED\n  BigInt: string; // MODIFIED\n  Bytes: string; // MODIFIED\n  Int8: string; // MODIFIED\n};\n\nexport type BlockChangedFilter = {\n  number_gte: Scalars['Int'];\n};\n\nexport type Block_height = {\n  hash?: InputMaybe<Scalars['Bytes']>;\n  number?: InputMaybe<Scalars['Int']>;\n  number_gte?: InputMaybe<Scalars['Int']>;\n};\n\nexport type Commitment = {\n  id: Scalars['Bytes'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hashes: Array<Scalars['Bytes']>;\n};\n\nexport type CommitmentCiphertext = {\n  id: Scalars['Bytes'];\n  ciphertext: Scalars['Bytes'];\n  blindedSenderViewingKey: Scalars['Bytes'];\n  blindedReceiverViewingKey: Scalars['Bytes'];\n};\n\nexport type CommitmentCiphertext_filter = {\n  id?: InputMaybe<Scalars['Bytes']>;\n  id_not?: InputMaybe<Scalars['Bytes']>;\n  id_gt?: InputMaybe<Scalars['Bytes']>;\n  id_lt?: InputMaybe<Scalars['Bytes']>;\n  id_gte?: InputMaybe<Scalars['Bytes']>;\n  id_lte?: InputMaybe<Scalars['Bytes']>;\n  id_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_contains?: InputMaybe<Scalars['Bytes']>;\n  id_not_contains?: InputMaybe<Scalars['Bytes']>;\n  ciphertext?: InputMaybe<Scalars['Bytes']>;\n  ciphertext_not?: InputMaybe<Scalars['Bytes']>;\n  ciphertext_gt?: InputMaybe<Scalars['Bytes']>;\n  ciphertext_lt?: InputMaybe<Scalars['Bytes']>;\n  ciphertext_gte?: InputMaybe<Scalars['Bytes']>;\n  ciphertext_lte?: InputMaybe<Scalars['Bytes']>;\n  ciphertext_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  ciphertext_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  ciphertext_contains?: InputMaybe<Scalars['Bytes']>;\n  ciphertext_not_contains?: InputMaybe<Scalars['Bytes']>;\n  blindedSenderViewingKey?: InputMaybe<Scalars['Bytes']>;\n  blindedSenderViewingKey_not?: InputMaybe<Scalars['Bytes']>;\n  blindedSenderViewingKey_gt?: InputMaybe<Scalars['Bytes']>;\n  blindedSenderViewingKey_lt?: InputMaybe<Scalars['Bytes']>;\n  blindedSenderViewingKey_gte?: InputMaybe<Scalars['Bytes']>;\n  blindedSenderViewingKey_lte?: InputMaybe<Scalars['Bytes']>;\n  blindedSenderViewingKey_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  blindedSenderViewingKey_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  blindedSenderViewingKey_contains?: InputMaybe<Scalars['Bytes']>;\n  blindedSenderViewingKey_not_contains?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey_not?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey_gt?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey_lt?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey_gte?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey_lte?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  blindedReceiverViewingKey_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  blindedReceiverViewingKey_contains?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey_not_contains?: InputMaybe<Scalars['Bytes']>;\n  /** Filter for the block changed event. */\n  _change_block?: InputMaybe<BlockChangedFilter>;\n  and?: InputMaybe<Array<InputMaybe<CommitmentCiphertext_filter>>>;\n  or?: InputMaybe<Array<InputMaybe<CommitmentCiphertext_filter>>>;\n};\n\nexport type CommitmentCiphertext_orderBy =\n  | 'id'\n  | 'ciphertext'\n  | 'blindedSenderViewingKey'\n  | 'blindedReceiverViewingKey';\n\nexport type CommitmentPreimage = {\n  id: Scalars['Bytes'];\n  npk: Scalars['Bytes'];\n  token: Token;\n  value: Scalars['BigInt'];\n};\n\nexport type CommitmentPreimage_filter = {\n  id?: InputMaybe<Scalars['Bytes']>;\n  id_not?: InputMaybe<Scalars['Bytes']>;\n  id_gt?: InputMaybe<Scalars['Bytes']>;\n  id_lt?: InputMaybe<Scalars['Bytes']>;\n  id_gte?: InputMaybe<Scalars['Bytes']>;\n  id_lte?: InputMaybe<Scalars['Bytes']>;\n  id_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_contains?: InputMaybe<Scalars['Bytes']>;\n  id_not_contains?: InputMaybe<Scalars['Bytes']>;\n  npk?: InputMaybe<Scalars['Bytes']>;\n  npk_not?: InputMaybe<Scalars['Bytes']>;\n  npk_gt?: InputMaybe<Scalars['Bytes']>;\n  npk_lt?: InputMaybe<Scalars['Bytes']>;\n  npk_gte?: InputMaybe<Scalars['Bytes']>;\n  npk_lte?: InputMaybe<Scalars['Bytes']>;\n  npk_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  npk_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  npk_contains?: InputMaybe<Scalars['Bytes']>;\n  npk_not_contains?: InputMaybe<Scalars['Bytes']>;\n  token?: InputMaybe<Scalars['String']>;\n  token_not?: InputMaybe<Scalars['String']>;\n  token_gt?: InputMaybe<Scalars['String']>;\n  token_lt?: InputMaybe<Scalars['String']>;\n  token_gte?: InputMaybe<Scalars['String']>;\n  token_lte?: InputMaybe<Scalars['String']>;\n  token_in?: InputMaybe<Array<Scalars['String']>>;\n  token_not_in?: InputMaybe<Array<Scalars['String']>>;\n  token_contains?: InputMaybe<Scalars['String']>;\n  token_contains_nocase?: InputMaybe<Scalars['String']>;\n  token_not_contains?: InputMaybe<Scalars['String']>;\n  token_not_contains_nocase?: InputMaybe<Scalars['String']>;\n  token_starts_with?: InputMaybe<Scalars['String']>;\n  token_starts_with_nocase?: InputMaybe<Scalars['String']>;\n  token_not_starts_with?: InputMaybe<Scalars['String']>;\n  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;\n  token_ends_with?: InputMaybe<Scalars['String']>;\n  token_ends_with_nocase?: InputMaybe<Scalars['String']>;\n  token_not_ends_with?: InputMaybe<Scalars['String']>;\n  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;\n  token_?: InputMaybe<Token_filter>;\n  value?: InputMaybe<Scalars['BigInt']>;\n  value_not?: InputMaybe<Scalars['BigInt']>;\n  value_gt?: InputMaybe<Scalars['BigInt']>;\n  value_lt?: InputMaybe<Scalars['BigInt']>;\n  value_gte?: InputMaybe<Scalars['BigInt']>;\n  value_lte?: InputMaybe<Scalars['BigInt']>;\n  value_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  value_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  /** Filter for the block changed event. */\n  _change_block?: InputMaybe<BlockChangedFilter>;\n  and?: InputMaybe<Array<InputMaybe<CommitmentPreimage_filter>>>;\n  or?: InputMaybe<Array<InputMaybe<CommitmentPreimage_filter>>>;\n};\n\nexport type CommitmentPreimage_orderBy =\n  | 'id'\n  | 'npk'\n  | 'token'\n  | 'token__id'\n  | 'token__tokenType'\n  | 'token__tokenAddress'\n  | 'token__tokenSubID'\n  | 'value';\n\nexport type CommitmentType =\n  | 'ShieldCommitment'\n  | 'TransactCommitment'\n  | 'LegacyGeneratedCommitment'\n  | 'LegacyEncryptedCommitment';\n\nexport type Commitment_filter = {\n  id?: InputMaybe<Scalars['Bytes']>;\n  id_not?: InputMaybe<Scalars['Bytes']>;\n  id_gt?: InputMaybe<Scalars['Bytes']>;\n  id_lt?: InputMaybe<Scalars['Bytes']>;\n  id_gte?: InputMaybe<Scalars['Bytes']>;\n  id_lte?: InputMaybe<Scalars['Bytes']>;\n  id_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_contains?: InputMaybe<Scalars['Bytes']>;\n  id_not_contains?: InputMaybe<Scalars['Bytes']>;\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;\n  treeNumber?: InputMaybe<Scalars['Int']>;\n  treeNumber_not?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType?: InputMaybe<CommitmentType>;\n  commitmentType_not?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hashes?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_not?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  /** Filter for the block changed event. */\n  _change_block?: InputMaybe<BlockChangedFilter>;\n  and?: InputMaybe<Array<InputMaybe<Commitment_filter>>>;\n  or?: InputMaybe<Array<InputMaybe<Commitment_filter>>>;\n};\n\nexport type Commitment_orderBy =\n  | 'id'\n  | 'blockNumber'\n  | 'blockTimestamp'\n  | 'transactionHash'\n  | 'treeNumber'\n  | 'commitmentType'\n  | 'hashes';\n\nexport type Nullifier = {\n  id: Scalars['Bytes'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  nullifier: Scalars['Bytes'];\n};\n\nexport type Nullifier_filter = {\n  id?: InputMaybe<Scalars['Bytes']>;\n  id_not?: InputMaybe<Scalars['Bytes']>;\n  id_gt?: InputMaybe<Scalars['Bytes']>;\n  id_lt?: InputMaybe<Scalars['Bytes']>;\n  id_gte?: InputMaybe<Scalars['Bytes']>;\n  id_lte?: InputMaybe<Scalars['Bytes']>;\n  id_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_contains?: InputMaybe<Scalars['Bytes']>;\n  id_not_contains?: InputMaybe<Scalars['Bytes']>;\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;\n  treeNumber?: InputMaybe<Scalars['Int']>;\n  treeNumber_not?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  nullifier?: InputMaybe<Scalars['Bytes']>;\n  nullifier_not?: InputMaybe<Scalars['Bytes']>;\n  nullifier_gt?: InputMaybe<Scalars['Bytes']>;\n  nullifier_lt?: InputMaybe<Scalars['Bytes']>;\n  nullifier_gte?: InputMaybe<Scalars['Bytes']>;\n  nullifier_lte?: InputMaybe<Scalars['Bytes']>;\n  nullifier_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  nullifier_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  nullifier_contains?: InputMaybe<Scalars['Bytes']>;\n  nullifier_not_contains?: InputMaybe<Scalars['Bytes']>;\n  /** Filter for the block changed event. */\n  _change_block?: InputMaybe<BlockChangedFilter>;\n  and?: InputMaybe<Array<InputMaybe<Nullifier_filter>>>;\n  or?: InputMaybe<Array<InputMaybe<Nullifier_filter>>>;\n};\n\nexport type Nullifier_orderBy =\n  | 'id'\n  | 'blockNumber'\n  | 'blockTimestamp'\n  | 'transactionHash'\n  | 'treeNumber'\n  | 'nullifier';\n\n/** Defines the order direction, either ascending or descending */\nexport type OrderDirection = 'asc' | 'desc';\n\nexport type Query = {\n  token?: Maybe<Token>;\n  tokens: Array<Token>;\n  commitmentPreimage?: Maybe<CommitmentPreimage>;\n  commitmentPreimages: Array<CommitmentPreimage>;\n  commitmentCiphertext?: Maybe<CommitmentCiphertext>;\n  commitmentCiphertexts: Array<CommitmentCiphertext>;\n  shieldCommitment?: Maybe<ShieldCommitment>;\n  shieldCommitments: Array<ShieldCommitment>;\n  transactCommitment?: Maybe<TransactCommitment>;\n  transactCommitments: Array<TransactCommitment>;\n  unshield?: Maybe<Unshield>;\n  unshields: Array<Unshield>;\n  nullifier?: Maybe<Nullifier>;\n  nullifiers: Array<Nullifier>;\n  railgunTransaction?: Maybe<RailgunTransaction>;\n  railgunTransactions: Array<RailgunTransaction>;\n  verificationHash?: Maybe<VerificationHash>;\n  verificationHashes: Array<VerificationHash>;\n  commitment?: Maybe<Commitment>;\n  commitments: Array<Commitment>;\n  /** Access to subgraph metadata */\n  _meta?: Maybe<_Meta_>;\n};\n\nexport type QuerytokenArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QuerytokensArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<Token_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<Token_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QuerycommitmentPreimageArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QuerycommitmentPreimagesArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<CommitmentPreimage_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<CommitmentPreimage_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QuerycommitmentCiphertextArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QuerycommitmentCiphertextsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<CommitmentCiphertext_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<CommitmentCiphertext_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QueryshieldCommitmentArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QueryshieldCommitmentsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ShieldCommitment_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<ShieldCommitment_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QuerytransactCommitmentArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QuerytransactCommitmentsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<TransactCommitment_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<TransactCommitment_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QueryunshieldArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QueryunshieldsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<Unshield_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<Unshield_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QuerynullifierArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QuerynullifiersArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<Nullifier_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<Nullifier_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QueryrailgunTransactionArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QueryrailgunTransactionsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RailgunTransaction_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<RailgunTransaction_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QueryverificationHashArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QueryverificationHashesArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<VerificationHash_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<VerificationHash_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QuerycommitmentArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type QuerycommitmentsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<Commitment_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<Commitment_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type Query_metaArgs = {\n  block?: InputMaybe<Block_height>;\n};\n\nexport type RailgunTransaction = {\n  id: Scalars['Bytes'];\n  blockNumber: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  nullifiers: Array<Scalars['Bytes']>;\n  commitments: Array<Scalars['Bytes']>;\n  boundParamsHash: Scalars['Bytes'];\n  hasUnshield: Scalars['Boolean'];\n  utxoTreeIn: Scalars['BigInt'];\n  utxoTreeOut: Scalars['BigInt'];\n  utxoBatchStartPositionOut: Scalars['BigInt'];\n  unshieldToken: Token;\n  unshieldToAddress: Scalars['Bytes'];\n  unshieldValue: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  verificationHash: Scalars['Bytes'];\n};\n\nexport type RailgunTransaction_filter = {\n  id?: InputMaybe<Scalars['Bytes']>;\n  id_not?: InputMaybe<Scalars['Bytes']>;\n  id_gt?: InputMaybe<Scalars['Bytes']>;\n  id_lt?: InputMaybe<Scalars['Bytes']>;\n  id_gte?: InputMaybe<Scalars['Bytes']>;\n  id_lte?: InputMaybe<Scalars['Bytes']>;\n  id_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_contains?: InputMaybe<Scalars['Bytes']>;\n  id_not_contains?: InputMaybe<Scalars['Bytes']>;\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;\n  nullifiers?: InputMaybe<Array<Scalars['Bytes']>>;\n  nullifiers_not?: InputMaybe<Array<Scalars['Bytes']>>;\n  nullifiers_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  nullifiers_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  nullifiers_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  nullifiers_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments_not?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  boundParamsHash?: InputMaybe<Scalars['Bytes']>;\n  boundParamsHash_not?: InputMaybe<Scalars['Bytes']>;\n  boundParamsHash_gt?: InputMaybe<Scalars['Bytes']>;\n  boundParamsHash_lt?: InputMaybe<Scalars['Bytes']>;\n  boundParamsHash_gte?: InputMaybe<Scalars['Bytes']>;\n  boundParamsHash_lte?: InputMaybe<Scalars['Bytes']>;\n  boundParamsHash_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  boundParamsHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  boundParamsHash_contains?: InputMaybe<Scalars['Bytes']>;\n  boundParamsHash_not_contains?: InputMaybe<Scalars['Bytes']>;\n  hasUnshield?: InputMaybe<Scalars['Boolean']>;\n  hasUnshield_not?: InputMaybe<Scalars['Boolean']>;\n  hasUnshield_in?: InputMaybe<Array<Scalars['Boolean']>>;\n  hasUnshield_not_in?: InputMaybe<Array<Scalars['Boolean']>>;\n  utxoTreeIn?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_not?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_gt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_lt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_gte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_lte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoTreeIn_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoTreeOut?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_not?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_gt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_lt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_gte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_lte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoTreeOut_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoBatchStartPositionOut?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_not?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_gt?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_lt?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_gte?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_lte?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoBatchStartPositionOut_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  unshieldToken?: InputMaybe<Scalars['String']>;\n  unshieldToken_not?: InputMaybe<Scalars['String']>;\n  unshieldToken_gt?: InputMaybe<Scalars['String']>;\n  unshieldToken_lt?: InputMaybe<Scalars['String']>;\n  unshieldToken_gte?: InputMaybe<Scalars['String']>;\n  unshieldToken_lte?: InputMaybe<Scalars['String']>;\n  unshieldToken_in?: InputMaybe<Array<Scalars['String']>>;\n  unshieldToken_not_in?: InputMaybe<Array<Scalars['String']>>;\n  unshieldToken_contains?: InputMaybe<Scalars['String']>;\n  unshieldToken_contains_nocase?: InputMaybe<Scalars['String']>;\n  unshieldToken_not_contains?: InputMaybe<Scalars['String']>;\n  unshieldToken_not_contains_nocase?: InputMaybe<Scalars['String']>;\n  unshieldToken_starts_with?: InputMaybe<Scalars['String']>;\n  unshieldToken_starts_with_nocase?: InputMaybe<Scalars['String']>;\n  unshieldToken_not_starts_with?: InputMaybe<Scalars['String']>;\n  unshieldToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;\n  unshieldToken_ends_with?: InputMaybe<Scalars['String']>;\n  unshieldToken_ends_with_nocase?: InputMaybe<Scalars['String']>;\n  unshieldToken_not_ends_with?: InputMaybe<Scalars['String']>;\n  unshieldToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;\n  unshieldToken_?: InputMaybe<Token_filter>;\n  unshieldToAddress?: InputMaybe<Scalars['Bytes']>;\n  unshieldToAddress_not?: InputMaybe<Scalars['Bytes']>;\n  unshieldToAddress_gt?: InputMaybe<Scalars['Bytes']>;\n  unshieldToAddress_lt?: InputMaybe<Scalars['Bytes']>;\n  unshieldToAddress_gte?: InputMaybe<Scalars['Bytes']>;\n  unshieldToAddress_lte?: InputMaybe<Scalars['Bytes']>;\n  unshieldToAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  unshieldToAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  unshieldToAddress_contains?: InputMaybe<Scalars['Bytes']>;\n  unshieldToAddress_not_contains?: InputMaybe<Scalars['Bytes']>;\n  unshieldValue?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_not?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_gt?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_lt?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_gte?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_lte?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  unshieldValue_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  verificationHash?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_not?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_gt?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_lt?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_gte?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_lte?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  verificationHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  verificationHash_contains?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_not_contains?: InputMaybe<Scalars['Bytes']>;\n  /** Filter for the block changed event. */\n  _change_block?: InputMaybe<BlockChangedFilter>;\n  and?: InputMaybe<Array<InputMaybe<RailgunTransaction_filter>>>;\n  or?: InputMaybe<Array<InputMaybe<RailgunTransaction_filter>>>;\n};\n\nexport type RailgunTransaction_orderBy =\n  | 'id'\n  | 'blockNumber'\n  | 'transactionHash'\n  | 'nullifiers'\n  | 'commitments'\n  | 'boundParamsHash'\n  | 'hasUnshield'\n  | 'utxoTreeIn'\n  | 'utxoTreeOut'\n  | 'utxoBatchStartPositionOut'\n  | 'unshieldToken'\n  | 'unshieldToken__id'\n  | 'unshieldToken__tokenType'\n  | 'unshieldToken__tokenAddress'\n  | 'unshieldToken__tokenSubID'\n  | 'unshieldToAddress'\n  | 'unshieldValue'\n  | 'blockTimestamp'\n  | 'verificationHash';\n\nexport type ShieldCommitment = Commitment & {\n  id: Scalars['Bytes'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hashes: Array<Scalars['Bytes']>;\n  from: Scalars['Bytes'];\n  treePosition: Scalars['Int'];\n  preimage: CommitmentPreimage;\n  encryptedBundle: Array<Scalars['Bytes']>;\n  shieldKey: Scalars['Bytes'];\n  fee: Scalars['BigInt'];\n};\n\nexport type ShieldCommitment_filter = {\n  id?: InputMaybe<Scalars['Bytes']>;\n  id_not?: InputMaybe<Scalars['Bytes']>;\n  id_gt?: InputMaybe<Scalars['Bytes']>;\n  id_lt?: InputMaybe<Scalars['Bytes']>;\n  id_gte?: InputMaybe<Scalars['Bytes']>;\n  id_lte?: InputMaybe<Scalars['Bytes']>;\n  id_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_contains?: InputMaybe<Scalars['Bytes']>;\n  id_not_contains?: InputMaybe<Scalars['Bytes']>;\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;\n  treeNumber?: InputMaybe<Scalars['Int']>;\n  treeNumber_not?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType?: InputMaybe<CommitmentType>;\n  commitmentType_not?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hashes?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_not?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  from?: InputMaybe<Scalars['Bytes']>;\n  from_not?: InputMaybe<Scalars['Bytes']>;\n  from_gt?: InputMaybe<Scalars['Bytes']>;\n  from_lt?: InputMaybe<Scalars['Bytes']>;\n  from_gte?: InputMaybe<Scalars['Bytes']>;\n  from_lte?: InputMaybe<Scalars['Bytes']>;\n  from_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  from_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  from_contains?: InputMaybe<Scalars['Bytes']>;\n  from_not_contains?: InputMaybe<Scalars['Bytes']>;\n  treePosition?: InputMaybe<Scalars['Int']>;\n  treePosition_not?: InputMaybe<Scalars['Int']>;\n  treePosition_gt?: InputMaybe<Scalars['Int']>;\n  treePosition_lt?: InputMaybe<Scalars['Int']>;\n  treePosition_gte?: InputMaybe<Scalars['Int']>;\n  treePosition_lte?: InputMaybe<Scalars['Int']>;\n  treePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  preimage?: InputMaybe<Scalars['String']>;\n  preimage_not?: InputMaybe<Scalars['String']>;\n  preimage_gt?: InputMaybe<Scalars['String']>;\n  preimage_lt?: InputMaybe<Scalars['String']>;\n  preimage_gte?: InputMaybe<Scalars['String']>;\n  preimage_lte?: InputMaybe<Scalars['String']>;\n  preimage_in?: InputMaybe<Array<Scalars['String']>>;\n  preimage_not_in?: InputMaybe<Array<Scalars['String']>>;\n  preimage_contains?: InputMaybe<Scalars['String']>;\n  preimage_contains_nocase?: InputMaybe<Scalars['String']>;\n  preimage_not_contains?: InputMaybe<Scalars['String']>;\n  preimage_not_contains_nocase?: InputMaybe<Scalars['String']>;\n  preimage_starts_with?: InputMaybe<Scalars['String']>;\n  preimage_starts_with_nocase?: InputMaybe<Scalars['String']>;\n  preimage_not_starts_with?: InputMaybe<Scalars['String']>;\n  preimage_not_starts_with_nocase?: InputMaybe<Scalars['String']>;\n  preimage_ends_with?: InputMaybe<Scalars['String']>;\n  preimage_ends_with_nocase?: InputMaybe<Scalars['String']>;\n  preimage_not_ends_with?: InputMaybe<Scalars['String']>;\n  preimage_not_ends_with_nocase?: InputMaybe<Scalars['String']>;\n  preimage_?: InputMaybe<CommitmentPreimage_filter>;\n  encryptedBundle?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedBundle_not?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedBundle_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedBundle_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedBundle_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedBundle_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  shieldKey?: InputMaybe<Scalars['Bytes']>;\n  shieldKey_not?: InputMaybe<Scalars['Bytes']>;\n  shieldKey_gt?: InputMaybe<Scalars['Bytes']>;\n  shieldKey_lt?: InputMaybe<Scalars['Bytes']>;\n  shieldKey_gte?: InputMaybe<Scalars['Bytes']>;\n  shieldKey_lte?: InputMaybe<Scalars['Bytes']>;\n  shieldKey_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  shieldKey_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  shieldKey_contains?: InputMaybe<Scalars['Bytes']>;\n  shieldKey_not_contains?: InputMaybe<Scalars['Bytes']>;\n  fee?: InputMaybe<Scalars['BigInt']>;\n  fee_not?: InputMaybe<Scalars['BigInt']>;\n  fee_gt?: InputMaybe<Scalars['BigInt']>;\n  fee_lt?: InputMaybe<Scalars['BigInt']>;\n  fee_gte?: InputMaybe<Scalars['BigInt']>;\n  fee_lte?: InputMaybe<Scalars['BigInt']>;\n  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  /** Filter for the block changed event. */\n  _change_block?: InputMaybe<BlockChangedFilter>;\n  and?: InputMaybe<Array<InputMaybe<ShieldCommitment_filter>>>;\n  or?: InputMaybe<Array<InputMaybe<ShieldCommitment_filter>>>;\n};\n\nexport type ShieldCommitment_orderBy =\n  | 'id'\n  | 'blockNumber'\n  | 'blockTimestamp'\n  | 'transactionHash'\n  | 'treeNumber'\n  | 'commitmentType'\n  | 'hashes'\n  | 'from'\n  | 'treePosition'\n  | 'preimage'\n  | 'preimage__id'\n  | 'preimage__npk'\n  | 'preimage__value'\n  | 'encryptedBundle'\n  | 'shieldKey'\n  | 'fee';\n\nexport type Subscription = {\n  token?: Maybe<Token>;\n  tokens: Array<Token>;\n  commitmentPreimage?: Maybe<CommitmentPreimage>;\n  commitmentPreimages: Array<CommitmentPreimage>;\n  commitmentCiphertext?: Maybe<CommitmentCiphertext>;\n  commitmentCiphertexts: Array<CommitmentCiphertext>;\n  shieldCommitment?: Maybe<ShieldCommitment>;\n  shieldCommitments: Array<ShieldCommitment>;\n  transactCommitment?: Maybe<TransactCommitment>;\n  transactCommitments: Array<TransactCommitment>;\n  unshield?: Maybe<Unshield>;\n  unshields: Array<Unshield>;\n  nullifier?: Maybe<Nullifier>;\n  nullifiers: Array<Nullifier>;\n  railgunTransaction?: Maybe<RailgunTransaction>;\n  railgunTransactions: Array<RailgunTransaction>;\n  verificationHash?: Maybe<VerificationHash>;\n  verificationHashes: Array<VerificationHash>;\n  commitment?: Maybe<Commitment>;\n  commitments: Array<Commitment>;\n  /** Access to subgraph metadata */\n  _meta?: Maybe<_Meta_>;\n};\n\nexport type SubscriptiontokenArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptiontokensArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<Token_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<Token_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptioncommitmentPreimageArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptioncommitmentPreimagesArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<CommitmentPreimage_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<CommitmentPreimage_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptioncommitmentCiphertextArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptioncommitmentCiphertextsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<CommitmentCiphertext_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<CommitmentCiphertext_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptionshieldCommitmentArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptionshieldCommitmentsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ShieldCommitment_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<ShieldCommitment_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptiontransactCommitmentArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptiontransactCommitmentsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<TransactCommitment_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<TransactCommitment_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptionunshieldArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptionunshieldsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<Unshield_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<Unshield_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptionnullifierArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptionnullifiersArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<Nullifier_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<Nullifier_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptionrailgunTransactionArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptionrailgunTransactionsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RailgunTransaction_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<RailgunTransaction_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptionverificationHashArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptionverificationHashesArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<VerificationHash_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<VerificationHash_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptioncommitmentArgs = {\n  id: Scalars['ID'];\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type SubscriptioncommitmentsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<Commitment_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<Commitment_filter>;\n  block?: InputMaybe<Block_height>;\n  subgraphError?: _SubgraphErrorPolicy_;\n};\n\nexport type Subscription_metaArgs = {\n  block?: InputMaybe<Block_height>;\n};\n\nexport type Token = {\n  id: Scalars['Bytes'];\n  tokenType: TokenType;\n  tokenAddress: Scalars['Bytes'];\n  tokenSubID: Scalars['Bytes'];\n};\n\nexport type TokenType = 'ERC20' | 'ERC721' | 'ERC1155';\n\nexport type Token_filter = {\n  id?: InputMaybe<Scalars['Bytes']>;\n  id_not?: InputMaybe<Scalars['Bytes']>;\n  id_gt?: InputMaybe<Scalars['Bytes']>;\n  id_lt?: InputMaybe<Scalars['Bytes']>;\n  id_gte?: InputMaybe<Scalars['Bytes']>;\n  id_lte?: InputMaybe<Scalars['Bytes']>;\n  id_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_contains?: InputMaybe<Scalars['Bytes']>;\n  id_not_contains?: InputMaybe<Scalars['Bytes']>;\n  tokenType?: InputMaybe<TokenType>;\n  tokenType_not?: InputMaybe<TokenType>;\n  tokenType_in?: InputMaybe<Array<TokenType>>;\n  tokenType_not_in?: InputMaybe<Array<TokenType>>;\n  tokenAddress?: InputMaybe<Scalars['Bytes']>;\n  tokenAddress_not?: InputMaybe<Scalars['Bytes']>;\n  tokenAddress_gt?: InputMaybe<Scalars['Bytes']>;\n  tokenAddress_lt?: InputMaybe<Scalars['Bytes']>;\n  tokenAddress_gte?: InputMaybe<Scalars['Bytes']>;\n  tokenAddress_lte?: InputMaybe<Scalars['Bytes']>;\n  tokenAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  tokenAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  tokenAddress_contains?: InputMaybe<Scalars['Bytes']>;\n  tokenAddress_not_contains?: InputMaybe<Scalars['Bytes']>;\n  tokenSubID?: InputMaybe<Scalars['Bytes']>;\n  tokenSubID_not?: InputMaybe<Scalars['Bytes']>;\n  tokenSubID_gt?: InputMaybe<Scalars['Bytes']>;\n  tokenSubID_lt?: InputMaybe<Scalars['Bytes']>;\n  tokenSubID_gte?: InputMaybe<Scalars['Bytes']>;\n  tokenSubID_lte?: InputMaybe<Scalars['Bytes']>;\n  tokenSubID_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  tokenSubID_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  tokenSubID_contains?: InputMaybe<Scalars['Bytes']>;\n  tokenSubID_not_contains?: InputMaybe<Scalars['Bytes']>;\n  /** Filter for the block changed event. */\n  _change_block?: InputMaybe<BlockChangedFilter>;\n  and?: InputMaybe<Array<InputMaybe<Token_filter>>>;\n  or?: InputMaybe<Array<InputMaybe<Token_filter>>>;\n};\n\nexport type Token_orderBy = 'id' | 'tokenType' | 'tokenAddress' | 'tokenSubID';\n\nexport type TransactCommitment = Commitment & {\n  id: Scalars['Bytes'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hashes: Array<Scalars['Bytes']>;\n  commitmentCiphertexts: Array<CommitmentCiphertext>;\n  batchStartTreePosition: Scalars['Int'];\n  transactIndex: Scalars['Int'];\n  senderCiphertext: Scalars['Bytes'];\n};\n\nexport type TransactCommitmentcommitmentCiphertextsArgs = {\n  skip?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<CommitmentCiphertext_orderBy>;\n  orderDirection?: InputMaybe<OrderDirection>;\n  where?: InputMaybe<CommitmentCiphertext_filter>;\n};\n\nexport type TransactCommitment_filter = {\n  id?: InputMaybe<Scalars['Bytes']>;\n  id_not?: InputMaybe<Scalars['Bytes']>;\n  id_gt?: InputMaybe<Scalars['Bytes']>;\n  id_lt?: InputMaybe<Scalars['Bytes']>;\n  id_gte?: InputMaybe<Scalars['Bytes']>;\n  id_lte?: InputMaybe<Scalars['Bytes']>;\n  id_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_contains?: InputMaybe<Scalars['Bytes']>;\n  id_not_contains?: InputMaybe<Scalars['Bytes']>;\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;\n  treeNumber?: InputMaybe<Scalars['Int']>;\n  treeNumber_not?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType?: InputMaybe<CommitmentType>;\n  commitmentType_not?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hashes?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_not?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;\n  hashes_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitmentCiphertexts?: InputMaybe<Array<Scalars['String']>>;\n  commitmentCiphertexts_not?: InputMaybe<Array<Scalars['String']>>;\n  commitmentCiphertexts_contains?: InputMaybe<Array<Scalars['String']>>;\n  commitmentCiphertexts_contains_nocase?: InputMaybe<Array<Scalars['String']>>;\n  commitmentCiphertexts_not_contains?: InputMaybe<Array<Scalars['String']>>;\n  commitmentCiphertexts_not_contains_nocase?: InputMaybe<\n    Array<Scalars['String']>\n  >;\n  commitmentCiphertexts_?: InputMaybe<CommitmentCiphertext_filter>;\n  batchStartTreePosition?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_not?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  transactIndex?: InputMaybe<Scalars['Int']>;\n  transactIndex_not?: InputMaybe<Scalars['Int']>;\n  transactIndex_gt?: InputMaybe<Scalars['Int']>;\n  transactIndex_lt?: InputMaybe<Scalars['Int']>;\n  transactIndex_gte?: InputMaybe<Scalars['Int']>;\n  transactIndex_lte?: InputMaybe<Scalars['Int']>;\n  transactIndex_in?: InputMaybe<Array<Scalars['Int']>>;\n  transactIndex_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  senderCiphertext?: InputMaybe<Scalars['Bytes']>;\n  senderCiphertext_not?: InputMaybe<Scalars['Bytes']>;\n  senderCiphertext_gt?: InputMaybe<Scalars['Bytes']>;\n  senderCiphertext_lt?: InputMaybe<Scalars['Bytes']>;\n  senderCiphertext_gte?: InputMaybe<Scalars['Bytes']>;\n  senderCiphertext_lte?: InputMaybe<Scalars['Bytes']>;\n  senderCiphertext_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  senderCiphertext_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  senderCiphertext_contains?: InputMaybe<Scalars['Bytes']>;\n  senderCiphertext_not_contains?: InputMaybe<Scalars['Bytes']>;\n  /** Filter for the block changed event. */\n  _change_block?: InputMaybe<BlockChangedFilter>;\n  and?: InputMaybe<Array<InputMaybe<TransactCommitment_filter>>>;\n  or?: InputMaybe<Array<InputMaybe<TransactCommitment_filter>>>;\n};\n\nexport type TransactCommitment_orderBy =\n  | 'id'\n  | 'blockNumber'\n  | 'blockTimestamp'\n  | 'transactionHash'\n  | 'treeNumber'\n  | 'commitmentType'\n  | 'hashes'\n  | 'commitmentCiphertexts'\n  | 'batchStartTreePosition'\n  | 'transactIndex'\n  | 'senderCiphertext';\n\nexport type Unshield = {\n  id: Scalars['Bytes'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  to: Scalars['Bytes'];\n  token: Token;\n  value: Scalars['BigInt'];\n  fee: Scalars['BigInt'];\n  transactIndex: Scalars['BigInt'];\n};\n\nexport type Unshield_filter = {\n  id?: InputMaybe<Scalars['Bytes']>;\n  id_not?: InputMaybe<Scalars['Bytes']>;\n  id_gt?: InputMaybe<Scalars['Bytes']>;\n  id_lt?: InputMaybe<Scalars['Bytes']>;\n  id_gte?: InputMaybe<Scalars['Bytes']>;\n  id_lte?: InputMaybe<Scalars['Bytes']>;\n  id_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_contains?: InputMaybe<Scalars['Bytes']>;\n  id_not_contains?: InputMaybe<Scalars['Bytes']>;\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;\n  to?: InputMaybe<Scalars['Bytes']>;\n  to_not?: InputMaybe<Scalars['Bytes']>;\n  to_gt?: InputMaybe<Scalars['Bytes']>;\n  to_lt?: InputMaybe<Scalars['Bytes']>;\n  to_gte?: InputMaybe<Scalars['Bytes']>;\n  to_lte?: InputMaybe<Scalars['Bytes']>;\n  to_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  to_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  to_contains?: InputMaybe<Scalars['Bytes']>;\n  to_not_contains?: InputMaybe<Scalars['Bytes']>;\n  token?: InputMaybe<Scalars['String']>;\n  token_not?: InputMaybe<Scalars['String']>;\n  token_gt?: InputMaybe<Scalars['String']>;\n  token_lt?: InputMaybe<Scalars['String']>;\n  token_gte?: InputMaybe<Scalars['String']>;\n  token_lte?: InputMaybe<Scalars['String']>;\n  token_in?: InputMaybe<Array<Scalars['String']>>;\n  token_not_in?: InputMaybe<Array<Scalars['String']>>;\n  token_contains?: InputMaybe<Scalars['String']>;\n  token_contains_nocase?: InputMaybe<Scalars['String']>;\n  token_not_contains?: InputMaybe<Scalars['String']>;\n  token_not_contains_nocase?: InputMaybe<Scalars['String']>;\n  token_starts_with?: InputMaybe<Scalars['String']>;\n  token_starts_with_nocase?: InputMaybe<Scalars['String']>;\n  token_not_starts_with?: InputMaybe<Scalars['String']>;\n  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;\n  token_ends_with?: InputMaybe<Scalars['String']>;\n  token_ends_with_nocase?: InputMaybe<Scalars['String']>;\n  token_not_ends_with?: InputMaybe<Scalars['String']>;\n  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;\n  token_?: InputMaybe<Token_filter>;\n  value?: InputMaybe<Scalars['BigInt']>;\n  value_not?: InputMaybe<Scalars['BigInt']>;\n  value_gt?: InputMaybe<Scalars['BigInt']>;\n  value_lt?: InputMaybe<Scalars['BigInt']>;\n  value_gte?: InputMaybe<Scalars['BigInt']>;\n  value_lte?: InputMaybe<Scalars['BigInt']>;\n  value_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  value_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  fee?: InputMaybe<Scalars['BigInt']>;\n  fee_not?: InputMaybe<Scalars['BigInt']>;\n  fee_gt?: InputMaybe<Scalars['BigInt']>;\n  fee_lt?: InputMaybe<Scalars['BigInt']>;\n  fee_gte?: InputMaybe<Scalars['BigInt']>;\n  fee_lte?: InputMaybe<Scalars['BigInt']>;\n  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactIndex?: InputMaybe<Scalars['BigInt']>;\n  transactIndex_not?: InputMaybe<Scalars['BigInt']>;\n  transactIndex_gt?: InputMaybe<Scalars['BigInt']>;\n  transactIndex_lt?: InputMaybe<Scalars['BigInt']>;\n  transactIndex_gte?: InputMaybe<Scalars['BigInt']>;\n  transactIndex_lte?: InputMaybe<Scalars['BigInt']>;\n  transactIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  /** Filter for the block changed event. */\n  _change_block?: InputMaybe<BlockChangedFilter>;\n  and?: InputMaybe<Array<InputMaybe<Unshield_filter>>>;\n  or?: InputMaybe<Array<InputMaybe<Unshield_filter>>>;\n};\n\nexport type Unshield_orderBy =\n  | 'id'\n  | 'blockNumber'\n  | 'blockTimestamp'\n  | 'transactionHash'\n  | 'to'\n  | 'token'\n  | 'token__id'\n  | 'token__tokenType'\n  | 'token__tokenAddress'\n  | 'token__tokenSubID'\n  | 'value'\n  | 'fee'\n  | 'transactIndex';\n\nexport type VerificationHash = {\n  id: Scalars['Bytes'];\n  verificationHash: Scalars['Bytes'];\n};\n\nexport type VerificationHash_filter = {\n  id?: InputMaybe<Scalars['Bytes']>;\n  id_not?: InputMaybe<Scalars['Bytes']>;\n  id_gt?: InputMaybe<Scalars['Bytes']>;\n  id_lt?: InputMaybe<Scalars['Bytes']>;\n  id_gte?: InputMaybe<Scalars['Bytes']>;\n  id_lte?: InputMaybe<Scalars['Bytes']>;\n  id_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  id_contains?: InputMaybe<Scalars['Bytes']>;\n  id_not_contains?: InputMaybe<Scalars['Bytes']>;\n  verificationHash?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_not?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_gt?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_lt?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_gte?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_lte?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  verificationHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;\n  verificationHash_contains?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_not_contains?: InputMaybe<Scalars['Bytes']>;\n  /** Filter for the block changed event. */\n  _change_block?: InputMaybe<BlockChangedFilter>;\n  and?: InputMaybe<Array<InputMaybe<VerificationHash_filter>>>;\n  or?: InputMaybe<Array<InputMaybe<VerificationHash_filter>>>;\n};\n\nexport type VerificationHash_orderBy = 'id' | 'verificationHash';\n\nexport type _Block_ = {\n  /** The hash of the block */\n  hash?: Maybe<Scalars['Bytes']>;\n  /** The block number */\n  number: Scalars['Int'];\n  /** Integer representation of the timestamp stored in blocks for the chain */\n  timestamp?: Maybe<Scalars['Int']>;\n};\n\n/** The type for the top-level _meta field */\nexport type _Meta_ = {\n  /**\n   * Information about a specific subgraph block. The hash of the block\n   * will be null if the _meta field has a block constraint that asks for\n   * a block number. It will be filled if the _meta field has no block constraint\n   * and therefore asks for the latest  block\n   *\n   */\n  block: _Block_;\n  /** The deployment ID */\n  deployment: Scalars['String'];\n  /** If `true`, the subgraph encountered indexing errors at some past block */\n  hasIndexingErrors: Scalars['Boolean'];\n};\n\nexport type _SubgraphErrorPolicy_ =\n  /** Data will be returned even if the subgraph has indexing errors */\n  | 'allow'\n  /** If the subgraph has indexing errors, data will be omitted. The default. */\n  | 'deny';\n\nexport type WithIndex<TObject> = TObject & Record<string, any>;\nexport type ResolversObject<TObject> = WithIndex<TObject>;\n\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\n\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\n\nexport type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {\n  fragment: string;\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\n\nexport type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {\n  selectionSet: string | ((fieldNode: FieldNode) => SelectionSetNode);\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\nexport type StitchingResolver<TResult, TParent, TContext, TArgs> =\n  | LegacyStitchingResolver<TResult, TParent, TContext, TArgs>\n  | NewStitchingResolver<TResult, TParent, TContext, TArgs>;\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n  | ResolverFn<TResult, TParent, TContext, TArgs>\n  | ResolverWithResolve<TResult, TParent, TContext, TArgs>\n  | StitchingResolver<TResult, TParent, TContext, TArgs>;\n\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => Promise<TResult> | TResult;\n\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\n\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => TResult | Promise<TResult>;\n\nexport interface SubscriptionSubscriberObject<\n  TResult,\n  TKey extends string,\n  TParent,\n  TContext,\n  TArgs,\n> {\n  subscribe: SubscriptionSubscribeFn<\n    { [key in TKey]: TResult },\n    TParent,\n    TContext,\n    TArgs\n  >;\n  resolve?: SubscriptionResolveFn<\n    TResult,\n    { [key in TKey]: TResult },\n    TContext,\n    TArgs\n  >;\n}\n\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\n  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\n  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\n}\n\nexport type SubscriptionObject<\n  TResult,\n  TKey extends string,\n  TParent,\n  TContext,\n  TArgs,\n> =\n  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\n  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\n\nexport type SubscriptionResolver<\n  TResult,\n  TKey extends string,\n  TParent = {},\n  TContext = {},\n  TArgs = {},\n> =\n  | ((\n      ...args: any[]\n    ) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\n  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\n\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\n  parent: TParent,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\n\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (\n  obj: T,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => boolean | Promise<boolean>;\n\nexport type NextResolverFn<T> = () => Promise<T>;\n\nexport type DirectiveResolverFn<\n  TResult = {},\n  TParent = {},\n  TContext = {},\n  TArgs = {},\n> = (\n  next: NextResolverFn<TResult>,\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => TResult | Promise<TResult>;\n\n/** Mapping between all available schema types and the resolvers types */\nexport type ResolversTypes = ResolversObject<{\n  BigDecimal: ResolverTypeWrapper<Scalars['BigDecimal']>;\n  BigInt: ResolverTypeWrapper<Scalars['BigInt']>;\n  BlockChangedFilter: BlockChangedFilter;\n  Block_height: Block_height;\n  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n  Bytes: ResolverTypeWrapper<Scalars['Bytes']>;\n  Commitment:\n    | ResolversTypes['ShieldCommitment']\n    | ResolversTypes['TransactCommitment'];\n  CommitmentCiphertext: ResolverTypeWrapper<CommitmentCiphertext>;\n  CommitmentCiphertext_filter: CommitmentCiphertext_filter;\n  CommitmentCiphertext_orderBy: CommitmentCiphertext_orderBy;\n  CommitmentPreimage: ResolverTypeWrapper<CommitmentPreimage>;\n  CommitmentPreimage_filter: CommitmentPreimage_filter;\n  CommitmentPreimage_orderBy: CommitmentPreimage_orderBy;\n  CommitmentType: CommitmentType;\n  Commitment_filter: Commitment_filter;\n  Commitment_orderBy: Commitment_orderBy;\n  Float: ResolverTypeWrapper<Scalars['Float']>;\n  ID: ResolverTypeWrapper<Scalars['ID']>;\n  Int: ResolverTypeWrapper<Scalars['Int']>;\n  Int8: ResolverTypeWrapper<Scalars['Int8']>;\n  Nullifier: ResolverTypeWrapper<Nullifier>;\n  Nullifier_filter: Nullifier_filter;\n  Nullifier_orderBy: Nullifier_orderBy;\n  OrderDirection: OrderDirection;\n  Query: ResolverTypeWrapper<{}>;\n  RailgunTransaction: ResolverTypeWrapper<RailgunTransaction>;\n  RailgunTransaction_filter: RailgunTransaction_filter;\n  RailgunTransaction_orderBy: RailgunTransaction_orderBy;\n  ShieldCommitment: ResolverTypeWrapper<ShieldCommitment>;\n  ShieldCommitment_filter: ShieldCommitment_filter;\n  ShieldCommitment_orderBy: ShieldCommitment_orderBy;\n  String: ResolverTypeWrapper<Scalars['String']>;\n  Subscription: ResolverTypeWrapper<{}>;\n  Token: ResolverTypeWrapper<Token>;\n  TokenType: TokenType;\n  Token_filter: Token_filter;\n  Token_orderBy: Token_orderBy;\n  TransactCommitment: ResolverTypeWrapper<TransactCommitment>;\n  TransactCommitment_filter: TransactCommitment_filter;\n  TransactCommitment_orderBy: TransactCommitment_orderBy;\n  Unshield: ResolverTypeWrapper<Unshield>;\n  Unshield_filter: Unshield_filter;\n  Unshield_orderBy: Unshield_orderBy;\n  VerificationHash: ResolverTypeWrapper<VerificationHash>;\n  VerificationHash_filter: VerificationHash_filter;\n  VerificationHash_orderBy: VerificationHash_orderBy;\n  _Block_: ResolverTypeWrapper<_Block_>;\n  _Meta_: ResolverTypeWrapper<_Meta_>;\n  _SubgraphErrorPolicy_: _SubgraphErrorPolicy_;\n}>;\n\n/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = ResolversObject<{\n  BigDecimal: Scalars['BigDecimal'];\n  BigInt: Scalars['BigInt'];\n  BlockChangedFilter: BlockChangedFilter;\n  Block_height: Block_height;\n  Boolean: Scalars['Boolean'];\n  Bytes: Scalars['Bytes'];\n  Commitment:\n    | ResolversParentTypes['ShieldCommitment']\n    | ResolversParentTypes['TransactCommitment'];\n  CommitmentCiphertext: CommitmentCiphertext;\n  CommitmentCiphertext_filter: CommitmentCiphertext_filter;\n  CommitmentPreimage: CommitmentPreimage;\n  CommitmentPreimage_filter: CommitmentPreimage_filter;\n  Commitment_filter: Commitment_filter;\n  Float: Scalars['Float'];\n  ID: Scalars['ID'];\n  Int: Scalars['Int'];\n  Int8: Scalars['Int8'];\n  Nullifier: Nullifier;\n  Nullifier_filter: Nullifier_filter;\n  Query: {};\n  RailgunTransaction: RailgunTransaction;\n  RailgunTransaction_filter: RailgunTransaction_filter;\n  ShieldCommitment: ShieldCommitment;\n  ShieldCommitment_filter: ShieldCommitment_filter;\n  String: Scalars['String'];\n  Subscription: {};\n  Token: Token;\n  Token_filter: Token_filter;\n  TransactCommitment: TransactCommitment;\n  TransactCommitment_filter: TransactCommitment_filter;\n  Unshield: Unshield;\n  Unshield_filter: Unshield_filter;\n  VerificationHash: VerificationHash;\n  VerificationHash_filter: VerificationHash_filter;\n  _Block_: _Block_;\n  _Meta_: _Meta_;\n}>;\n\nexport type entityDirectiveArgs = {};\n\nexport type entityDirectiveResolver<\n  Result,\n  Parent,\n  ContextType = MeshContext,\n  Args = entityDirectiveArgs,\n> = DirectiveResolverFn<Result, Parent, ContextType, Args>;\n\nexport type subgraphIdDirectiveArgs = {\n  id: Scalars['String'];\n};\n\nexport type subgraphIdDirectiveResolver<\n  Result,\n  Parent,\n  ContextType = MeshContext,\n  Args = subgraphIdDirectiveArgs,\n> = DirectiveResolverFn<Result, Parent, ContextType, Args>;\n\nexport type derivedFromDirectiveArgs = {\n  field: Scalars['String'];\n};\n\nexport type derivedFromDirectiveResolver<\n  Result,\n  Parent,\n  ContextType = MeshContext,\n  Args = derivedFromDirectiveArgs,\n> = DirectiveResolverFn<Result, Parent, ContextType, Args>;\n\nexport interface BigDecimalScalarConfig\n  extends GraphQLScalarTypeConfig<ResolversTypes['BigDecimal'], any> {\n  name: 'BigDecimal';\n}\n\nexport interface BigIntScalarConfig\n  extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {\n  name: 'BigInt';\n}\n\nexport interface BytesScalarConfig\n  extends GraphQLScalarTypeConfig<ResolversTypes['Bytes'], any> {\n  name: 'Bytes';\n}\n\nexport type CommitmentResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['Commitment'] = ResolversParentTypes['Commitment'],\n> = ResolversObject<{\n  __resolveType: TypeResolveFn<\n    'ShieldCommitment' | 'TransactCommitment',\n    ParentType,\n    ContextType\n  >;\n  id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<\n    ResolversTypes['CommitmentType'],\n    ParentType,\n    ContextType\n  >;\n  hashes?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n}>;\n\nexport type CommitmentCiphertextResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['CommitmentCiphertext'] = ResolversParentTypes['CommitmentCiphertext'],\n> = ResolversObject<{\n  id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  ciphertext?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  blindedSenderViewingKey?: Resolver<\n    ResolversTypes['Bytes'],\n    ParentType,\n    ContextType\n  >;\n  blindedReceiverViewingKey?: Resolver<\n    ResolversTypes['Bytes'],\n    ParentType,\n    ContextType\n  >;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentPreimageResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['CommitmentPreimage'] = ResolversParentTypes['CommitmentPreimage'],\n> = ResolversObject<{\n  id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  npk?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  token?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  value?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport interface Int8ScalarConfig\n  extends GraphQLScalarTypeConfig<ResolversTypes['Int8'], any> {\n  name: 'Int8';\n}\n\nexport type NullifierResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['Nullifier'] = ResolversParentTypes['Nullifier'],\n> = ResolversObject<{\n  id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  nullifier?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type QueryResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query'],\n> = ResolversObject<{\n  token?: Resolver<\n    Maybe<ResolversTypes['Token']>,\n    ParentType,\n    ContextType,\n    RequireFields<QuerytokenArgs, 'id' | 'subgraphError'>\n  >;\n  tokens?: Resolver<\n    Array<ResolversTypes['Token']>,\n    ParentType,\n    ContextType,\n    RequireFields<QuerytokensArgs, 'skip' | 'first' | 'subgraphError'>\n  >;\n  commitmentPreimage?: Resolver<\n    Maybe<ResolversTypes['CommitmentPreimage']>,\n    ParentType,\n    ContextType,\n    RequireFields<QuerycommitmentPreimageArgs, 'id' | 'subgraphError'>\n  >;\n  commitmentPreimages?: Resolver<\n    Array<ResolversTypes['CommitmentPreimage']>,\n    ParentType,\n    ContextType,\n    RequireFields<\n      QuerycommitmentPreimagesArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  commitmentCiphertext?: Resolver<\n    Maybe<ResolversTypes['CommitmentCiphertext']>,\n    ParentType,\n    ContextType,\n    RequireFields<QuerycommitmentCiphertextArgs, 'id' | 'subgraphError'>\n  >;\n  commitmentCiphertexts?: Resolver<\n    Array<ResolversTypes['CommitmentCiphertext']>,\n    ParentType,\n    ContextType,\n    RequireFields<\n      QuerycommitmentCiphertextsArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  shieldCommitment?: Resolver<\n    Maybe<ResolversTypes['ShieldCommitment']>,\n    ParentType,\n    ContextType,\n    RequireFields<QueryshieldCommitmentArgs, 'id' | 'subgraphError'>\n  >;\n  shieldCommitments?: Resolver<\n    Array<ResolversTypes['ShieldCommitment']>,\n    ParentType,\n    ContextType,\n    RequireFields<\n      QueryshieldCommitmentsArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  transactCommitment?: Resolver<\n    Maybe<ResolversTypes['TransactCommitment']>,\n    ParentType,\n    ContextType,\n    RequireFields<QuerytransactCommitmentArgs, 'id' | 'subgraphError'>\n  >;\n  transactCommitments?: Resolver<\n    Array<ResolversTypes['TransactCommitment']>,\n    ParentType,\n    ContextType,\n    RequireFields<\n      QuerytransactCommitmentsArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  unshield?: Resolver<\n    Maybe<ResolversTypes['Unshield']>,\n    ParentType,\n    ContextType,\n    RequireFields<QueryunshieldArgs, 'id' | 'subgraphError'>\n  >;\n  unshields?: Resolver<\n    Array<ResolversTypes['Unshield']>,\n    ParentType,\n    ContextType,\n    RequireFields<QueryunshieldsArgs, 'skip' | 'first' | 'subgraphError'>\n  >;\n  nullifier?: Resolver<\n    Maybe<ResolversTypes['Nullifier']>,\n    ParentType,\n    ContextType,\n    RequireFields<QuerynullifierArgs, 'id' | 'subgraphError'>\n  >;\n  nullifiers?: Resolver<\n    Array<ResolversTypes['Nullifier']>,\n    ParentType,\n    ContextType,\n    RequireFields<QuerynullifiersArgs, 'skip' | 'first' | 'subgraphError'>\n  >;\n  railgunTransaction?: Resolver<\n    Maybe<ResolversTypes['RailgunTransaction']>,\n    ParentType,\n    ContextType,\n    RequireFields<QueryrailgunTransactionArgs, 'id' | 'subgraphError'>\n  >;\n  railgunTransactions?: Resolver<\n    Array<ResolversTypes['RailgunTransaction']>,\n    ParentType,\n    ContextType,\n    RequireFields<\n      QueryrailgunTransactionsArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  verificationHash?: Resolver<\n    Maybe<ResolversTypes['VerificationHash']>,\n    ParentType,\n    ContextType,\n    RequireFields<QueryverificationHashArgs, 'id' | 'subgraphError'>\n  >;\n  verificationHashes?: Resolver<\n    Array<ResolversTypes['VerificationHash']>,\n    ParentType,\n    ContextType,\n    RequireFields<\n      QueryverificationHashesArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  commitment?: Resolver<\n    Maybe<ResolversTypes['Commitment']>,\n    ParentType,\n    ContextType,\n    RequireFields<QuerycommitmentArgs, 'id' | 'subgraphError'>\n  >;\n  commitments?: Resolver<\n    Array<ResolversTypes['Commitment']>,\n    ParentType,\n    ContextType,\n    RequireFields<QuerycommitmentsArgs, 'skip' | 'first' | 'subgraphError'>\n  >;\n  _meta?: Resolver<\n    Maybe<ResolversTypes['_Meta_']>,\n    ParentType,\n    ContextType,\n    Partial<Query_metaArgs>\n  >;\n}>;\n\nexport type RailgunTransactionResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['RailgunTransaction'] = ResolversParentTypes['RailgunTransaction'],\n> = ResolversObject<{\n  id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  nullifiers?: Resolver<\n    Array<ResolversTypes['Bytes']>,\n    ParentType,\n    ContextType\n  >;\n  commitments?: Resolver<\n    Array<ResolversTypes['Bytes']>,\n    ParentType,\n    ContextType\n  >;\n  boundParamsHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  hasUnshield?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;\n  utxoTreeIn?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  utxoTreeOut?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  utxoBatchStartPositionOut?: Resolver<\n    ResolversTypes['BigInt'],\n    ParentType,\n    ContextType\n  >;\n  unshieldToken?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  unshieldToAddress?: Resolver<\n    ResolversTypes['Bytes'],\n    ParentType,\n    ContextType\n  >;\n  unshieldValue?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  verificationHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type ShieldCommitmentResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['ShieldCommitment'] = ResolversParentTypes['ShieldCommitment'],\n> = ResolversObject<{\n  id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<\n    ResolversTypes['CommitmentType'],\n    ParentType,\n    ContextType\n  >;\n  hashes?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  from?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  preimage?: Resolver<\n    ResolversTypes['CommitmentPreimage'],\n    ParentType,\n    ContextType\n  >;\n  encryptedBundle?: Resolver<\n    Array<ResolversTypes['Bytes']>,\n    ParentType,\n    ContextType\n  >;\n  shieldKey?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  fee?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type SubscriptionResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription'],\n> = ResolversObject<{\n  token?: SubscriptionResolver<\n    Maybe<ResolversTypes['Token']>,\n    'token',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptiontokenArgs, 'id' | 'subgraphError'>\n  >;\n  tokens?: SubscriptionResolver<\n    Array<ResolversTypes['Token']>,\n    'tokens',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptiontokensArgs, 'skip' | 'first' | 'subgraphError'>\n  >;\n  commitmentPreimage?: SubscriptionResolver<\n    Maybe<ResolversTypes['CommitmentPreimage']>,\n    'commitmentPreimage',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptioncommitmentPreimageArgs, 'id' | 'subgraphError'>\n  >;\n  commitmentPreimages?: SubscriptionResolver<\n    Array<ResolversTypes['CommitmentPreimage']>,\n    'commitmentPreimages',\n    ParentType,\n    ContextType,\n    RequireFields<\n      SubscriptioncommitmentPreimagesArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  commitmentCiphertext?: SubscriptionResolver<\n    Maybe<ResolversTypes['CommitmentCiphertext']>,\n    'commitmentCiphertext',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptioncommitmentCiphertextArgs, 'id' | 'subgraphError'>\n  >;\n  commitmentCiphertexts?: SubscriptionResolver<\n    Array<ResolversTypes['CommitmentCiphertext']>,\n    'commitmentCiphertexts',\n    ParentType,\n    ContextType,\n    RequireFields<\n      SubscriptioncommitmentCiphertextsArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  shieldCommitment?: SubscriptionResolver<\n    Maybe<ResolversTypes['ShieldCommitment']>,\n    'shieldCommitment',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptionshieldCommitmentArgs, 'id' | 'subgraphError'>\n  >;\n  shieldCommitments?: SubscriptionResolver<\n    Array<ResolversTypes['ShieldCommitment']>,\n    'shieldCommitments',\n    ParentType,\n    ContextType,\n    RequireFields<\n      SubscriptionshieldCommitmentsArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  transactCommitment?: SubscriptionResolver<\n    Maybe<ResolversTypes['TransactCommitment']>,\n    'transactCommitment',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptiontransactCommitmentArgs, 'id' | 'subgraphError'>\n  >;\n  transactCommitments?: SubscriptionResolver<\n    Array<ResolversTypes['TransactCommitment']>,\n    'transactCommitments',\n    ParentType,\n    ContextType,\n    RequireFields<\n      SubscriptiontransactCommitmentsArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  unshield?: SubscriptionResolver<\n    Maybe<ResolversTypes['Unshield']>,\n    'unshield',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptionunshieldArgs, 'id' | 'subgraphError'>\n  >;\n  unshields?: SubscriptionResolver<\n    Array<ResolversTypes['Unshield']>,\n    'unshields',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptionunshieldsArgs, 'skip' | 'first' | 'subgraphError'>\n  >;\n  nullifier?: SubscriptionResolver<\n    Maybe<ResolversTypes['Nullifier']>,\n    'nullifier',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptionnullifierArgs, 'id' | 'subgraphError'>\n  >;\n  nullifiers?: SubscriptionResolver<\n    Array<ResolversTypes['Nullifier']>,\n    'nullifiers',\n    ParentType,\n    ContextType,\n    RequireFields<\n      SubscriptionnullifiersArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  railgunTransaction?: SubscriptionResolver<\n    Maybe<ResolversTypes['RailgunTransaction']>,\n    'railgunTransaction',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptionrailgunTransactionArgs, 'id' | 'subgraphError'>\n  >;\n  railgunTransactions?: SubscriptionResolver<\n    Array<ResolversTypes['RailgunTransaction']>,\n    'railgunTransactions',\n    ParentType,\n    ContextType,\n    RequireFields<\n      SubscriptionrailgunTransactionsArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  verificationHash?: SubscriptionResolver<\n    Maybe<ResolversTypes['VerificationHash']>,\n    'verificationHash',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptionverificationHashArgs, 'id' | 'subgraphError'>\n  >;\n  verificationHashes?: SubscriptionResolver<\n    Array<ResolversTypes['VerificationHash']>,\n    'verificationHashes',\n    ParentType,\n    ContextType,\n    RequireFields<\n      SubscriptionverificationHashesArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  commitment?: SubscriptionResolver<\n    Maybe<ResolversTypes['Commitment']>,\n    'commitment',\n    ParentType,\n    ContextType,\n    RequireFields<SubscriptioncommitmentArgs, 'id' | 'subgraphError'>\n  >;\n  commitments?: SubscriptionResolver<\n    Array<ResolversTypes['Commitment']>,\n    'commitments',\n    ParentType,\n    ContextType,\n    RequireFields<\n      SubscriptioncommitmentsArgs,\n      'skip' | 'first' | 'subgraphError'\n    >\n  >;\n  _meta?: SubscriptionResolver<\n    Maybe<ResolversTypes['_Meta_']>,\n    '_meta',\n    ParentType,\n    ContextType,\n    Partial<Subscription_metaArgs>\n  >;\n}>;\n\nexport type TokenResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['Token'] = ResolversParentTypes['Token'],\n> = ResolversObject<{\n  id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  tokenType?: Resolver<ResolversTypes['TokenType'], ParentType, ContextType>;\n  tokenAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  tokenSubID?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactCommitmentResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['TransactCommitment'] = ResolversParentTypes['TransactCommitment'],\n> = ResolversObject<{\n  id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<\n    ResolversTypes['CommitmentType'],\n    ParentType,\n    ContextType\n  >;\n  hashes?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  commitmentCiphertexts?: Resolver<\n    Array<ResolversTypes['CommitmentCiphertext']>,\n    ParentType,\n    ContextType,\n    RequireFields<TransactCommitmentcommitmentCiphertextsArgs, 'skip' | 'first'>\n  >;\n  batchStartTreePosition?: Resolver<\n    ResolversTypes['Int'],\n    ParentType,\n    ContextType\n  >;\n  transactIndex?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  senderCiphertext?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type UnshieldResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['Unshield'] = ResolversParentTypes['Unshield'],\n> = ResolversObject<{\n  id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  to?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  token?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  value?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  fee?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactIndex?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type VerificationHashResolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['VerificationHash'] = ResolversParentTypes['VerificationHash'],\n> = ResolversObject<{\n  id?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  verificationHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type _Block_Resolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['_Block_'] = ResolversParentTypes['_Block_'],\n> = ResolversObject<{\n  hash?: Resolver<Maybe<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  timestamp?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type _Meta_Resolvers<\n  ContextType = MeshContext,\n  ParentType extends ResolversParentTypes['_Meta_'] = ResolversParentTypes['_Meta_'],\n> = ResolversObject<{\n  block?: Resolver<ResolversTypes['_Block_'], ParentType, ContextType>;\n  deployment?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  hasIndexingErrors?: Resolver<\n    ResolversTypes['Boolean'],\n    ParentType,\n    ContextType\n  >;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type Resolvers<ContextType = MeshContext> = ResolversObject<{\n  BigDecimal?: GraphQLScalarType;\n  BigInt?: GraphQLScalarType;\n  Bytes?: GraphQLScalarType;\n  Commitment?: CommitmentResolvers<ContextType>;\n  CommitmentCiphertext?: CommitmentCiphertextResolvers<ContextType>;\n  CommitmentPreimage?: CommitmentPreimageResolvers<ContextType>;\n  Int8?: GraphQLScalarType;\n  Nullifier?: NullifierResolvers<ContextType>;\n  Query?: QueryResolvers<ContextType>;\n  RailgunTransaction?: RailgunTransactionResolvers<ContextType>;\n  ShieldCommitment?: ShieldCommitmentResolvers<ContextType>;\n  Subscription?: SubscriptionResolvers<ContextType>;\n  Token?: TokenResolvers<ContextType>;\n  TransactCommitment?: TransactCommitmentResolvers<ContextType>;\n  Unshield?: UnshieldResolvers<ContextType>;\n  VerificationHash?: VerificationHashResolvers<ContextType>;\n  _Block_?: _Block_Resolvers<ContextType>;\n  _Meta_?: _Meta_Resolvers<ContextType>;\n}>;\n\nexport type DirectiveResolvers<ContextType = MeshContext> = ResolversObject<{\n  entity?: entityDirectiveResolver<any, any, ContextType>;\n  subgraphId?: subgraphIdDirectiveResolver<any, any, ContextType>;\n  derivedFrom?: derivedFromDirectiveResolver<any, any, ContextType>;\n}>;\n\nexport type MeshContext = MumbaiTypes.Context & BaseMeshContext;\n\nconst baseDir = pathModule.join(\n  typeof __dirname === 'string' ? __dirname : '/',\n  '..',\n);\n\nconst importFn: ImportFn = <T>(moduleId: string) => {\n  const relativeModuleId = (\n    pathModule.isAbsolute(moduleId)\n      ? pathModule.relative(baseDir, moduleId)\n      : moduleId\n  )\n    .split('\\\\')\n    .join('/')\n    .replace(baseDir + '/', '');\n  switch (relativeModuleId) {\n    case '.graphclient/sources/mumbai/introspectionSchema':\n      return import('./.graphclient/sources/mumbai/introspectionSchema') as T;\n\n    default:\n      return Promise.reject(\n        new Error(`Cannot find module '${relativeModuleId}'.`),\n      );\n  }\n};\n\nconst rootStore = new MeshStore(\n  '.graphclient',\n  new FsStoreStorageAdapter({\n    cwd: baseDir,\n    importFn,\n    fileType: 'ts',\n  }),\n  {\n    readonly: true,\n    validate: false,\n  },\n);\n\nexport const rawServeConfig: YamlConfig.Config['serve'] = undefined as any;\nexport async function getMeshOptions(): Promise<GetMeshOptions> {\n  const pubsub = new PubSub();\n  const sourcesStore = rootStore.child('sources');\n  const logger = new DefaultLogger('GraphClient');\n  const cache = new (MeshCache as any)({\n    ...({} as any),\n    importFn,\n    store: rootStore.child('cache'),\n    pubsub,\n    logger,\n  } as any);\n\n  const sources: MeshResolvedSource[] = [];\n  const transforms: MeshTransform[] = [];\n  const additionalEnvelopPlugins: MeshPlugin<any>[] = [];\n  const mumbaiTransforms = [];\n  const additionalTypeDefs = [] as any[];\n  const mumbaiHandler = new GraphqlHandler({\n    name: 'mumbai',\n    config: {\n      endpoint:\n        'https://api.thegraph.com/subgraphs/name/railgun-community/railgun-v3-mumbai',\n    },\n    baseDir,\n    cache,\n    pubsub,\n    store: sourcesStore.child('mumbai'),\n    logger: logger.child('mumbai'),\n    importFn,\n  });\n  sources[0] = {\n    name: 'mumbai',\n    handler: mumbaiHandler,\n    transforms: mumbaiTransforms,\n  };\n  const additionalResolvers = [] as any[];\n  const merger = new (BareMerger as any)({\n    cache,\n    pubsub,\n    logger: logger.child('bareMerger'),\n    store: rootStore.child('bareMerger'),\n  });\n\n  return {\n    sources,\n    transforms,\n    additionalTypeDefs,\n    additionalResolvers,\n    cache,\n    pubsub,\n    merger,\n    logger,\n    additionalEnvelopPlugins,\n    get documents() {\n      return [\n        {\n          document: NullifiersDocument,\n          get rawSDL() {\n            return printWithCache(NullifiersDocument);\n          },\n          location: 'NullifiersDocument.graphql',\n        },\n        {\n          document: UnshieldsDocument,\n          get rawSDL() {\n            return printWithCache(UnshieldsDocument);\n          },\n          location: 'UnshieldsDocument.graphql',\n        },\n        {\n          document: CommitmentsDocument,\n          get rawSDL() {\n            return printWithCache(CommitmentsDocument);\n          },\n          location: 'CommitmentsDocument.graphql',\n        },\n        {\n          document: RailgunTransactionsDocument,\n          get rawSDL() {\n            return printWithCache(RailgunTransactionsDocument);\n          },\n          location: 'RailgunTransactionsDocument.graphql',\n        },\n      ];\n    },\n    fetchFn,\n  };\n}\n\nexport function createBuiltMeshHTTPHandler<\n  TServerContext = {},\n>(): MeshHTTPHandler<TServerContext> {\n  return createMeshHTTPHandler<TServerContext>({\n    baseDir,\n    getBuiltMesh: getBuiltGraphClient,\n    rawServeConfig: undefined,\n  });\n}\n\nlet meshInstance$: Promise<MeshInstance> | undefined;\n\nexport function getBuiltGraphClient(): Promise<MeshInstance> {\n  if (meshInstance$ == null) {\n    meshInstance$ = getMeshOptions()\n      .then(meshOptions => getMesh(meshOptions))\n      .then(mesh => {\n        const id = mesh.pubsub.subscribe('destroy', () => {\n          meshInstance$ = undefined;\n          mesh.pubsub.unsubscribe(id);\n        });\n        return mesh;\n      });\n  }\n  return meshInstance$;\n}\n\nexport const execute: ExecuteMeshFn = (...args) =>\n  getBuiltGraphClient().then(({ execute }) => execute(...args));\n\nexport const subscribe: SubscribeMeshFn = (...args) =>\n  getBuiltGraphClient().then(({ subscribe }) => subscribe(...args));\nexport function getBuiltGraphSDK<TGlobalContext = any, TOperationContext = any>(\n  globalContext?: TGlobalContext,\n) {\n  const sdkRequester$ = getBuiltGraphClient().then(({ sdkRequesterFactory }) =>\n    sdkRequesterFactory(globalContext),\n  );\n  return getSdk<TOperationContext, TGlobalContext>((...args) =>\n    sdkRequester$.then(sdkRequester => sdkRequester(...args)),\n  );\n}\nexport type NullifiersQueryVariables = Exact<{\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n}>;\n\nexport type NullifiersQuery = {\n  nullifiers: Array<\n    Pick<\n      Nullifier,\n      | 'id'\n      | 'blockNumber'\n      | 'blockTimestamp'\n      | 'transactionHash'\n      | 'treeNumber'\n      | 'nullifier'\n    >\n  >;\n};\n\nexport type UnshieldsQueryVariables = Exact<{\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n}>;\n\nexport type UnshieldsQuery = {\n  unshields: Array<\n    Pick<\n      Unshield,\n      | 'id'\n      | 'blockNumber'\n      | 'blockTimestamp'\n      | 'to'\n      | 'transactionHash'\n      | 'fee'\n      | 'value'\n      | 'transactIndex'\n    > & {\n      token: Pick<Token, 'id' | 'tokenType' | 'tokenSubID' | 'tokenAddress'>;\n    }\n  >;\n};\n\nexport type CommitmentsQueryVariables = Exact<{\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n}>;\n\nexport type CommitmentsQuery = {\n  commitments: Array<\n    | (Pick<\n        ShieldCommitment,\n        | 'id'\n        | 'blockNumber'\n        | 'blockTimestamp'\n        | 'transactionHash'\n        | 'treeNumber'\n        | 'treePosition'\n        | 'commitmentType'\n        | 'hashes'\n        | 'shieldKey'\n        | 'fee'\n        | 'encryptedBundle'\n        | 'from'\n      > & {\n        preimage: Pick<CommitmentPreimage, 'id' | 'npk' | 'value'> & {\n          token: Pick<\n            Token,\n            'id' | 'tokenType' | 'tokenSubID' | 'tokenAddress'\n          >;\n        };\n      })\n    | (Pick<\n        TransactCommitment,\n        | 'id'\n        | 'blockNumber'\n        | 'blockTimestamp'\n        | 'transactionHash'\n        | 'treeNumber'\n        | 'batchStartTreePosition'\n        | 'transactIndex'\n        | 'commitmentType'\n        | 'senderCiphertext'\n        | 'hashes'\n      > & {\n        commitmentCiphertexts: Array<\n          Pick<\n            CommitmentCiphertext,\n            | 'id'\n            | 'ciphertext'\n            | 'blindedSenderViewingKey'\n            | 'blindedReceiverViewingKey'\n          >\n        >;\n      })\n  >;\n};\n\nexport type RailgunTransactionsQueryVariables = Exact<{\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n}>;\n\nexport type RailgunTransactionsQuery = {\n  railgunTransactions: Array<\n    Pick<\n      RailgunTransaction,\n      | 'id'\n      | 'blockNumber'\n      | 'blockTimestamp'\n      | 'transactionHash'\n      | 'nullifiers'\n      | 'commitments'\n      | 'boundParamsHash'\n      | 'hasUnshield'\n      | 'utxoTreeIn'\n      | 'utxoTreeOut'\n      | 'utxoBatchStartPositionOut'\n      | 'unshieldToAddress'\n      | 'unshieldValue'\n      | 'verificationHash'\n    > & {\n      unshieldToken: Pick<\n        Token,\n        'id' | 'tokenType' | 'tokenAddress' | 'tokenSubID'\n      >;\n    }\n  >;\n};\n\nexport const NullifiersDocument = gql`\n  query Nullifiers($blockNumber: BigInt = 0) {\n    nullifiers(\n      orderBy: blockNumber\n      where: { blockNumber_gte: $blockNumber }\n      first: 1000\n    ) {\n      id\n      blockNumber\n      blockTimestamp\n      transactionHash\n      treeNumber\n      nullifier\n    }\n  }\n` as unknown as DocumentNode<NullifiersQuery, NullifiersQueryVariables>;\nexport const UnshieldsDocument = gql`\n  query Unshields($blockNumber: BigInt = 0) {\n    unshields(\n      orderBy: blockNumber\n      where: { blockNumber_gte: $blockNumber }\n      first: 1000\n    ) {\n      id\n      blockNumber\n      blockTimestamp\n      to\n      transactionHash\n      fee\n      value\n      transactIndex\n      token {\n        id\n        tokenType\n        tokenSubID\n        tokenAddress\n      }\n    }\n  }\n` as unknown as DocumentNode<UnshieldsQuery, UnshieldsQueryVariables>;\nexport const CommitmentsDocument = gql`\n  query Commitments($blockNumber: BigInt = 0) {\n    commitments(\n      orderBy: blockNumber\n      where: { blockNumber_gte: $blockNumber }\n      first: 1000\n    ) {\n      id\n      treeNumber\n      blockNumber\n      transactionHash\n      blockTimestamp\n      ... on ShieldCommitment {\n        id\n        blockNumber\n        blockTimestamp\n        transactionHash\n        treeNumber\n        treePosition\n        commitmentType\n        hashes\n        shieldKey\n        fee\n        encryptedBundle\n        from\n        preimage {\n          id\n          npk\n          value\n          token {\n            id\n            tokenType\n            tokenSubID\n            tokenAddress\n          }\n        }\n      }\n      ... on TransactCommitment {\n        id\n        blockNumber\n        blockTimestamp\n        transactionHash\n        treeNumber\n        batchStartTreePosition\n        transactIndex\n        commitmentType\n        senderCiphertext\n        hashes\n        commitmentCiphertexts {\n          id\n          ciphertext\n          blindedSenderViewingKey\n          blindedReceiverViewingKey\n        }\n      }\n    }\n  }\n` as unknown as DocumentNode<CommitmentsQuery, CommitmentsQueryVariables>;\nexport const RailgunTransactionsDocument = gql`\n  query RailgunTransactions($blockNumber: BigInt = 0) {\n    railgunTransactions(\n      orderBy: blockNumber\n      where: { blockNumber_gte: $blockNumber }\n      first: 1000\n    ) {\n      id\n      blockNumber\n      blockTimestamp\n      transactionHash\n      blockNumber\n      blockTimestamp\n      nullifiers\n      commitments\n      boundParamsHash\n      hasUnshield\n      utxoTreeIn\n      utxoTreeOut\n      utxoBatchStartPositionOut\n      unshieldToken {\n        id\n        tokenType\n        tokenAddress\n        tokenSubID\n      }\n      unshieldToAddress\n      unshieldValue\n      verificationHash\n    }\n  }\n` as unknown as DocumentNode<\n  RailgunTransactionsQuery,\n  RailgunTransactionsQueryVariables\n>;\n\nexport type Requester<C = {}, E = unknown> = <R, V>(\n  doc: DocumentNode,\n  vars?: V,\n  options?: C,\n) => Promise<R> | AsyncIterable<R>;\nexport function getSdk<C, E>(requester: Requester<C, E>) {\n  return {\n    Nullifiers(\n      variables?: NullifiersQueryVariables,\n      options?: C,\n    ): Promise<NullifiersQuery> {\n      return requester<NullifiersQuery, NullifiersQueryVariables>(\n        NullifiersDocument,\n        variables,\n        options,\n      ) as Promise<NullifiersQuery>;\n    },\n    Unshields(\n      variables?: UnshieldsQueryVariables,\n      options?: C,\n    ): Promise<UnshieldsQuery> {\n      return requester<UnshieldsQuery, UnshieldsQueryVariables>(\n        UnshieldsDocument,\n        variables,\n        options,\n      ) as Promise<UnshieldsQuery>;\n    },\n    Commitments(\n      variables?: CommitmentsQueryVariables,\n      options?: C,\n    ): Promise<CommitmentsQuery> {\n      return requester<CommitmentsQuery, CommitmentsQueryVariables>(\n        CommitmentsDocument,\n        variables,\n        options,\n      ) as Promise<CommitmentsQuery>;\n    },\n    RailgunTransactions(\n      variables?: RailgunTransactionsQueryVariables,\n      options?: C,\n    ): Promise<RailgunTransactionsQuery> {\n      return requester<\n        RailgunTransactionsQuery,\n        RailgunTransactionsQueryVariables\n      >(\n        RailgunTransactionsDocument,\n        variables,\n        options,\n      ) as Promise<RailgunTransactionsQuery>;\n    },\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;\n"]}