"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.quickSyncEventsGraphV2 = void 0;
const shared_models_1 = require("@railgun-community/shared-models");
const graphql_1 = require("./graphql");
const runtime_1 = require("@graphql-mesh/runtime");
const graph_type_formatters_v2_1 = require("./graph-type-formatters-v2");
const graph_util_1 = require("../../util/graph-util");
const graph_query_1 = require("../graph-query");
const meshes = {};
// 1.5 full trees of commitments
// TODO: This will have to change when we have more than 100k commitments.
const MAX_QUERY_RESULTS = 100000;
const sourceNameForNetwork = (networkName) => {
    switch (networkName) {
        case shared_models_1.NetworkName.Ethereum:
            return 'ethereum';
        case shared_models_1.NetworkName.EthereumSepolia:
            return 'sepolia';
        case shared_models_1.NetworkName.BNBChain:
            return 'bsc';
        case shared_models_1.NetworkName.Polygon:
            return 'matic';
        case shared_models_1.NetworkName.Arbitrum:
            return 'arbitrum-one';
        case shared_models_1.NetworkName.PolygonAmoy:
        case shared_models_1.NetworkName.ArbitrumGoerli_DEPRECATED:
        case shared_models_1.NetworkName.EthereumGoerli_DEPRECATED:
        case shared_models_1.NetworkName.EthereumRopsten_DEPRECATED:
        case shared_models_1.NetworkName.PolygonMumbai_DEPRECATED:
        case shared_models_1.NetworkName.Hardhat:
        default:
            throw new Error('No Graph API hosted service for this network');
    }
};
const isSupportedByNetwork = (networkName) => {
    try {
        sourceNameForNetwork(networkName);
        return true;
    }
    catch {
        return false;
    }
};
const quickSyncEventsGraphV2 = async (chain, startingBlock) => {
    const network = (0, shared_models_1.networkForChain)(chain);
    if (!network || !isSupportedByNetwork(network.name)) {
        // Return empty logs, Engine will default to full scan.
        return graph_query_1.EMPTY_EVENTS;
    }
    const sdk = getBuiltGraphSDK(network.name);
    const nullifiers = await (0, graph_query_1.autoPaginatingQuery)(async (blockNumber) => (await sdk.Nullifiers({
        blockNumber,
    })).nullifiers, startingBlock.toString(), MAX_QUERY_RESULTS);
    await (0, shared_models_1.delay)(100);
    const unshields = await (0, graph_query_1.autoPaginatingQuery)(async (blockNumber) => (await sdk.Unshields({
        blockNumber,
    })).unshields, startingBlock.toString(), MAX_QUERY_RESULTS);
    await (0, shared_models_1.delay)(100);
    const commitments = await (0, graph_query_1.autoPaginatingQuery)(async (blockNumber) => (await sdk.Commitments({
        blockNumber,
    })).commitments, startingBlock.toString(), MAX_QUERY_RESULTS);
    const filteredNullifiers = (0, graph_util_1.removeDuplicatesByID)(nullifiers);
    const filteredUnshields = (0, graph_util_1.removeDuplicatesByID)(unshields);
    const filteredCommitments = (0, graph_util_1.removeDuplicatesByID)(commitments);
    const graphCommitmentBatches = createGraphCommitmentBatches(filteredCommitments);
    graphCommitmentBatches.sort(sortByTreeNumberAndStartPosition);
    const nullifierEvents = (0, graph_type_formatters_v2_1.formatGraphNullifierEventsV2)(filteredNullifiers);
    const unshieldEvents = (0, graph_type_formatters_v2_1.formatGraphUnshieldEventsV2)(filteredUnshields);
    const commitmentEvents = (0, graph_type_formatters_v2_1.formatGraphCommitmentEventsV2)(graphCommitmentBatches);
    return { nullifierEvents, unshieldEvents, commitmentEvents };
};
exports.quickSyncEventsGraphV2 = quickSyncEventsGraphV2;
const createGraphCommitmentBatches = (flattenedCommitments) => {
    const graphCommitmentMap = {};
    for (const commitment of flattenedCommitments) {
        const startPosition = commitment.batchStartTreePosition;
        const existingBatch = graphCommitmentMap[startPosition];
        if ((0, shared_models_1.isDefined)(existingBatch)) {
            existingBatch.commitments.push(commitment);
        }
        else {
            graphCommitmentMap[commitment.batchStartTreePosition] = {
                commitments: [commitment],
                transactionHash: commitment.transactionHash,
                treeNumber: commitment.treeNumber,
                startPosition: commitment.batchStartTreePosition,
                blockNumber: Number(commitment.blockNumber),
            };
        }
    }
    return (0, shared_models_1.removeUndefineds)(Object.values(graphCommitmentMap));
};
const sortByTreeNumberAndStartPosition = (a, b) => {
    if (a.treeNumber < b.treeNumber) {
        return -1;
    }
    if (a.treeNumber > b.treeNumber) {
        return 1;
    }
    if (a.startPosition < b.startPosition) {
        return -1;
    }
    if (a.startPosition > b.startPosition) {
        return 1;
    }
    return 0;
};
const getBuiltGraphClient = async (networkName) => {
    const meshForNetwork = meshes[networkName];
    if ((0, shared_models_1.isDefined)(meshForNetwork)) {
        return meshForNetwork;
    }
    const sourceName = sourceNameForNetwork(networkName);
    const meshOptions = await (0, graphql_1.getMeshOptions)();
    const filteredSources = meshOptions.sources.filter(source => {
        return source.name === sourceName;
    });
    if (filteredSources.length !== 1) {
        throw new Error(`Expected exactly one source for network ${networkName}, found ${filteredSources.length}`);
    }
    meshOptions.sources = [filteredSources[0]];
    const mesh = await (0, runtime_1.getMesh)(meshOptions);
    meshes[networkName] = mesh;
    const id = mesh.pubsub.subscribe('destroy', () => {
        meshes[networkName] = undefined;
        mesh.pubsub.unsubscribe(id);
    });
    return mesh;
};
const getBuiltGraphSDK = (networkName, globalContext) => {
    const sdkRequester$ = getBuiltGraphClient(networkName).then(({ sdkRequesterFactory }) => sdkRequesterFactory(globalContext));
    return (0, graphql_1.getSdk)((...args) => sdkRequester$.then(sdkRequester => sdkRequester(...args)));
};
//# sourceMappingURL=quick-sync-events-graph-v2.js.map