{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../../src/services/railgun/quick-sync/V2/graphql/index.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;AACH,cAAc;AACd,sDAAsD;AACtD,uDAAuD;AACvD,sDAAsD;AACtD,4DAA4D;AAC5D,yCAAyC;AACzC,iDAAiD;AACjD,qEAAqE;AACrE,gDAAgD;AAChD,oCAAoC;AACpC,wDAAwD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIxD,+CAA0C;AAI1C,+CAA6C;AAC7C,+CAAoD;AACpD,wFAAwD;AACxD,8CAAsD;AAItD,oEAAkD;AAClD,sFAA6D;AAC7D,+CAAqD;AACrD,6CAA4E;AAC5E,mDAA8H;AAC9H,+CAAuE;AACvE,+DAAiE;AA8gGjE,MAAM,OAAO,GAAG,oBAAU,CAAC,IAAI,CAAC,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AAEvF,MAAM,QAAQ,GAAa,CAAI,QAAgB,EAAE,EAAE;IACjD,MAAM,gBAAgB,GAAG,CAAC,oBAAU,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,oBAAU,CAAC,QAAQ,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,OAAO,GAAG,GAAG,EAAE,EAAE,CAAC,CAAC;IAChK,QAAO,gBAAgB,EAAE;QACvB,KAAK,uDAAuD;YAC1D,OAAO,kDAAO,yDAAyD,GAAM,CAAC;QAEhF,KAAK,kDAAkD;YACrD,OAAO,kDAAO,oDAAoD,GAAM,CAAC;QAE3E,KAAK,8CAA8C;YACjD,OAAO,kDAAO,gDAAgD,GAAM,CAAC;QAEvE,KAAK,mDAAmD;YACtD,OAAO,kDAAO,qDAAqD,GAAM,CAAC;QAE5E,KAAK,gDAAgD;YACnD,OAAO,kDAAO,kDAAkD,GAAM,CAAC;QAEzE;YACE,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,uBAAuB,gBAAgB,IAAI,CAAC,CAAC,CAAC;KACjF;AACH,CAAC,CAAC;AAEF,MAAM,SAAS,GAAG,IAAI,iBAAS,CAAC,cAAc,EAAE,IAAI,6BAAqB,CAAC;IACxE,GAAG,EAAE,OAAO;IACZ,QAAQ;IACR,QAAQ,EAAE,IAAI;CACf,CAAC,EAAE;IACF,QAAQ,EAAE,IAAI;IACd,QAAQ,EAAE,KAAK;CAChB,CAAC,CAAC;AAEU,QAAA,cAAc,GAA+B,SAAgB,CAAA;AACnE,KAAK,UAAU,cAAc;IACpC,MAAM,MAAM,GAAG,IAAI,cAAM,EAAE,CAAC;IAC5B,MAAM,YAAY,GAAG,SAAS,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IAChD,MAAM,MAAM,GAAG,IAAI,qBAAa,CAAC,aAAa,CAAC,CAAC;IAChD,MAAM,KAAK,GAAG,IAAK,2BAAiB,CAAC;QAC/B,GAAI,EAAU;QACd,QAAQ;QACR,KAAK,EAAE,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC;QAC/B,MAAM;QACN,MAAM;KACA,CAAC,CAAA;IAEb,MAAM,OAAO,GAAyB,EAAE,CAAC;IACzC,MAAM,UAAU,GAAoB,EAAE,CAAC;IACvC,MAAM,wBAAwB,GAAsB,EAAE,CAAC;IACvD,MAAM,kBAAkB,GAAG,EAAE,CAAC;IAC9B,MAAM,aAAa,GAAG,EAAE,CAAC;IACzB,MAAM,eAAe,GAAG,EAAE,CAAC;IAC3B,MAAM,qBAAqB,GAAG,EAAE,CAAC;IACjC,MAAM,iBAAiB,GAAG,EAAE,CAAC;IAC7B,MAAM,kBAAkB,GAAG,EAAW,CAAC;IACvC,MAAM,eAAe,GAAG,IAAI,iBAAc,CAAC;QAC7B,IAAI,EAAE,UAAU;QAChB,MAAM,EAAE,EAAC,UAAU,EAAC,kEAAkE,EAAC;QACvF,OAAO;QACP,KAAK;QACL,MAAM;QACN,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,UAAU,CAAC;QACrC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC;QAChC,QAAQ;KACT,CAAC,CAAC;IACf,MAAM,UAAU,GAAG,IAAI,iBAAc,CAAC;QACxB,IAAI,EAAE,KAAK;QACX,MAAM,EAAE,EAAC,UAAU,EAAC,6DAA6D,EAAC;QAClF,OAAO;QACP,KAAK;QACL,MAAM;QACN,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,KAAK,CAAC;QAChC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC;QAC3B,QAAQ;KACT,CAAC,CAAC;IACf,MAAM,YAAY,GAAG,IAAI,iBAAc,CAAC;QAC1B,IAAI,EAAE,OAAO;QACb,MAAM,EAAE,EAAC,UAAU,EAAC,iEAAiE,EAAC;QACtF,OAAO;QACP,KAAK;QACL,MAAM;QACN,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,OAAO,CAAC;QAClC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC;QAC7B,QAAQ;KACT,CAAC,CAAC;IACf,MAAM,kBAAkB,GAAG,IAAI,iBAAc,CAAC;QAChC,IAAI,EAAE,cAAc;QACpB,MAAM,EAAE,EAAC,UAAU,EAAC,kEAAkE,EAAC;QACvF,OAAO;QACP,KAAK;QACL,MAAM;QACN,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,cAAc,CAAC;QACzC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC;QACpC,QAAQ;KACT,CAAC,CAAC;IACf,MAAM,cAAc,GAAG,IAAI,iBAAc,CAAC;QAC5B,IAAI,EAAE,SAAS;QACf,MAAM,EAAE,EAAC,UAAU,EAAC,qEAAqE,EAAC;QAC1F,OAAO;QACP,KAAK;QACL,MAAM;QACN,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC;QACpC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC;QAC/B,QAAQ;KACT,CAAC,CAAC;IACf,OAAO,CAAC,CAAC,CAAC,GAAG;QACH,IAAI,EAAE,UAAU;QAChB,OAAO,EAAE,eAAe;QACxB,UAAU,EAAE,kBAAkB;KAC/B,CAAA;IACT,OAAO,CAAC,CAAC,CAAC,GAAG;QACH,IAAI,EAAE,KAAK;QACX,OAAO,EAAE,UAAU;QACnB,UAAU,EAAE,aAAa;KAC1B,CAAA;IACT,OAAO,CAAC,CAAC,CAAC,GAAG;QACH,IAAI,EAAE,OAAO;QACb,OAAO,EAAE,YAAY;QACrB,UAAU,EAAE,eAAe;KAC5B,CAAA;IACT,OAAO,CAAC,CAAC,CAAC,GAAG;QACH,IAAI,EAAE,cAAc;QACpB,OAAO,EAAE,kBAAkB;QAC3B,UAAU,EAAE,qBAAqB;KAClC,CAAA;IACT,OAAO,CAAC,CAAC,CAAC,GAAG;QACH,IAAI,EAAE,SAAS;QACf,OAAO,EAAE,cAAc;QACvB,UAAU,EAAE,iBAAiB;KAC9B,CAAA;IACT,MAAM,mBAAmB,GAAG,EAAW,CAAA;IACvC,MAAM,MAAM,GAAG,IAAI,0BAAuB,CAAC;QACnC,KAAK;QACL,MAAM;QACN,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,iBAAiB,CAAC;QACvC,KAAK,EAAE,SAAS,CAAC,KAAK,CAAC,iBAAiB,CAAC;KAC1C,CAAC,CAAA;IAEN,OAAO;QACL,OAAO;QACP,UAAU;QACV,kBAAkB;QAClB,mBAAmB;QACnB,KAAK;QACL,MAAM;QACN,MAAM;QACN,MAAM;QACN,wBAAwB;QACxB,IAAI,SAAS;YACX,OAAO;gBACP;oBACE,QAAQ,EAAE,0BAAkB;oBAC5B,IAAI,MAAM;wBACR,OAAO,IAAA,sBAAc,EAAC,0BAAkB,CAAC,CAAC;oBAC5C,CAAC;oBACD,QAAQ,EAAE,4BAA4B;iBACvC,EAAC;oBACA,QAAQ,EAAE,yBAAiB;oBAC3B,IAAI,MAAM;wBACR,OAAO,IAAA,sBAAc,EAAC,yBAAiB,CAAC,CAAC;oBAC3C,CAAC;oBACD,QAAQ,EAAE,2BAA2B;iBACtC,EAAC;oBACA,QAAQ,EAAE,2BAAmB;oBAC7B,IAAI,MAAM;wBACR,OAAO,IAAA,sBAAc,EAAC,2BAAmB,CAAC,CAAC;oBAC7C,CAAC;oBACD,QAAQ,EAAE,6BAA6B;iBACxC;aACF,CAAC;QACF,CAAC;QACD,OAAO,EAAP,aAAO;KACR,CAAC;AACJ,CAAC;AA3ID,wCA2IC;AAED,SAAgB,0BAA0B;IACxC,OAAO,IAAA,4BAAqB,EAAiB;QAC3C,OAAO;QACP,YAAY,EAAE,mBAAmB;QACjC,cAAc,EAAE,SAAS;KAC1B,CAAC,CAAA;AACJ,CAAC;AAND,gEAMC;AAGD,IAAI,aAAgD,CAAC;AAErD,SAAgB,mBAAmB;IACjC,IAAI,aAAa,IAAI,IAAI,EAAE;QACzB,aAAa,GAAG,cAAc,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,IAAA,iBAAO,EAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YACrF,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,SAAS,EAAE,GAAG,EAAE;gBAC/C,aAAa,GAAG,SAAS,CAAC;gBAC1B,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;YAC9B,CAAC,CAAC,CAAC;YACH,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;KACJ;IACD,OAAO,aAAa,CAAC;AACvB,CAAC;AAXD,kDAWC;AAEM,MAAM,OAAO,GAAkB,CAAC,GAAG,IAAI,EAAE,EAAE,CAAC,mBAAmB,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;AAApG,QAAA,OAAO,WAA6F;AAE1G,MAAM,SAAS,GAAoB,CAAC,GAAG,IAAI,EAAE,EAAE,CAAC,mBAAmB,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,SAAS,EAAE,EAAE,EAAE,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;AAA5G,QAAA,SAAS,aAAmG;AACzH,SAAgB,gBAAgB,CAAgD,aAA8B;IAC5G,MAAM,aAAa,GAAG,mBAAmB,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,mBAAmB,EAAE,EAAE,EAAE,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC,CAAC;IAClH,OAAO,MAAM,CAAoC,CAAC,GAAG,IAAI,EAAE,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AAC3H,CAAC;AAHD,4CAGC;AAkDY,QAAA,kBAAkB,GAAG,IAAA,WAAG,EAAA;;;;;;;;;;;;;;;KAesC,CAAC;AAC/D,QAAA,iBAAiB,GAAG,IAAA,WAAG,EAAA;;;;;;;;;;;;;;;;;;;;;;;KAuBqC,CAAC;AAC7D,QAAA,mBAAmB,GAAG,IAAA,WAAG,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAgHuC,CAAC;AAM9E,SAAgB,MAAM,CAAO,SAA0B;IACrD,OAAO;QACL,UAAU,CAAC,SAAoC,EAAE,OAAW;YAC1D,OAAO,SAAS,CAA4C,0BAAkB,EAAE,SAAS,EAAE,OAAO,CAA6B,CAAC;QAClI,CAAC;QACD,SAAS,CAAC,SAAmC,EAAE,OAAW;YACxD,OAAO,SAAS,CAA0C,yBAAiB,EAAE,SAAS,EAAE,OAAO,CAA4B,CAAC;QAC9H,CAAC;QACD,WAAW,CAAC,SAAqC,EAAE,OAAW;YAC5D,OAAO,SAAS,CAA8C,2BAAmB,EAAE,SAAS,EAAE,OAAO,CAA8B,CAAC;QACtI,CAAC;KACF,CAAC;AACJ,CAAC;AAZD,wBAYC","sourcesContent":["/**\n * TO UPDATE:\n * 1. Find all places that are \"MODIFIED\", move them into the new built index.ts (in .graphclient)\n * 2. add these comments (including eslint disables)\n * 3. move the modified index file to quick-sync/graphql/\n */\n// @ts-nocheck\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable import/no-duplicates */\n/* eslint-disable @typescript-eslint/ban-types */\n/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\n/* eslint-disable import/newline-after-import */\n/* eslint-disable prefer-template */\n/* eslint-disable @typescript-eslint/no-unsafe-return */\n\nimport { GraphQLResolveInfo, SelectionSetNode, FieldNode, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';\nimport { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\nimport { gql } from '@graphql-mesh/utils';\n\nimport type { GetMeshOptions } from '@graphql-mesh/runtime';\nimport type { YamlConfig } from '@graphql-mesh/types';\nimport { PubSub } from '@graphql-mesh/utils';\nimport { DefaultLogger } from '@graphql-mesh/utils';\nimport MeshCache from \"@graphql-mesh/cache-localforage\";\nimport { fetch as fetchFn } from '@whatwg-node/fetch';\n\nimport { MeshResolvedSource } from '@graphql-mesh/runtime';\nimport { MeshTransform, MeshPlugin } from '@graphql-mesh/types';\nimport GraphqlHandler from \"@graphql-mesh/graphql\"\nimport StitchingMerger from \"@graphql-mesh/merger-stitching\";\nimport { printWithCache } from '@graphql-mesh/utils';\nimport { createMeshHTTPHandler, MeshHTTPHandler } from '@graphql-mesh/http';\nimport { getMesh, ExecuteMeshFn, SubscribeMeshFn, MeshContext as BaseMeshContext, MeshInstance } from '@graphql-mesh/runtime';\nimport { MeshStore, FsStoreStorageAdapter } from '@graphql-mesh/store';\nimport { path as pathModule } from '@graphql-mesh/cross-helpers';\nimport { ImportFn } from '@graphql-mesh/types';\nimport type { ArbitrumOneTypes } from './.graphclient/sources/arbitrum-one/types';\nimport type { SepoliaTypes } from './.graphclient/sources/sepolia/types';\nimport type { BscTypes } from './.graphclient/sources/bsc/types';\nimport type { EthereumTypes } from './.graphclient/sources/ethereum/types';\nimport type { MaticTypes } from './.graphclient/sources/matic/types';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };\n\n\n\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  Bytes: string; // MODIFIED\n  BigInt: string; // MODIFIED\n};\n\nexport type Query = {\n  tokens: Array<Token>;\n  tokenById?: Maybe<Token>;\n  /** @deprecated Use tokenById */\n  tokenByUniqueInput?: Maybe<Token>;\n  tokensConnection: TokensConnection;\n  commitmentPreimages: Array<CommitmentPreimage>;\n  commitmentPreimageById?: Maybe<CommitmentPreimage>;\n  /** @deprecated Use commitmentPreimageById */\n  commitmentPreimageByUniqueInput?: Maybe<CommitmentPreimage>;\n  commitmentPreimagesConnection: CommitmentPreimagesConnection;\n  ciphertexts: Array<Ciphertext>;\n  ciphertextById?: Maybe<Ciphertext>;\n  /** @deprecated Use ciphertextById */\n  ciphertextByUniqueInput?: Maybe<Ciphertext>;\n  ciphertextsConnection: CiphertextsConnection;\n  legacyCommitmentCiphertexts: Array<LegacyCommitmentCiphertext>;\n  legacyCommitmentCiphertextById?: Maybe<LegacyCommitmentCiphertext>;\n  /** @deprecated Use legacyCommitmentCiphertextById */\n  legacyCommitmentCiphertextByUniqueInput?: Maybe<LegacyCommitmentCiphertext>;\n  legacyCommitmentCiphertextsConnection: LegacyCommitmentCiphertextsConnection;\n  commitmentCiphertexts: Array<CommitmentCiphertext>;\n  commitmentCiphertextById?: Maybe<CommitmentCiphertext>;\n  /** @deprecated Use commitmentCiphertextById */\n  commitmentCiphertextByUniqueInput?: Maybe<CommitmentCiphertext>;\n  commitmentCiphertextsConnection: CommitmentCiphertextsConnection;\n  legacyGeneratedCommitments: Array<LegacyGeneratedCommitment>;\n  legacyGeneratedCommitmentById?: Maybe<LegacyGeneratedCommitment>;\n  /** @deprecated Use legacyGeneratedCommitmentById */\n  legacyGeneratedCommitmentByUniqueInput?: Maybe<LegacyGeneratedCommitment>;\n  legacyGeneratedCommitmentsConnection: LegacyGeneratedCommitmentsConnection;\n  commitments: Array<Commitment>;\n  commitmentsConnection: CommitmentsConnection;\n  legacyEncryptedCommitments: Array<LegacyEncryptedCommitment>;\n  legacyEncryptedCommitmentById?: Maybe<LegacyEncryptedCommitment>;\n  /** @deprecated Use legacyEncryptedCommitmentById */\n  legacyEncryptedCommitmentByUniqueInput?: Maybe<LegacyEncryptedCommitment>;\n  legacyEncryptedCommitmentsConnection: LegacyEncryptedCommitmentsConnection;\n  shieldCommitments: Array<ShieldCommitment>;\n  shieldCommitmentById?: Maybe<ShieldCommitment>;\n  /** @deprecated Use shieldCommitmentById */\n  shieldCommitmentByUniqueInput?: Maybe<ShieldCommitment>;\n  shieldCommitmentsConnection: ShieldCommitmentsConnection;\n  transactCommitments: Array<TransactCommitment>;\n  transactCommitmentById?: Maybe<TransactCommitment>;\n  /** @deprecated Use transactCommitmentById */\n  transactCommitmentByUniqueInput?: Maybe<TransactCommitment>;\n  transactCommitmentsConnection: TransactCommitmentsConnection;\n  unshields: Array<Unshield>;\n  unshieldById?: Maybe<Unshield>;\n  /** @deprecated Use unshieldById */\n  unshieldByUniqueInput?: Maybe<Unshield>;\n  unshieldsConnection: UnshieldsConnection;\n  nullifiers: Array<Nullifier>;\n  nullifierById?: Maybe<Nullifier>;\n  /** @deprecated Use nullifierById */\n  nullifierByUniqueInput?: Maybe<Nullifier>;\n  nullifiersConnection: NullifiersConnection;\n  transactions: Array<Transaction>;\n  transactionById?: Maybe<Transaction>;\n  /** @deprecated Use transactionById */\n  transactionByUniqueInput?: Maybe<Transaction>;\n  transactionsConnection: TransactionsConnection;\n  verificationHashes: Array<VerificationHash>;\n  verificationHashById?: Maybe<VerificationHash>;\n  /** @deprecated Use verificationHashById */\n  verificationHashByUniqueInput?: Maybe<VerificationHash>;\n  verificationHashesConnection: VerificationHashesConnection;\n  commitmentBatchEventNews: Array<CommitmentBatchEventNew>;\n  commitmentBatchEventNewById?: Maybe<CommitmentBatchEventNew>;\n  /** @deprecated Use commitmentBatchEventNewById */\n  commitmentBatchEventNewByUniqueInput?: Maybe<CommitmentBatchEventNew>;\n  commitmentBatchEventNewsConnection: CommitmentBatchEventNewsConnection;\n  squidStatus?: Maybe<SquidStatus>;\n};\n\n\nexport type QuerytokensArgs = {\n  where?: InputMaybe<TokenWhereInput>;\n  orderBy?: InputMaybe<Array<TokenOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerytokenByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerytokenByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerytokensConnectionArgs = {\n  orderBy: Array<TokenOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<TokenWhereInput>;\n};\n\n\nexport type QuerycommitmentPreimagesArgs = {\n  where?: InputMaybe<CommitmentPreimageWhereInput>;\n  orderBy?: InputMaybe<Array<CommitmentPreimageOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerycommitmentPreimageByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerycommitmentPreimageByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerycommitmentPreimagesConnectionArgs = {\n  orderBy: Array<CommitmentPreimageOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<CommitmentPreimageWhereInput>;\n};\n\n\nexport type QueryciphertextsArgs = {\n  where?: InputMaybe<CiphertextWhereInput>;\n  orderBy?: InputMaybe<Array<CiphertextOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QueryciphertextByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QueryciphertextByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryciphertextsConnectionArgs = {\n  orderBy: Array<CiphertextOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<CiphertextWhereInput>;\n};\n\n\nexport type QuerylegacyCommitmentCiphertextsArgs = {\n  where?: InputMaybe<LegacyCommitmentCiphertextWhereInput>;\n  orderBy?: InputMaybe<Array<LegacyCommitmentCiphertextOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerylegacyCommitmentCiphertextByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerylegacyCommitmentCiphertextByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerylegacyCommitmentCiphertextsConnectionArgs = {\n  orderBy: Array<LegacyCommitmentCiphertextOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<LegacyCommitmentCiphertextWhereInput>;\n};\n\n\nexport type QuerycommitmentCiphertextsArgs = {\n  where?: InputMaybe<CommitmentCiphertextWhereInput>;\n  orderBy?: InputMaybe<Array<CommitmentCiphertextOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerycommitmentCiphertextByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerycommitmentCiphertextByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerycommitmentCiphertextsConnectionArgs = {\n  orderBy: Array<CommitmentCiphertextOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<CommitmentCiphertextWhereInput>;\n};\n\n\nexport type QuerylegacyGeneratedCommitmentsArgs = {\n  where?: InputMaybe<LegacyGeneratedCommitmentWhereInput>;\n  orderBy?: InputMaybe<Array<LegacyGeneratedCommitmentOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerylegacyGeneratedCommitmentByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerylegacyGeneratedCommitmentByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerylegacyGeneratedCommitmentsConnectionArgs = {\n  orderBy: Array<LegacyGeneratedCommitmentOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<LegacyGeneratedCommitmentWhereInput>;\n};\n\n\nexport type QuerycommitmentsArgs = {\n  where?: InputMaybe<CommitmentWhereInput>;\n  orderBy?: InputMaybe<Array<CommitmentOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerycommitmentsConnectionArgs = {\n  orderBy: Array<CommitmentOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<CommitmentWhereInput>;\n};\n\n\nexport type QuerylegacyEncryptedCommitmentsArgs = {\n  where?: InputMaybe<LegacyEncryptedCommitmentWhereInput>;\n  orderBy?: InputMaybe<Array<LegacyEncryptedCommitmentOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerylegacyEncryptedCommitmentByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerylegacyEncryptedCommitmentByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerylegacyEncryptedCommitmentsConnectionArgs = {\n  orderBy: Array<LegacyEncryptedCommitmentOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<LegacyEncryptedCommitmentWhereInput>;\n};\n\n\nexport type QueryshieldCommitmentsArgs = {\n  where?: InputMaybe<ShieldCommitmentWhereInput>;\n  orderBy?: InputMaybe<Array<ShieldCommitmentOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QueryshieldCommitmentByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QueryshieldCommitmentByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryshieldCommitmentsConnectionArgs = {\n  orderBy: Array<ShieldCommitmentOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<ShieldCommitmentWhereInput>;\n};\n\n\nexport type QuerytransactCommitmentsArgs = {\n  where?: InputMaybe<TransactCommitmentWhereInput>;\n  orderBy?: InputMaybe<Array<TransactCommitmentOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerytransactCommitmentByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerytransactCommitmentByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerytransactCommitmentsConnectionArgs = {\n  orderBy: Array<TransactCommitmentOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<TransactCommitmentWhereInput>;\n};\n\n\nexport type QueryunshieldsArgs = {\n  where?: InputMaybe<UnshieldWhereInput>;\n  orderBy?: InputMaybe<Array<UnshieldOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QueryunshieldByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QueryunshieldByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryunshieldsConnectionArgs = {\n  orderBy: Array<UnshieldOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<UnshieldWhereInput>;\n};\n\n\nexport type QuerynullifiersArgs = {\n  where?: InputMaybe<NullifierWhereInput>;\n  orderBy?: InputMaybe<Array<NullifierOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerynullifierByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerynullifierByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerynullifiersConnectionArgs = {\n  orderBy: Array<NullifierOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<NullifierWhereInput>;\n};\n\n\nexport type QuerytransactionsArgs = {\n  where?: InputMaybe<TransactionWhereInput>;\n  orderBy?: InputMaybe<Array<TransactionOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerytransactionByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerytransactionByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerytransactionsConnectionArgs = {\n  orderBy: Array<TransactionOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<TransactionWhereInput>;\n};\n\n\nexport type QueryverificationHashesArgs = {\n  where?: InputMaybe<VerificationHashWhereInput>;\n  orderBy?: InputMaybe<Array<VerificationHashOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QueryverificationHashByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QueryverificationHashByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryverificationHashesConnectionArgs = {\n  orderBy: Array<VerificationHashOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<VerificationHashWhereInput>;\n};\n\n\nexport type QuerycommitmentBatchEventNewsArgs = {\n  where?: InputMaybe<CommitmentBatchEventNewWhereInput>;\n  orderBy?: InputMaybe<Array<CommitmentBatchEventNewOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerycommitmentBatchEventNewByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerycommitmentBatchEventNewByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerycommitmentBatchEventNewsConnectionArgs = {\n  orderBy: Array<CommitmentBatchEventNewOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<CommitmentBatchEventNewWhereInput>;\n};\n\nexport type Token = {\n  id: Scalars['String'];\n  tokenType: TokenType;\n  tokenAddress: Scalars['Bytes'];\n  tokenSubID: Scalars['String'];\n};\n\nexport type TokenType =\n  | 'ERC20'\n  | 'ERC721'\n  | 'ERC1155';\n\nexport type TokenWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  tokenType_isNull?: InputMaybe<Scalars['Boolean']>;\n  tokenType_eq?: InputMaybe<TokenType>;\n  tokenType_not_eq?: InputMaybe<TokenType>;\n  tokenType_in?: InputMaybe<Array<TokenType>>;\n  tokenType_not_in?: InputMaybe<Array<TokenType>>;\n  tokenAddress_isNull?: InputMaybe<Scalars['Boolean']>;\n  tokenAddress_eq?: InputMaybe<Scalars['Bytes']>;\n  tokenAddress_not_eq?: InputMaybe<Scalars['Bytes']>;\n  tokenSubID_isNull?: InputMaybe<Scalars['Boolean']>;\n  tokenSubID_eq?: InputMaybe<Scalars['String']>;\n  tokenSubID_not_eq?: InputMaybe<Scalars['String']>;\n  tokenSubID_gt?: InputMaybe<Scalars['String']>;\n  tokenSubID_gte?: InputMaybe<Scalars['String']>;\n  tokenSubID_lt?: InputMaybe<Scalars['String']>;\n  tokenSubID_lte?: InputMaybe<Scalars['String']>;\n  tokenSubID_in?: InputMaybe<Array<Scalars['String']>>;\n  tokenSubID_not_in?: InputMaybe<Array<Scalars['String']>>;\n  tokenSubID_contains?: InputMaybe<Scalars['String']>;\n  tokenSubID_not_contains?: InputMaybe<Scalars['String']>;\n  tokenSubID_containsInsensitive?: InputMaybe<Scalars['String']>;\n  tokenSubID_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  tokenSubID_startsWith?: InputMaybe<Scalars['String']>;\n  tokenSubID_not_startsWith?: InputMaybe<Scalars['String']>;\n  tokenSubID_endsWith?: InputMaybe<Scalars['String']>;\n  tokenSubID_not_endsWith?: InputMaybe<Scalars['String']>;\n  AND?: InputMaybe<Array<TokenWhereInput>>;\n  OR?: InputMaybe<Array<TokenWhereInput>>;\n};\n\nexport type TokenOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'tokenType_ASC'\n  | 'tokenType_DESC'\n  | 'tokenType_ASC_NULLS_FIRST'\n  | 'tokenType_DESC_NULLS_LAST'\n  | 'tokenAddress_ASC'\n  | 'tokenAddress_DESC'\n  | 'tokenAddress_ASC_NULLS_FIRST'\n  | 'tokenAddress_DESC_NULLS_LAST'\n  | 'tokenSubID_ASC'\n  | 'tokenSubID_DESC'\n  | 'tokenSubID_ASC_NULLS_FIRST'\n  | 'tokenSubID_DESC_NULLS_LAST';\n\nexport type WhereIdInput = {\n  id: Scalars['String'];\n};\n\nexport type TokensConnection = {\n  edges: Array<TokenEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type TokenEdge = {\n  node: Token;\n  cursor: Scalars['String'];\n};\n\nexport type PageInfo = {\n  hasNextPage: Scalars['Boolean'];\n  hasPreviousPage: Scalars['Boolean'];\n  startCursor: Scalars['String'];\n  endCursor: Scalars['String'];\n};\n\nexport type CommitmentPreimage = {\n  id: Scalars['String'];\n  npk: Scalars['Bytes'];\n  token: Token;\n  value: Scalars['BigInt'];\n};\n\nexport type CommitmentPreimageWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  npk_isNull?: InputMaybe<Scalars['Boolean']>;\n  npk_eq?: InputMaybe<Scalars['Bytes']>;\n  npk_not_eq?: InputMaybe<Scalars['Bytes']>;\n  token_isNull?: InputMaybe<Scalars['Boolean']>;\n  token?: InputMaybe<TokenWhereInput>;\n  value_isNull?: InputMaybe<Scalars['Boolean']>;\n  value_eq?: InputMaybe<Scalars['BigInt']>;\n  value_not_eq?: InputMaybe<Scalars['BigInt']>;\n  value_gt?: InputMaybe<Scalars['BigInt']>;\n  value_gte?: InputMaybe<Scalars['BigInt']>;\n  value_lt?: InputMaybe<Scalars['BigInt']>;\n  value_lte?: InputMaybe<Scalars['BigInt']>;\n  value_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  value_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  AND?: InputMaybe<Array<CommitmentPreimageWhereInput>>;\n  OR?: InputMaybe<Array<CommitmentPreimageWhereInput>>;\n};\n\nexport type CommitmentPreimageOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'npk_ASC'\n  | 'npk_DESC'\n  | 'npk_ASC_NULLS_FIRST'\n  | 'npk_DESC_NULLS_LAST'\n  | 'token_id_ASC'\n  | 'token_id_DESC'\n  | 'token_id_ASC_NULLS_FIRST'\n  | 'token_id_DESC_NULLS_LAST'\n  | 'token_tokenType_ASC'\n  | 'token_tokenType_DESC'\n  | 'token_tokenType_ASC_NULLS_FIRST'\n  | 'token_tokenType_DESC_NULLS_LAST'\n  | 'token_tokenAddress_ASC'\n  | 'token_tokenAddress_DESC'\n  | 'token_tokenAddress_ASC_NULLS_FIRST'\n  | 'token_tokenAddress_DESC_NULLS_LAST'\n  | 'token_tokenSubID_ASC'\n  | 'token_tokenSubID_DESC'\n  | 'token_tokenSubID_ASC_NULLS_FIRST'\n  | 'token_tokenSubID_DESC_NULLS_LAST'\n  | 'value_ASC'\n  | 'value_DESC'\n  | 'value_ASC_NULLS_FIRST'\n  | 'value_DESC_NULLS_LAST';\n\nexport type CommitmentPreimagesConnection = {\n  edges: Array<CommitmentPreimageEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CommitmentPreimageEdge = {\n  node: CommitmentPreimage;\n  cursor: Scalars['String'];\n};\n\nexport type Ciphertext = {\n  id: Scalars['String'];\n  iv: Scalars['Bytes'];\n  tag: Scalars['Bytes'];\n  data: Array<Scalars['Bytes']>;\n};\n\nexport type CiphertextWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  iv_isNull?: InputMaybe<Scalars['Boolean']>;\n  iv_eq?: InputMaybe<Scalars['Bytes']>;\n  iv_not_eq?: InputMaybe<Scalars['Bytes']>;\n  tag_isNull?: InputMaybe<Scalars['Boolean']>;\n  tag_eq?: InputMaybe<Scalars['Bytes']>;\n  tag_not_eq?: InputMaybe<Scalars['Bytes']>;\n  data_isNull?: InputMaybe<Scalars['Boolean']>;\n  data_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  data_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  data_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  AND?: InputMaybe<Array<CiphertextWhereInput>>;\n  OR?: InputMaybe<Array<CiphertextWhereInput>>;\n};\n\nexport type CiphertextOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'iv_ASC'\n  | 'iv_DESC'\n  | 'iv_ASC_NULLS_FIRST'\n  | 'iv_DESC_NULLS_LAST'\n  | 'tag_ASC'\n  | 'tag_DESC'\n  | 'tag_ASC_NULLS_FIRST'\n  | 'tag_DESC_NULLS_LAST';\n\nexport type CiphertextsConnection = {\n  edges: Array<CiphertextEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CiphertextEdge = {\n  node: Ciphertext;\n  cursor: Scalars['String'];\n};\n\nexport type LegacyCommitmentCiphertext = {\n  id: Scalars['String'];\n  ciphertext: Ciphertext;\n  ephemeralKeys: Array<Scalars['Bytes']>;\n  memo: Array<Scalars['Bytes']>;\n};\n\nexport type LegacyCommitmentCiphertextWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  ciphertext_isNull?: InputMaybe<Scalars['Boolean']>;\n  ciphertext?: InputMaybe<CiphertextWhereInput>;\n  ephemeralKeys_isNull?: InputMaybe<Scalars['Boolean']>;\n  ephemeralKeys_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  ephemeralKeys_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  ephemeralKeys_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  memo_isNull?: InputMaybe<Scalars['Boolean']>;\n  memo_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  memo_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  memo_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  AND?: InputMaybe<Array<LegacyCommitmentCiphertextWhereInput>>;\n  OR?: InputMaybe<Array<LegacyCommitmentCiphertextWhereInput>>;\n};\n\nexport type LegacyCommitmentCiphertextOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'ciphertext_id_ASC'\n  | 'ciphertext_id_DESC'\n  | 'ciphertext_id_ASC_NULLS_FIRST'\n  | 'ciphertext_id_DESC_NULLS_LAST'\n  | 'ciphertext_iv_ASC'\n  | 'ciphertext_iv_DESC'\n  | 'ciphertext_iv_ASC_NULLS_FIRST'\n  | 'ciphertext_iv_DESC_NULLS_LAST'\n  | 'ciphertext_tag_ASC'\n  | 'ciphertext_tag_DESC'\n  | 'ciphertext_tag_ASC_NULLS_FIRST'\n  | 'ciphertext_tag_DESC_NULLS_LAST';\n\nexport type LegacyCommitmentCiphertextsConnection = {\n  edges: Array<LegacyCommitmentCiphertextEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type LegacyCommitmentCiphertextEdge = {\n  node: LegacyCommitmentCiphertext;\n  cursor: Scalars['String'];\n};\n\nexport type CommitmentCiphertext = {\n  id: Scalars['String'];\n  ciphertext: Ciphertext;\n  blindedSenderViewingKey: Scalars['Bytes'];\n  blindedReceiverViewingKey: Scalars['Bytes'];\n  annotationData: Scalars['Bytes'];\n  memo: Scalars['Bytes'];\n};\n\nexport type CommitmentCiphertextWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  ciphertext_isNull?: InputMaybe<Scalars['Boolean']>;\n  ciphertext?: InputMaybe<CiphertextWhereInput>;\n  blindedSenderViewingKey_isNull?: InputMaybe<Scalars['Boolean']>;\n  blindedSenderViewingKey_eq?: InputMaybe<Scalars['Bytes']>;\n  blindedSenderViewingKey_not_eq?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey_isNull?: InputMaybe<Scalars['Boolean']>;\n  blindedReceiverViewingKey_eq?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey_not_eq?: InputMaybe<Scalars['Bytes']>;\n  annotationData_isNull?: InputMaybe<Scalars['Boolean']>;\n  annotationData_eq?: InputMaybe<Scalars['Bytes']>;\n  annotationData_not_eq?: InputMaybe<Scalars['Bytes']>;\n  memo_isNull?: InputMaybe<Scalars['Boolean']>;\n  memo_eq?: InputMaybe<Scalars['Bytes']>;\n  memo_not_eq?: InputMaybe<Scalars['Bytes']>;\n  AND?: InputMaybe<Array<CommitmentCiphertextWhereInput>>;\n  OR?: InputMaybe<Array<CommitmentCiphertextWhereInput>>;\n};\n\nexport type CommitmentCiphertextOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'ciphertext_id_ASC'\n  | 'ciphertext_id_DESC'\n  | 'ciphertext_id_ASC_NULLS_FIRST'\n  | 'ciphertext_id_DESC_NULLS_LAST'\n  | 'ciphertext_iv_ASC'\n  | 'ciphertext_iv_DESC'\n  | 'ciphertext_iv_ASC_NULLS_FIRST'\n  | 'ciphertext_iv_DESC_NULLS_LAST'\n  | 'ciphertext_tag_ASC'\n  | 'ciphertext_tag_DESC'\n  | 'ciphertext_tag_ASC_NULLS_FIRST'\n  | 'ciphertext_tag_DESC_NULLS_LAST'\n  | 'blindedSenderViewingKey_ASC'\n  | 'blindedSenderViewingKey_DESC'\n  | 'blindedSenderViewingKey_ASC_NULLS_FIRST'\n  | 'blindedSenderViewingKey_DESC_NULLS_LAST'\n  | 'blindedReceiverViewingKey_ASC'\n  | 'blindedReceiverViewingKey_DESC'\n  | 'blindedReceiverViewingKey_ASC_NULLS_FIRST'\n  | 'blindedReceiverViewingKey_DESC_NULLS_LAST'\n  | 'annotationData_ASC'\n  | 'annotationData_DESC'\n  | 'annotationData_ASC_NULLS_FIRST'\n  | 'annotationData_DESC_NULLS_LAST'\n  | 'memo_ASC'\n  | 'memo_DESC'\n  | 'memo_ASC_NULLS_FIRST'\n  | 'memo_DESC_NULLS_LAST';\n\nexport type CommitmentCiphertextsConnection = {\n  edges: Array<CommitmentCiphertextEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CommitmentCiphertextEdge = {\n  node: CommitmentCiphertext;\n  cursor: Scalars['String'];\n};\n\nexport type LegacyGeneratedCommitment = Commitment & {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  batchStartTreePosition: Scalars['Int'];\n  treePosition: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hash: Scalars['BigInt'];\n  preimage: CommitmentPreimage;\n  encryptedRandom: Array<Scalars['Bytes']>;\n};\n\nexport type Commitment = {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  batchStartTreePosition: Scalars['Int'];\n  treePosition: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hash: Scalars['BigInt'];\n};\n\nexport type CommitmentType =\n  | 'ShieldCommitment'\n  | 'TransactCommitment'\n  | 'LegacyGeneratedCommitment'\n  | 'LegacyEncryptedCommitment';\n\nexport type LegacyGeneratedCommitmentWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  treePosition_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_gt?: InputMaybe<Scalars['Int']>;\n  treePosition_gte?: InputMaybe<Scalars['Int']>;\n  treePosition_lt?: InputMaybe<Scalars['Int']>;\n  treePosition_lte?: InputMaybe<Scalars['Int']>;\n  treePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitmentType_eq?: InputMaybe<CommitmentType>;\n  commitmentType_not_eq?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']>;\n  hash_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_not_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_gt?: InputMaybe<Scalars['BigInt']>;\n  hash_gte?: InputMaybe<Scalars['BigInt']>;\n  hash_lt?: InputMaybe<Scalars['BigInt']>;\n  hash_lte?: InputMaybe<Scalars['BigInt']>;\n  hash_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  hash_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  preimage_isNull?: InputMaybe<Scalars['Boolean']>;\n  preimage?: InputMaybe<CommitmentPreimageWhereInput>;\n  encryptedRandom_isNull?: InputMaybe<Scalars['Boolean']>;\n  encryptedRandom_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedRandom_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedRandom_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  AND?: InputMaybe<Array<LegacyGeneratedCommitmentWhereInput>>;\n  OR?: InputMaybe<Array<LegacyGeneratedCommitmentWhereInput>>;\n};\n\nexport type LegacyGeneratedCommitmentOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST'\n  | 'treePosition_ASC'\n  | 'treePosition_DESC'\n  | 'treePosition_ASC_NULLS_FIRST'\n  | 'treePosition_DESC_NULLS_LAST'\n  | 'commitmentType_ASC'\n  | 'commitmentType_DESC'\n  | 'commitmentType_ASC_NULLS_FIRST'\n  | 'commitmentType_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_DESC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC_NULLS_LAST'\n  | 'preimage_id_ASC'\n  | 'preimage_id_DESC'\n  | 'preimage_id_ASC_NULLS_FIRST'\n  | 'preimage_id_DESC_NULLS_LAST'\n  | 'preimage_npk_ASC'\n  | 'preimage_npk_DESC'\n  | 'preimage_npk_ASC_NULLS_FIRST'\n  | 'preimage_npk_DESC_NULLS_LAST'\n  | 'preimage_value_ASC'\n  | 'preimage_value_DESC'\n  | 'preimage_value_ASC_NULLS_FIRST'\n  | 'preimage_value_DESC_NULLS_LAST';\n\nexport type LegacyGeneratedCommitmentsConnection = {\n  edges: Array<LegacyGeneratedCommitmentEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type LegacyGeneratedCommitmentEdge = {\n  node: LegacyGeneratedCommitment;\n  cursor: Scalars['String'];\n};\n\nexport type CommitmentWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  treePosition_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_gt?: InputMaybe<Scalars['Int']>;\n  treePosition_gte?: InputMaybe<Scalars['Int']>;\n  treePosition_lt?: InputMaybe<Scalars['Int']>;\n  treePosition_lte?: InputMaybe<Scalars['Int']>;\n  treePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitmentType_eq?: InputMaybe<CommitmentType>;\n  commitmentType_not_eq?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']>;\n  hash_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_not_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_gt?: InputMaybe<Scalars['BigInt']>;\n  hash_gte?: InputMaybe<Scalars['BigInt']>;\n  hash_lt?: InputMaybe<Scalars['BigInt']>;\n  hash_lte?: InputMaybe<Scalars['BigInt']>;\n  hash_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  hash_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  AND?: InputMaybe<Array<CommitmentWhereInput>>;\n  OR?: InputMaybe<Array<CommitmentWhereInput>>;\n};\n\nexport type CommitmentOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST'\n  | 'treePosition_ASC'\n  | 'treePosition_DESC'\n  | 'treePosition_ASC_NULLS_FIRST'\n  | 'treePosition_DESC_NULLS_LAST'\n  | 'commitmentType_ASC'\n  | 'commitmentType_DESC'\n  | 'commitmentType_ASC_NULLS_FIRST'\n  | 'commitmentType_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_DESC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC_NULLS_LAST'\n  | '_type_ASC'\n  | '_type_DESC';\n\nexport type CommitmentsConnection = {\n  edges: Array<CommitmentEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CommitmentEdge = {\n  node: Commitment;\n  cursor: Scalars['String'];\n};\n\nexport type LegacyEncryptedCommitment = Commitment & {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  batchStartTreePosition: Scalars['Int'];\n  treePosition: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hash: Scalars['BigInt'];\n  legacyCiphertext: LegacyCommitmentCiphertext; // MODIFIED\n};\n\nexport type LegacyEncryptedCommitmentWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  treePosition_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_gt?: InputMaybe<Scalars['Int']>;\n  treePosition_gte?: InputMaybe<Scalars['Int']>;\n  treePosition_lt?: InputMaybe<Scalars['Int']>;\n  treePosition_lte?: InputMaybe<Scalars['Int']>;\n  treePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitmentType_eq?: InputMaybe<CommitmentType>;\n  commitmentType_not_eq?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']>;\n  hash_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_not_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_gt?: InputMaybe<Scalars['BigInt']>;\n  hash_gte?: InputMaybe<Scalars['BigInt']>;\n  hash_lt?: InputMaybe<Scalars['BigInt']>;\n  hash_lte?: InputMaybe<Scalars['BigInt']>;\n  hash_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  hash_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  ciphertext_isNull?: InputMaybe<Scalars['Boolean']>;\n  ciphertext?: InputMaybe<LegacyCommitmentCiphertextWhereInput>;\n  AND?: InputMaybe<Array<LegacyEncryptedCommitmentWhereInput>>;\n  OR?: InputMaybe<Array<LegacyEncryptedCommitmentWhereInput>>;\n};\n\nexport type LegacyEncryptedCommitmentOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST'\n  | 'treePosition_ASC'\n  | 'treePosition_DESC'\n  | 'treePosition_ASC_NULLS_FIRST'\n  | 'treePosition_DESC_NULLS_LAST'\n  | 'commitmentType_ASC'\n  | 'commitmentType_DESC'\n  | 'commitmentType_ASC_NULLS_FIRST'\n  | 'commitmentType_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_DESC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC_NULLS_LAST'\n  | 'ciphertext_id_ASC'\n  | 'ciphertext_id_DESC'\n  | 'ciphertext_id_ASC_NULLS_FIRST'\n  | 'ciphertext_id_DESC_NULLS_LAST';\n\nexport type LegacyEncryptedCommitmentsConnection = {\n  edges: Array<LegacyEncryptedCommitmentEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type LegacyEncryptedCommitmentEdge = {\n  node: LegacyEncryptedCommitment;\n  cursor: Scalars['String'];\n};\n\nexport type ShieldCommitment = Commitment & {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  batchStartTreePosition: Scalars['Int'];\n  treePosition: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hash: Scalars['BigInt'];\n  preimage: CommitmentPreimage;\n  encryptedBundle: Array<Scalars['Bytes']>;\n  shieldKey: Scalars['Bytes'];\n  fee?: Maybe<Scalars['BigInt']>;\n};\n\nexport type ShieldCommitmentWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  treePosition_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_gt?: InputMaybe<Scalars['Int']>;\n  treePosition_gte?: InputMaybe<Scalars['Int']>;\n  treePosition_lt?: InputMaybe<Scalars['Int']>;\n  treePosition_lte?: InputMaybe<Scalars['Int']>;\n  treePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitmentType_eq?: InputMaybe<CommitmentType>;\n  commitmentType_not_eq?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']>;\n  hash_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_not_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_gt?: InputMaybe<Scalars['BigInt']>;\n  hash_gte?: InputMaybe<Scalars['BigInt']>;\n  hash_lt?: InputMaybe<Scalars['BigInt']>;\n  hash_lte?: InputMaybe<Scalars['BigInt']>;\n  hash_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  hash_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  preimage_isNull?: InputMaybe<Scalars['Boolean']>;\n  preimage?: InputMaybe<CommitmentPreimageWhereInput>;\n  encryptedBundle_isNull?: InputMaybe<Scalars['Boolean']>;\n  encryptedBundle_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedBundle_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedBundle_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  shieldKey_isNull?: InputMaybe<Scalars['Boolean']>;\n  shieldKey_eq?: InputMaybe<Scalars['Bytes']>;\n  shieldKey_not_eq?: InputMaybe<Scalars['Bytes']>;\n  fee_isNull?: InputMaybe<Scalars['Boolean']>;\n  fee_eq?: InputMaybe<Scalars['BigInt']>;\n  fee_not_eq?: InputMaybe<Scalars['BigInt']>;\n  fee_gt?: InputMaybe<Scalars['BigInt']>;\n  fee_gte?: InputMaybe<Scalars['BigInt']>;\n  fee_lt?: InputMaybe<Scalars['BigInt']>;\n  fee_lte?: InputMaybe<Scalars['BigInt']>;\n  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  AND?: InputMaybe<Array<ShieldCommitmentWhereInput>>;\n  OR?: InputMaybe<Array<ShieldCommitmentWhereInput>>;\n};\n\nexport type ShieldCommitmentOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST'\n  | 'treePosition_ASC'\n  | 'treePosition_DESC'\n  | 'treePosition_ASC_NULLS_FIRST'\n  | 'treePosition_DESC_NULLS_LAST'\n  | 'commitmentType_ASC'\n  | 'commitmentType_DESC'\n  | 'commitmentType_ASC_NULLS_FIRST'\n  | 'commitmentType_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_DESC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC_NULLS_LAST'\n  | 'preimage_id_ASC'\n  | 'preimage_id_DESC'\n  | 'preimage_id_ASC_NULLS_FIRST'\n  | 'preimage_id_DESC_NULLS_LAST'\n  | 'preimage_npk_ASC'\n  | 'preimage_npk_DESC'\n  | 'preimage_npk_ASC_NULLS_FIRST'\n  | 'preimage_npk_DESC_NULLS_LAST'\n  | 'preimage_value_ASC'\n  | 'preimage_value_DESC'\n  | 'preimage_value_ASC_NULLS_FIRST'\n  | 'preimage_value_DESC_NULLS_LAST'\n  | 'shieldKey_ASC'\n  | 'shieldKey_DESC'\n  | 'shieldKey_ASC_NULLS_FIRST'\n  | 'shieldKey_DESC_NULLS_LAST'\n  | 'fee_ASC'\n  | 'fee_DESC'\n  | 'fee_ASC_NULLS_FIRST'\n  | 'fee_DESC_NULLS_LAST';\n\nexport type ShieldCommitmentsConnection = {\n  edges: Array<ShieldCommitmentEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type ShieldCommitmentEdge = {\n  node: ShieldCommitment;\n  cursor: Scalars['String'];\n};\n\nexport type TransactCommitment = Commitment & {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  batchStartTreePosition: Scalars['Int'];\n  treePosition: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hash: Scalars['BigInt'];\n  ciphertext: CommitmentCiphertext;\n};\n\nexport type TransactCommitmentWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  treePosition_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_gt?: InputMaybe<Scalars['Int']>;\n  treePosition_gte?: InputMaybe<Scalars['Int']>;\n  treePosition_lt?: InputMaybe<Scalars['Int']>;\n  treePosition_lte?: InputMaybe<Scalars['Int']>;\n  treePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitmentType_eq?: InputMaybe<CommitmentType>;\n  commitmentType_not_eq?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']>;\n  hash_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_not_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_gt?: InputMaybe<Scalars['BigInt']>;\n  hash_gte?: InputMaybe<Scalars['BigInt']>;\n  hash_lt?: InputMaybe<Scalars['BigInt']>;\n  hash_lte?: InputMaybe<Scalars['BigInt']>;\n  hash_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  hash_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  ciphertext_isNull?: InputMaybe<Scalars['Boolean']>;\n  ciphertext?: InputMaybe<CommitmentCiphertextWhereInput>;\n  AND?: InputMaybe<Array<TransactCommitmentWhereInput>>;\n  OR?: InputMaybe<Array<TransactCommitmentWhereInput>>;\n};\n\nexport type TransactCommitmentOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST'\n  | 'treePosition_ASC'\n  | 'treePosition_DESC'\n  | 'treePosition_ASC_NULLS_FIRST'\n  | 'treePosition_DESC_NULLS_LAST'\n  | 'commitmentType_ASC'\n  | 'commitmentType_DESC'\n  | 'commitmentType_ASC_NULLS_FIRST'\n  | 'commitmentType_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_DESC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC_NULLS_LAST'\n  | 'ciphertext_id_ASC'\n  | 'ciphertext_id_DESC'\n  | 'ciphertext_id_ASC_NULLS_FIRST'\n  | 'ciphertext_id_DESC_NULLS_LAST'\n  | 'ciphertext_blindedSenderViewingKey_ASC'\n  | 'ciphertext_blindedSenderViewingKey_DESC'\n  | 'ciphertext_blindedSenderViewingKey_ASC_NULLS_FIRST'\n  | 'ciphertext_blindedSenderViewingKey_DESC_NULLS_LAST'\n  | 'ciphertext_blindedReceiverViewingKey_ASC'\n  | 'ciphertext_blindedReceiverViewingKey_DESC'\n  | 'ciphertext_blindedReceiverViewingKey_ASC_NULLS_FIRST'\n  | 'ciphertext_blindedReceiverViewingKey_DESC_NULLS_LAST'\n  | 'ciphertext_annotationData_ASC'\n  | 'ciphertext_annotationData_DESC'\n  | 'ciphertext_annotationData_ASC_NULLS_FIRST'\n  | 'ciphertext_annotationData_DESC_NULLS_LAST'\n  | 'ciphertext_memo_ASC'\n  | 'ciphertext_memo_DESC'\n  | 'ciphertext_memo_ASC_NULLS_FIRST'\n  | 'ciphertext_memo_DESC_NULLS_LAST';\n\nexport type TransactCommitmentsConnection = {\n  edges: Array<TransactCommitmentEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type TransactCommitmentEdge = {\n  node: TransactCommitment;\n  cursor: Scalars['String'];\n};\n\nexport type Unshield = {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  to: Scalars['Bytes'];\n  token: Token;\n  amount: Scalars['BigInt'];\n  fee: Scalars['BigInt'];\n  eventLogIndex: Scalars['BigInt'];\n};\n\nexport type UnshieldWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  to_isNull?: InputMaybe<Scalars['Boolean']>;\n  to_eq?: InputMaybe<Scalars['Bytes']>;\n  to_not_eq?: InputMaybe<Scalars['Bytes']>;\n  token_isNull?: InputMaybe<Scalars['Boolean']>;\n  token?: InputMaybe<TokenWhereInput>;\n  amount_isNull?: InputMaybe<Scalars['Boolean']>;\n  amount_eq?: InputMaybe<Scalars['BigInt']>;\n  amount_not_eq?: InputMaybe<Scalars['BigInt']>;\n  amount_gt?: InputMaybe<Scalars['BigInt']>;\n  amount_gte?: InputMaybe<Scalars['BigInt']>;\n  amount_lt?: InputMaybe<Scalars['BigInt']>;\n  amount_lte?: InputMaybe<Scalars['BigInt']>;\n  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  fee_isNull?: InputMaybe<Scalars['Boolean']>;\n  fee_eq?: InputMaybe<Scalars['BigInt']>;\n  fee_not_eq?: InputMaybe<Scalars['BigInt']>;\n  fee_gt?: InputMaybe<Scalars['BigInt']>;\n  fee_gte?: InputMaybe<Scalars['BigInt']>;\n  fee_lt?: InputMaybe<Scalars['BigInt']>;\n  fee_lte?: InputMaybe<Scalars['BigInt']>;\n  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  eventLogIndex_isNull?: InputMaybe<Scalars['Boolean']>;\n  eventLogIndex_eq?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_not_eq?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_gt?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_gte?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_lt?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_lte?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  eventLogIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  AND?: InputMaybe<Array<UnshieldWhereInput>>;\n  OR?: InputMaybe<Array<UnshieldWhereInput>>;\n};\n\nexport type UnshieldOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'to_ASC'\n  | 'to_DESC'\n  | 'to_ASC_NULLS_FIRST'\n  | 'to_DESC_NULLS_LAST'\n  | 'token_id_ASC'\n  | 'token_id_DESC'\n  | 'token_id_ASC_NULLS_FIRST'\n  | 'token_id_DESC_NULLS_LAST'\n  | 'token_tokenType_ASC'\n  | 'token_tokenType_DESC'\n  | 'token_tokenType_ASC_NULLS_FIRST'\n  | 'token_tokenType_DESC_NULLS_LAST'\n  | 'token_tokenAddress_ASC'\n  | 'token_tokenAddress_DESC'\n  | 'token_tokenAddress_ASC_NULLS_FIRST'\n  | 'token_tokenAddress_DESC_NULLS_LAST'\n  | 'token_tokenSubID_ASC'\n  | 'token_tokenSubID_DESC'\n  | 'token_tokenSubID_ASC_NULLS_FIRST'\n  | 'token_tokenSubID_DESC_NULLS_LAST'\n  | 'amount_ASC'\n  | 'amount_DESC'\n  | 'amount_ASC_NULLS_FIRST'\n  | 'amount_DESC_NULLS_LAST'\n  | 'fee_ASC'\n  | 'fee_DESC'\n  | 'fee_ASC_NULLS_FIRST'\n  | 'fee_DESC_NULLS_LAST'\n  | 'eventLogIndex_ASC'\n  | 'eventLogIndex_DESC'\n  | 'eventLogIndex_ASC_NULLS_FIRST'\n  | 'eventLogIndex_DESC_NULLS_LAST';\n\nexport type UnshieldsConnection = {\n  edges: Array<UnshieldEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type UnshieldEdge = {\n  node: Unshield;\n  cursor: Scalars['String'];\n};\n\nexport type Nullifier = {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  nullifier: Scalars['Bytes'];\n};\n\nexport type NullifierWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  nullifier_isNull?: InputMaybe<Scalars['Boolean']>;\n  nullifier_eq?: InputMaybe<Scalars['Bytes']>;\n  nullifier_not_eq?: InputMaybe<Scalars['Bytes']>;\n  AND?: InputMaybe<Array<NullifierWhereInput>>;\n  OR?: InputMaybe<Array<NullifierWhereInput>>;\n};\n\nexport type NullifierOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'nullifier_ASC'\n  | 'nullifier_DESC'\n  | 'nullifier_ASC_NULLS_FIRST'\n  | 'nullifier_DESC_NULLS_LAST';\n\nexport type NullifiersConnection = {\n  edges: Array<NullifierEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type NullifierEdge = {\n  node: Nullifier;\n  cursor: Scalars['String'];\n};\n\nexport type Transaction = TransactionInterface & {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  merkleRoot: Scalars['Bytes'];\n  nullifiers: Array<Scalars['Bytes']>;\n  commitments: Array<Scalars['Bytes']>;\n  boundParamsHash: Scalars['Bytes'];\n  hasUnshield: Scalars['Boolean'];\n  utxoTreeIn: Scalars['BigInt'];\n  utxoTreeOut: Scalars['BigInt'];\n  utxoBatchStartPositionOut: Scalars['BigInt'];\n  unshieldToken: Token;\n  unshieldToAddress: Scalars['Bytes'];\n  unshieldValue: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  verificationHash: Scalars['Bytes'];\n};\n\nexport type TransactionInterface = {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  merkleRoot: Scalars['Bytes'];\n  nullifiers: Array<Scalars['Bytes']>;\n  commitments: Array<Scalars['Bytes']>;\n  boundParamsHash: Scalars['Bytes'];\n  hasUnshield: Scalars['Boolean'];\n  utxoTreeIn: Scalars['BigInt'];\n  utxoTreeOut: Scalars['BigInt'];\n  utxoBatchStartPositionOut: Scalars['BigInt'];\n  unshieldToken: Token;\n  unshieldToAddress: Scalars['Bytes'];\n  unshieldValue: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  verificationHash: Scalars['Bytes'];\n};\n\nexport type TransactionWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  merkleRoot_isNull?: InputMaybe<Scalars['Boolean']>;\n  merkleRoot_eq?: InputMaybe<Scalars['Bytes']>;\n  merkleRoot_not_eq?: InputMaybe<Scalars['Bytes']>;\n  nullifiers_isNull?: InputMaybe<Scalars['Boolean']>;\n  nullifiers_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  nullifiers_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  nullifiers_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitments_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  boundParamsHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  boundParamsHash_eq?: InputMaybe<Scalars['Bytes']>;\n  boundParamsHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  hasUnshield_isNull?: InputMaybe<Scalars['Boolean']>;\n  hasUnshield_eq?: InputMaybe<Scalars['Boolean']>;\n  hasUnshield_not_eq?: InputMaybe<Scalars['Boolean']>;\n  utxoTreeIn_isNull?: InputMaybe<Scalars['Boolean']>;\n  utxoTreeIn_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_not_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_gt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_gte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_lt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_lte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoTreeIn_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoTreeOut_isNull?: InputMaybe<Scalars['Boolean']>;\n  utxoTreeOut_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_not_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_gt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_gte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_lt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_lte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoTreeOut_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoBatchStartPositionOut_isNull?: InputMaybe<Scalars['Boolean']>;\n  utxoBatchStartPositionOut_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_not_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_gt?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_gte?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_lt?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_lte?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoBatchStartPositionOut_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  unshieldToken_isNull?: InputMaybe<Scalars['Boolean']>;\n  unshieldToken?: InputMaybe<TokenWhereInput>;\n  unshieldToAddress_isNull?: InputMaybe<Scalars['Boolean']>;\n  unshieldToAddress_eq?: InputMaybe<Scalars['Bytes']>;\n  unshieldToAddress_not_eq?: InputMaybe<Scalars['Bytes']>;\n  unshieldValue_isNull?: InputMaybe<Scalars['Boolean']>;\n  unshieldValue_eq?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_not_eq?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_gt?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_gte?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_lt?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_lte?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  unshieldValue_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  verificationHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  verificationHash_eq?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  AND?: InputMaybe<Array<TransactionWhereInput>>;\n  OR?: InputMaybe<Array<TransactionWhereInput>>;\n};\n\nexport type TransactionOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'merkleRoot_ASC'\n  | 'merkleRoot_DESC'\n  | 'merkleRoot_ASC_NULLS_FIRST'\n  | 'merkleRoot_DESC_NULLS_LAST'\n  | 'boundParamsHash_ASC'\n  | 'boundParamsHash_DESC'\n  | 'boundParamsHash_ASC_NULLS_FIRST'\n  | 'boundParamsHash_DESC_NULLS_LAST'\n  | 'hasUnshield_ASC'\n  | 'hasUnshield_DESC'\n  | 'hasUnshield_ASC_NULLS_FIRST'\n  | 'hasUnshield_DESC_NULLS_LAST'\n  | 'utxoTreeIn_ASC'\n  | 'utxoTreeIn_DESC'\n  | 'utxoTreeIn_ASC_NULLS_FIRST'\n  | 'utxoTreeIn_DESC_NULLS_LAST'\n  | 'utxoTreeOut_ASC'\n  | 'utxoTreeOut_DESC'\n  | 'utxoTreeOut_ASC_NULLS_FIRST'\n  | 'utxoTreeOut_DESC_NULLS_LAST'\n  | 'utxoBatchStartPositionOut_ASC'\n  | 'utxoBatchStartPositionOut_DESC'\n  | 'utxoBatchStartPositionOut_ASC_NULLS_FIRST'\n  | 'utxoBatchStartPositionOut_DESC_NULLS_LAST'\n  | 'unshieldToken_id_ASC'\n  | 'unshieldToken_id_DESC'\n  | 'unshieldToken_id_ASC_NULLS_FIRST'\n  | 'unshieldToken_id_DESC_NULLS_LAST'\n  | 'unshieldToken_tokenType_ASC'\n  | 'unshieldToken_tokenType_DESC'\n  | 'unshieldToken_tokenType_ASC_NULLS_FIRST'\n  | 'unshieldToken_tokenType_DESC_NULLS_LAST'\n  | 'unshieldToken_tokenAddress_ASC'\n  | 'unshieldToken_tokenAddress_DESC'\n  | 'unshieldToken_tokenAddress_ASC_NULLS_FIRST'\n  | 'unshieldToken_tokenAddress_DESC_NULLS_LAST'\n  | 'unshieldToken_tokenSubID_ASC'\n  | 'unshieldToken_tokenSubID_DESC'\n  | 'unshieldToken_tokenSubID_ASC_NULLS_FIRST'\n  | 'unshieldToken_tokenSubID_DESC_NULLS_LAST'\n  | 'unshieldToAddress_ASC'\n  | 'unshieldToAddress_DESC'\n  | 'unshieldToAddress_ASC_NULLS_FIRST'\n  | 'unshieldToAddress_DESC_NULLS_LAST'\n  | 'unshieldValue_ASC'\n  | 'unshieldValue_DESC'\n  | 'unshieldValue_ASC_NULLS_FIRST'\n  | 'unshieldValue_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'verificationHash_ASC'\n  | 'verificationHash_DESC'\n  | 'verificationHash_ASC_NULLS_FIRST'\n  | 'verificationHash_DESC_NULLS_LAST';\n\nexport type TransactionsConnection = {\n  edges: Array<TransactionEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type TransactionEdge = {\n  node: Transaction;\n  cursor: Scalars['String'];\n};\n\nexport type VerificationHash = {\n  id: Scalars['String'];\n  verificationHash: Scalars['Bytes'];\n};\n\nexport type VerificationHashWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  verificationHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  verificationHash_eq?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  AND?: InputMaybe<Array<VerificationHashWhereInput>>;\n  OR?: InputMaybe<Array<VerificationHashWhereInput>>;\n};\n\nexport type VerificationHashOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'verificationHash_ASC'\n  | 'verificationHash_DESC'\n  | 'verificationHash_ASC_NULLS_FIRST'\n  | 'verificationHash_DESC_NULLS_LAST';\n\nexport type VerificationHashesConnection = {\n  edges: Array<VerificationHashEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type VerificationHashEdge = {\n  node: VerificationHash;\n  cursor: Scalars['String'];\n};\n\nexport type CommitmentBatchEventNew = {\n  id: Scalars['String'];\n  treeNumber: Scalars['BigInt'];\n  batchStartTreePosition: Scalars['BigInt'];\n};\n\nexport type CommitmentBatchEventNewWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  AND?: InputMaybe<Array<CommitmentBatchEventNewWhereInput>>;\n  OR?: InputMaybe<Array<CommitmentBatchEventNewWhereInput>>;\n};\n\nexport type CommitmentBatchEventNewOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST';\n\nexport type CommitmentBatchEventNewsConnection = {\n  edges: Array<CommitmentBatchEventNewEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CommitmentBatchEventNewEdge = {\n  node: CommitmentBatchEventNew;\n  cursor: Scalars['String'];\n};\n\nexport type SquidStatus = {\n  /** The height of the processed part of the chain */\n  height?: Maybe<Scalars['Int']>;\n};\n\nexport type WithIndex<TObject> = TObject & Record<string, any>;\nexport type ResolversObject<TObject> = WithIndex<TObject>;\n\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\n\n\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\n\nexport type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {\n  fragment: string;\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\n\nexport type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {\n  selectionSet: string | ((fieldNode: FieldNode) => SelectionSetNode);\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\nexport type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n  | ResolverFn<TResult, TParent, TContext, TArgs>\n  | ResolverWithResolve<TResult, TParent, TContext, TArgs>\n  | StitchingResolver<TResult, TParent, TContext, TArgs>;\n\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\n\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\n\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\n  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\n  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\n}\n\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\n  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\n  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\n}\n\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\n  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\n  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\n\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\n  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\n  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\n\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\n  parent: TParent,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\n\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\n\nexport type NextResolverFn<T> = () => Promise<T>;\n\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\n  next: NextResolverFn<TResult>,\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n\n/** Mapping between all available schema types and the resolvers types */\nexport type ResolversTypes = ResolversObject<{\n  Query: ResolverTypeWrapper<{}>;\n  Int: ResolverTypeWrapper<Scalars['Int']>;\n  String: ResolverTypeWrapper<Scalars['String']>;\n  Token: ResolverTypeWrapper<Token>;\n  TokenType: TokenType;\n  Bytes: ResolverTypeWrapper<Scalars['Bytes']>;\n  TokenWhereInput: TokenWhereInput;\n  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n  TokenOrderByInput: TokenOrderByInput;\n  WhereIdInput: WhereIdInput;\n  TokensConnection: ResolverTypeWrapper<TokensConnection>;\n  TokenEdge: ResolverTypeWrapper<TokenEdge>;\n  PageInfo: ResolverTypeWrapper<PageInfo>;\n  CommitmentPreimage: ResolverTypeWrapper<CommitmentPreimage>;\n  BigInt: ResolverTypeWrapper<Scalars['BigInt']>;\n  CommitmentPreimageWhereInput: CommitmentPreimageWhereInput;\n  CommitmentPreimageOrderByInput: CommitmentPreimageOrderByInput;\n  CommitmentPreimagesConnection: ResolverTypeWrapper<CommitmentPreimagesConnection>;\n  CommitmentPreimageEdge: ResolverTypeWrapper<CommitmentPreimageEdge>;\n  Ciphertext: ResolverTypeWrapper<Ciphertext>;\n  CiphertextWhereInput: CiphertextWhereInput;\n  CiphertextOrderByInput: CiphertextOrderByInput;\n  CiphertextsConnection: ResolverTypeWrapper<CiphertextsConnection>;\n  CiphertextEdge: ResolverTypeWrapper<CiphertextEdge>;\n  LegacyCommitmentCiphertext: ResolverTypeWrapper<LegacyCommitmentCiphertext>;\n  LegacyCommitmentCiphertextWhereInput: LegacyCommitmentCiphertextWhereInput;\n  LegacyCommitmentCiphertextOrderByInput: LegacyCommitmentCiphertextOrderByInput;\n  LegacyCommitmentCiphertextsConnection: ResolverTypeWrapper<LegacyCommitmentCiphertextsConnection>;\n  LegacyCommitmentCiphertextEdge: ResolverTypeWrapper<LegacyCommitmentCiphertextEdge>;\n  CommitmentCiphertext: ResolverTypeWrapper<CommitmentCiphertext>;\n  CommitmentCiphertextWhereInput: CommitmentCiphertextWhereInput;\n  CommitmentCiphertextOrderByInput: CommitmentCiphertextOrderByInput;\n  CommitmentCiphertextsConnection: ResolverTypeWrapper<CommitmentCiphertextsConnection>;\n  CommitmentCiphertextEdge: ResolverTypeWrapper<CommitmentCiphertextEdge>;\n  LegacyGeneratedCommitment: ResolverTypeWrapper<LegacyGeneratedCommitment>;\n  Commitment: ResolversTypes['LegacyGeneratedCommitment'] | ResolversTypes['LegacyEncryptedCommitment'] | ResolversTypes['ShieldCommitment'] | ResolversTypes['TransactCommitment'];\n  CommitmentType: CommitmentType;\n  LegacyGeneratedCommitmentWhereInput: LegacyGeneratedCommitmentWhereInput;\n  LegacyGeneratedCommitmentOrderByInput: LegacyGeneratedCommitmentOrderByInput;\n  LegacyGeneratedCommitmentsConnection: ResolverTypeWrapper<LegacyGeneratedCommitmentsConnection>;\n  LegacyGeneratedCommitmentEdge: ResolverTypeWrapper<LegacyGeneratedCommitmentEdge>;\n  CommitmentWhereInput: CommitmentWhereInput;\n  CommitmentOrderByInput: CommitmentOrderByInput;\n  CommitmentsConnection: ResolverTypeWrapper<CommitmentsConnection>;\n  CommitmentEdge: ResolverTypeWrapper<CommitmentEdge>;\n  LegacyEncryptedCommitment: ResolverTypeWrapper<LegacyEncryptedCommitment>;\n  LegacyEncryptedCommitmentWhereInput: LegacyEncryptedCommitmentWhereInput;\n  LegacyEncryptedCommitmentOrderByInput: LegacyEncryptedCommitmentOrderByInput;\n  LegacyEncryptedCommitmentsConnection: ResolverTypeWrapper<LegacyEncryptedCommitmentsConnection>;\n  LegacyEncryptedCommitmentEdge: ResolverTypeWrapper<LegacyEncryptedCommitmentEdge>;\n  ShieldCommitment: ResolverTypeWrapper<ShieldCommitment>;\n  ShieldCommitmentWhereInput: ShieldCommitmentWhereInput;\n  ShieldCommitmentOrderByInput: ShieldCommitmentOrderByInput;\n  ShieldCommitmentsConnection: ResolverTypeWrapper<ShieldCommitmentsConnection>;\n  ShieldCommitmentEdge: ResolverTypeWrapper<ShieldCommitmentEdge>;\n  TransactCommitment: ResolverTypeWrapper<TransactCommitment>;\n  TransactCommitmentWhereInput: TransactCommitmentWhereInput;\n  TransactCommitmentOrderByInput: TransactCommitmentOrderByInput;\n  TransactCommitmentsConnection: ResolverTypeWrapper<TransactCommitmentsConnection>;\n  TransactCommitmentEdge: ResolverTypeWrapper<TransactCommitmentEdge>;\n  Unshield: ResolverTypeWrapper<Unshield>;\n  UnshieldWhereInput: UnshieldWhereInput;\n  UnshieldOrderByInput: UnshieldOrderByInput;\n  UnshieldsConnection: ResolverTypeWrapper<UnshieldsConnection>;\n  UnshieldEdge: ResolverTypeWrapper<UnshieldEdge>;\n  Nullifier: ResolverTypeWrapper<Nullifier>;\n  NullifierWhereInput: NullifierWhereInput;\n  NullifierOrderByInput: NullifierOrderByInput;\n  NullifiersConnection: ResolverTypeWrapper<NullifiersConnection>;\n  NullifierEdge: ResolverTypeWrapper<NullifierEdge>;\n  Transaction: ResolverTypeWrapper<Transaction>;\n  TransactionInterface: ResolversTypes['Transaction'];\n  TransactionWhereInput: TransactionWhereInput;\n  TransactionOrderByInput: TransactionOrderByInput;\n  TransactionsConnection: ResolverTypeWrapper<TransactionsConnection>;\n  TransactionEdge: ResolverTypeWrapper<TransactionEdge>;\n  VerificationHash: ResolverTypeWrapper<VerificationHash>;\n  VerificationHashWhereInput: VerificationHashWhereInput;\n  VerificationHashOrderByInput: VerificationHashOrderByInput;\n  VerificationHashesConnection: ResolverTypeWrapper<VerificationHashesConnection>;\n  VerificationHashEdge: ResolverTypeWrapper<VerificationHashEdge>;\n  CommitmentBatchEventNew: ResolverTypeWrapper<CommitmentBatchEventNew>;\n  CommitmentBatchEventNewWhereInput: CommitmentBatchEventNewWhereInput;\n  CommitmentBatchEventNewOrderByInput: CommitmentBatchEventNewOrderByInput;\n  CommitmentBatchEventNewsConnection: ResolverTypeWrapper<CommitmentBatchEventNewsConnection>;\n  CommitmentBatchEventNewEdge: ResolverTypeWrapper<CommitmentBatchEventNewEdge>;\n  SquidStatus: ResolverTypeWrapper<SquidStatus>;\n}>;\n\n/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = ResolversObject<{\n  Query: {};\n  Int: Scalars['Int'];\n  String: Scalars['String'];\n  Token: Token;\n  Bytes: Scalars['Bytes'];\n  TokenWhereInput: TokenWhereInput;\n  Boolean: Scalars['Boolean'];\n  WhereIdInput: WhereIdInput;\n  TokensConnection: TokensConnection;\n  TokenEdge: TokenEdge;\n  PageInfo: PageInfo;\n  CommitmentPreimage: CommitmentPreimage;\n  BigInt: Scalars['BigInt'];\n  CommitmentPreimageWhereInput: CommitmentPreimageWhereInput;\n  CommitmentPreimagesConnection: CommitmentPreimagesConnection;\n  CommitmentPreimageEdge: CommitmentPreimageEdge;\n  Ciphertext: Ciphertext;\n  CiphertextWhereInput: CiphertextWhereInput;\n  CiphertextsConnection: CiphertextsConnection;\n  CiphertextEdge: CiphertextEdge;\n  LegacyCommitmentCiphertext: LegacyCommitmentCiphertext;\n  LegacyCommitmentCiphertextWhereInput: LegacyCommitmentCiphertextWhereInput;\n  LegacyCommitmentCiphertextsConnection: LegacyCommitmentCiphertextsConnection;\n  LegacyCommitmentCiphertextEdge: LegacyCommitmentCiphertextEdge;\n  CommitmentCiphertext: CommitmentCiphertext;\n  CommitmentCiphertextWhereInput: CommitmentCiphertextWhereInput;\n  CommitmentCiphertextsConnection: CommitmentCiphertextsConnection;\n  CommitmentCiphertextEdge: CommitmentCiphertextEdge;\n  LegacyGeneratedCommitment: LegacyGeneratedCommitment;\n  Commitment: ResolversParentTypes['LegacyGeneratedCommitment'] | ResolversParentTypes['LegacyEncryptedCommitment'] | ResolversParentTypes['ShieldCommitment'] | ResolversParentTypes['TransactCommitment'];\n  LegacyGeneratedCommitmentWhereInput: LegacyGeneratedCommitmentWhereInput;\n  LegacyGeneratedCommitmentsConnection: LegacyGeneratedCommitmentsConnection;\n  LegacyGeneratedCommitmentEdge: LegacyGeneratedCommitmentEdge;\n  CommitmentWhereInput: CommitmentWhereInput;\n  CommitmentsConnection: CommitmentsConnection;\n  CommitmentEdge: CommitmentEdge;\n  LegacyEncryptedCommitment: LegacyEncryptedCommitment;\n  LegacyEncryptedCommitmentWhereInput: LegacyEncryptedCommitmentWhereInput;\n  LegacyEncryptedCommitmentsConnection: LegacyEncryptedCommitmentsConnection;\n  LegacyEncryptedCommitmentEdge: LegacyEncryptedCommitmentEdge;\n  ShieldCommitment: ShieldCommitment;\n  ShieldCommitmentWhereInput: ShieldCommitmentWhereInput;\n  ShieldCommitmentsConnection: ShieldCommitmentsConnection;\n  ShieldCommitmentEdge: ShieldCommitmentEdge;\n  TransactCommitment: TransactCommitment;\n  TransactCommitmentWhereInput: TransactCommitmentWhereInput;\n  TransactCommitmentsConnection: TransactCommitmentsConnection;\n  TransactCommitmentEdge: TransactCommitmentEdge;\n  Unshield: Unshield;\n  UnshieldWhereInput: UnshieldWhereInput;\n  UnshieldsConnection: UnshieldsConnection;\n  UnshieldEdge: UnshieldEdge;\n  Nullifier: Nullifier;\n  NullifierWhereInput: NullifierWhereInput;\n  NullifiersConnection: NullifiersConnection;\n  NullifierEdge: NullifierEdge;\n  Transaction: Transaction;\n  TransactionInterface: ResolversParentTypes['Transaction'];\n  TransactionWhereInput: TransactionWhereInput;\n  TransactionsConnection: TransactionsConnection;\n  TransactionEdge: TransactionEdge;\n  VerificationHash: VerificationHash;\n  VerificationHashWhereInput: VerificationHashWhereInput;\n  VerificationHashesConnection: VerificationHashesConnection;\n  VerificationHashEdge: VerificationHashEdge;\n  CommitmentBatchEventNew: CommitmentBatchEventNew;\n  CommitmentBatchEventNewWhereInput: CommitmentBatchEventNewWhereInput;\n  CommitmentBatchEventNewsConnection: CommitmentBatchEventNewsConnection;\n  CommitmentBatchEventNewEdge: CommitmentBatchEventNewEdge;\n  SquidStatus: SquidStatus;\n}>;\n\nexport type QueryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{\n  tokens?: Resolver<Array<ResolversTypes['Token']>, ParentType, ContextType, Partial<QuerytokensArgs>>;\n  tokenById?: Resolver<Maybe<ResolversTypes['Token']>, ParentType, ContextType, RequireFields<QuerytokenByIdArgs, 'id'>>;\n  tokenByUniqueInput?: Resolver<Maybe<ResolversTypes['Token']>, ParentType, ContextType, RequireFields<QuerytokenByUniqueInputArgs, 'where'>>;\n  tokensConnection?: Resolver<ResolversTypes['TokensConnection'], ParentType, ContextType, RequireFields<QuerytokensConnectionArgs, 'orderBy'>>;\n  commitmentPreimages?: Resolver<Array<ResolversTypes['CommitmentPreimage']>, ParentType, ContextType, Partial<QuerycommitmentPreimagesArgs>>;\n  commitmentPreimageById?: Resolver<Maybe<ResolversTypes['CommitmentPreimage']>, ParentType, ContextType, RequireFields<QuerycommitmentPreimageByIdArgs, 'id'>>;\n  commitmentPreimageByUniqueInput?: Resolver<Maybe<ResolversTypes['CommitmentPreimage']>, ParentType, ContextType, RequireFields<QuerycommitmentPreimageByUniqueInputArgs, 'where'>>;\n  commitmentPreimagesConnection?: Resolver<ResolversTypes['CommitmentPreimagesConnection'], ParentType, ContextType, RequireFields<QuerycommitmentPreimagesConnectionArgs, 'orderBy'>>;\n  ciphertexts?: Resolver<Array<ResolversTypes['Ciphertext']>, ParentType, ContextType, Partial<QueryciphertextsArgs>>;\n  ciphertextById?: Resolver<Maybe<ResolversTypes['Ciphertext']>, ParentType, ContextType, RequireFields<QueryciphertextByIdArgs, 'id'>>;\n  ciphertextByUniqueInput?: Resolver<Maybe<ResolversTypes['Ciphertext']>, ParentType, ContextType, RequireFields<QueryciphertextByUniqueInputArgs, 'where'>>;\n  ciphertextsConnection?: Resolver<ResolversTypes['CiphertextsConnection'], ParentType, ContextType, RequireFields<QueryciphertextsConnectionArgs, 'orderBy'>>;\n  legacyCommitmentCiphertexts?: Resolver<Array<ResolversTypes['LegacyCommitmentCiphertext']>, ParentType, ContextType, Partial<QuerylegacyCommitmentCiphertextsArgs>>;\n  legacyCommitmentCiphertextById?: Resolver<Maybe<ResolversTypes['LegacyCommitmentCiphertext']>, ParentType, ContextType, RequireFields<QuerylegacyCommitmentCiphertextByIdArgs, 'id'>>;\n  legacyCommitmentCiphertextByUniqueInput?: Resolver<Maybe<ResolversTypes['LegacyCommitmentCiphertext']>, ParentType, ContextType, RequireFields<QuerylegacyCommitmentCiphertextByUniqueInputArgs, 'where'>>;\n  legacyCommitmentCiphertextsConnection?: Resolver<ResolversTypes['LegacyCommitmentCiphertextsConnection'], ParentType, ContextType, RequireFields<QuerylegacyCommitmentCiphertextsConnectionArgs, 'orderBy'>>;\n  commitmentCiphertexts?: Resolver<Array<ResolversTypes['CommitmentCiphertext']>, ParentType, ContextType, Partial<QuerycommitmentCiphertextsArgs>>;\n  commitmentCiphertextById?: Resolver<Maybe<ResolversTypes['CommitmentCiphertext']>, ParentType, ContextType, RequireFields<QuerycommitmentCiphertextByIdArgs, 'id'>>;\n  commitmentCiphertextByUniqueInput?: Resolver<Maybe<ResolversTypes['CommitmentCiphertext']>, ParentType, ContextType, RequireFields<QuerycommitmentCiphertextByUniqueInputArgs, 'where'>>;\n  commitmentCiphertextsConnection?: Resolver<ResolversTypes['CommitmentCiphertextsConnection'], ParentType, ContextType, RequireFields<QuerycommitmentCiphertextsConnectionArgs, 'orderBy'>>;\n  legacyGeneratedCommitments?: Resolver<Array<ResolversTypes['LegacyGeneratedCommitment']>, ParentType, ContextType, Partial<QuerylegacyGeneratedCommitmentsArgs>>;\n  legacyGeneratedCommitmentById?: Resolver<Maybe<ResolversTypes['LegacyGeneratedCommitment']>, ParentType, ContextType, RequireFields<QuerylegacyGeneratedCommitmentByIdArgs, 'id'>>;\n  legacyGeneratedCommitmentByUniqueInput?: Resolver<Maybe<ResolversTypes['LegacyGeneratedCommitment']>, ParentType, ContextType, RequireFields<QuerylegacyGeneratedCommitmentByUniqueInputArgs, 'where'>>;\n  legacyGeneratedCommitmentsConnection?: Resolver<ResolversTypes['LegacyGeneratedCommitmentsConnection'], ParentType, ContextType, RequireFields<QuerylegacyGeneratedCommitmentsConnectionArgs, 'orderBy'>>;\n  commitments?: Resolver<Array<ResolversTypes['Commitment']>, ParentType, ContextType, Partial<QuerycommitmentsArgs>>;\n  commitmentsConnection?: Resolver<ResolversTypes['CommitmentsConnection'], ParentType, ContextType, RequireFields<QuerycommitmentsConnectionArgs, 'orderBy'>>;\n  legacyEncryptedCommitments?: Resolver<Array<ResolversTypes['LegacyEncryptedCommitment']>, ParentType, ContextType, Partial<QuerylegacyEncryptedCommitmentsArgs>>;\n  legacyEncryptedCommitmentById?: Resolver<Maybe<ResolversTypes['LegacyEncryptedCommitment']>, ParentType, ContextType, RequireFields<QuerylegacyEncryptedCommitmentByIdArgs, 'id'>>;\n  legacyEncryptedCommitmentByUniqueInput?: Resolver<Maybe<ResolversTypes['LegacyEncryptedCommitment']>, ParentType, ContextType, RequireFields<QuerylegacyEncryptedCommitmentByUniqueInputArgs, 'where'>>;\n  legacyEncryptedCommitmentsConnection?: Resolver<ResolversTypes['LegacyEncryptedCommitmentsConnection'], ParentType, ContextType, RequireFields<QuerylegacyEncryptedCommitmentsConnectionArgs, 'orderBy'>>;\n  shieldCommitments?: Resolver<Array<ResolversTypes['ShieldCommitment']>, ParentType, ContextType, Partial<QueryshieldCommitmentsArgs>>;\n  shieldCommitmentById?: Resolver<Maybe<ResolversTypes['ShieldCommitment']>, ParentType, ContextType, RequireFields<QueryshieldCommitmentByIdArgs, 'id'>>;\n  shieldCommitmentByUniqueInput?: Resolver<Maybe<ResolversTypes['ShieldCommitment']>, ParentType, ContextType, RequireFields<QueryshieldCommitmentByUniqueInputArgs, 'where'>>;\n  shieldCommitmentsConnection?: Resolver<ResolversTypes['ShieldCommitmentsConnection'], ParentType, ContextType, RequireFields<QueryshieldCommitmentsConnectionArgs, 'orderBy'>>;\n  transactCommitments?: Resolver<Array<ResolversTypes['TransactCommitment']>, ParentType, ContextType, Partial<QuerytransactCommitmentsArgs>>;\n  transactCommitmentById?: Resolver<Maybe<ResolversTypes['TransactCommitment']>, ParentType, ContextType, RequireFields<QuerytransactCommitmentByIdArgs, 'id'>>;\n  transactCommitmentByUniqueInput?: Resolver<Maybe<ResolversTypes['TransactCommitment']>, ParentType, ContextType, RequireFields<QuerytransactCommitmentByUniqueInputArgs, 'where'>>;\n  transactCommitmentsConnection?: Resolver<ResolversTypes['TransactCommitmentsConnection'], ParentType, ContextType, RequireFields<QuerytransactCommitmentsConnectionArgs, 'orderBy'>>;\n  unshields?: Resolver<Array<ResolversTypes['Unshield']>, ParentType, ContextType, Partial<QueryunshieldsArgs>>;\n  unshieldById?: Resolver<Maybe<ResolversTypes['Unshield']>, ParentType, ContextType, RequireFields<QueryunshieldByIdArgs, 'id'>>;\n  unshieldByUniqueInput?: Resolver<Maybe<ResolversTypes['Unshield']>, ParentType, ContextType, RequireFields<QueryunshieldByUniqueInputArgs, 'where'>>;\n  unshieldsConnection?: Resolver<ResolversTypes['UnshieldsConnection'], ParentType, ContextType, RequireFields<QueryunshieldsConnectionArgs, 'orderBy'>>;\n  nullifiers?: Resolver<Array<ResolversTypes['Nullifier']>, ParentType, ContextType, Partial<QuerynullifiersArgs>>;\n  nullifierById?: Resolver<Maybe<ResolversTypes['Nullifier']>, ParentType, ContextType, RequireFields<QuerynullifierByIdArgs, 'id'>>;\n  nullifierByUniqueInput?: Resolver<Maybe<ResolversTypes['Nullifier']>, ParentType, ContextType, RequireFields<QuerynullifierByUniqueInputArgs, 'where'>>;\n  nullifiersConnection?: Resolver<ResolversTypes['NullifiersConnection'], ParentType, ContextType, RequireFields<QuerynullifiersConnectionArgs, 'orderBy'>>;\n  transactions?: Resolver<Array<ResolversTypes['Transaction']>, ParentType, ContextType, Partial<QuerytransactionsArgs>>;\n  transactionById?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<QuerytransactionByIdArgs, 'id'>>;\n  transactionByUniqueInput?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<QuerytransactionByUniqueInputArgs, 'where'>>;\n  transactionsConnection?: Resolver<ResolversTypes['TransactionsConnection'], ParentType, ContextType, RequireFields<QuerytransactionsConnectionArgs, 'orderBy'>>;\n  verificationHashes?: Resolver<Array<ResolversTypes['VerificationHash']>, ParentType, ContextType, Partial<QueryverificationHashesArgs>>;\n  verificationHashById?: Resolver<Maybe<ResolversTypes['VerificationHash']>, ParentType, ContextType, RequireFields<QueryverificationHashByIdArgs, 'id'>>;\n  verificationHashByUniqueInput?: Resolver<Maybe<ResolversTypes['VerificationHash']>, ParentType, ContextType, RequireFields<QueryverificationHashByUniqueInputArgs, 'where'>>;\n  verificationHashesConnection?: Resolver<ResolversTypes['VerificationHashesConnection'], ParentType, ContextType, RequireFields<QueryverificationHashesConnectionArgs, 'orderBy'>>;\n  commitmentBatchEventNews?: Resolver<Array<ResolversTypes['CommitmentBatchEventNew']>, ParentType, ContextType, Partial<QuerycommitmentBatchEventNewsArgs>>;\n  commitmentBatchEventNewById?: Resolver<Maybe<ResolversTypes['CommitmentBatchEventNew']>, ParentType, ContextType, RequireFields<QuerycommitmentBatchEventNewByIdArgs, 'id'>>;\n  commitmentBatchEventNewByUniqueInput?: Resolver<Maybe<ResolversTypes['CommitmentBatchEventNew']>, ParentType, ContextType, RequireFields<QuerycommitmentBatchEventNewByUniqueInputArgs, 'where'>>;\n  commitmentBatchEventNewsConnection?: Resolver<ResolversTypes['CommitmentBatchEventNewsConnection'], ParentType, ContextType, RequireFields<QuerycommitmentBatchEventNewsConnectionArgs, 'orderBy'>>;\n  squidStatus?: Resolver<Maybe<ResolversTypes['SquidStatus']>, ParentType, ContextType>;\n}>;\n\nexport type TokenResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Token'] = ResolversParentTypes['Token']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  tokenType?: Resolver<ResolversTypes['TokenType'], ParentType, ContextType>;\n  tokenAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  tokenSubID?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport interface BytesScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Bytes'], any> {\n  name: 'Bytes';\n}\n\nexport type TokensConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TokensConnection'] = ResolversParentTypes['TokensConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['TokenEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TokenEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TokenEdge'] = ResolversParentTypes['TokenEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type PageInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = ResolversObject<{\n  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;\n  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;\n  startCursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  endCursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentPreimageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentPreimage'] = ResolversParentTypes['CommitmentPreimage']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  npk?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  token?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  value?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {\n  name: 'BigInt';\n}\n\nexport type CommitmentPreimagesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentPreimagesConnection'] = ResolversParentTypes['CommitmentPreimagesConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['CommitmentPreimageEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentPreimageEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentPreimageEdge'] = ResolversParentTypes['CommitmentPreimageEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['CommitmentPreimage'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CiphertextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Ciphertext'] = ResolversParentTypes['Ciphertext']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  iv?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  tag?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  data?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CiphertextsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CiphertextsConnection'] = ResolversParentTypes['CiphertextsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['CiphertextEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CiphertextEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CiphertextEdge'] = ResolversParentTypes['CiphertextEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Ciphertext'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyCommitmentCiphertextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyCommitmentCiphertext'] = ResolversParentTypes['LegacyCommitmentCiphertext']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  ciphertext?: Resolver<ResolversTypes['Ciphertext'], ParentType, ContextType>;\n  ephemeralKeys?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  memo?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyCommitmentCiphertextsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyCommitmentCiphertextsConnection'] = ResolversParentTypes['LegacyCommitmentCiphertextsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['LegacyCommitmentCiphertextEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyCommitmentCiphertextEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyCommitmentCiphertextEdge'] = ResolversParentTypes['LegacyCommitmentCiphertextEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['LegacyCommitmentCiphertext'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentCiphertextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentCiphertext'] = ResolversParentTypes['CommitmentCiphertext']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  ciphertext?: Resolver<ResolversTypes['Ciphertext'], ParentType, ContextType>;\n  blindedSenderViewingKey?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  blindedReceiverViewingKey?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  annotationData?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  memo?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentCiphertextsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentCiphertextsConnection'] = ResolversParentTypes['CommitmentCiphertextsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['CommitmentCiphertextEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentCiphertextEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentCiphertextEdge'] = ResolversParentTypes['CommitmentCiphertextEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['CommitmentCiphertext'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyGeneratedCommitmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyGeneratedCommitment'] = ResolversParentTypes['LegacyGeneratedCommitment']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  treePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<ResolversTypes['CommitmentType'], ParentType, ContextType>;\n  hash?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  preimage?: Resolver<ResolversTypes['CommitmentPreimage'], ParentType, ContextType>;\n  encryptedRandom?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Commitment'] = ResolversParentTypes['Commitment']> = ResolversObject<{\n  __resolveType: TypeResolveFn<'LegacyGeneratedCommitment' | 'LegacyEncryptedCommitment' | 'ShieldCommitment' | 'TransactCommitment', ParentType, ContextType>;\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  treePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<ResolversTypes['CommitmentType'], ParentType, ContextType>;\n  hash?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n}>;\n\nexport type LegacyGeneratedCommitmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyGeneratedCommitmentsConnection'] = ResolversParentTypes['LegacyGeneratedCommitmentsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['LegacyGeneratedCommitmentEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyGeneratedCommitmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyGeneratedCommitmentEdge'] = ResolversParentTypes['LegacyGeneratedCommitmentEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['LegacyGeneratedCommitment'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentsConnection'] = ResolversParentTypes['CommitmentsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['CommitmentEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentEdge'] = ResolversParentTypes['CommitmentEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Commitment'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyEncryptedCommitmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyEncryptedCommitment'] = ResolversParentTypes['LegacyEncryptedCommitment']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  treePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<ResolversTypes['CommitmentType'], ParentType, ContextType>;\n  hash?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  ciphertext?: Resolver<ResolversTypes['LegacyCommitmentCiphertext'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyEncryptedCommitmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyEncryptedCommitmentsConnection'] = ResolversParentTypes['LegacyEncryptedCommitmentsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['LegacyEncryptedCommitmentEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyEncryptedCommitmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyEncryptedCommitmentEdge'] = ResolversParentTypes['LegacyEncryptedCommitmentEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['LegacyEncryptedCommitment'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type ShieldCommitmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ShieldCommitment'] = ResolversParentTypes['ShieldCommitment']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  treePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<ResolversTypes['CommitmentType'], ParentType, ContextType>;\n  hash?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  preimage?: Resolver<ResolversTypes['CommitmentPreimage'], ParentType, ContextType>;\n  encryptedBundle?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  shieldKey?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  fee?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type ShieldCommitmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ShieldCommitmentsConnection'] = ResolversParentTypes['ShieldCommitmentsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['ShieldCommitmentEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type ShieldCommitmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ShieldCommitmentEdge'] = ResolversParentTypes['ShieldCommitmentEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['ShieldCommitment'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactCommitmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactCommitment'] = ResolversParentTypes['TransactCommitment']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  treePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<ResolversTypes['CommitmentType'], ParentType, ContextType>;\n  hash?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  ciphertext?: Resolver<ResolversTypes['CommitmentCiphertext'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactCommitmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactCommitmentsConnection'] = ResolversParentTypes['TransactCommitmentsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['TransactCommitmentEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactCommitmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactCommitmentEdge'] = ResolversParentTypes['TransactCommitmentEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['TransactCommitment'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type UnshieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Unshield'] = ResolversParentTypes['Unshield']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  to?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  token?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  amount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  fee?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  eventLogIndex?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type UnshieldsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnshieldsConnection'] = ResolversParentTypes['UnshieldsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['UnshieldEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type UnshieldEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnshieldEdge'] = ResolversParentTypes['UnshieldEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Unshield'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type NullifierResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Nullifier'] = ResolversParentTypes['Nullifier']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  nullifier?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type NullifiersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['NullifiersConnection'] = ResolversParentTypes['NullifiersConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['NullifierEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type NullifierEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['NullifierEdge'] = ResolversParentTypes['NullifierEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Nullifier'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Transaction'] = ResolversParentTypes['Transaction']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  merkleRoot?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  nullifiers?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  commitments?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  boundParamsHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  hasUnshield?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;\n  utxoTreeIn?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  utxoTreeOut?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  utxoBatchStartPositionOut?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  unshieldToken?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  unshieldToAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  unshieldValue?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  verificationHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactionInterfaceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactionInterface'] = ResolversParentTypes['TransactionInterface']> = ResolversObject<{\n  __resolveType: TypeResolveFn<'Transaction', ParentType, ContextType>;\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  merkleRoot?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  nullifiers?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  commitments?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  boundParamsHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  hasUnshield?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;\n  utxoTreeIn?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  utxoTreeOut?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  utxoBatchStartPositionOut?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  unshieldToken?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  unshieldToAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  unshieldValue?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  verificationHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n}>;\n\nexport type TransactionsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactionsConnection'] = ResolversParentTypes['TransactionsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['TransactionEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactionEdge'] = ResolversParentTypes['TransactionEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type VerificationHashResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VerificationHash'] = ResolversParentTypes['VerificationHash']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  verificationHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type VerificationHashesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VerificationHashesConnection'] = ResolversParentTypes['VerificationHashesConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['VerificationHashEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type VerificationHashEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VerificationHashEdge'] = ResolversParentTypes['VerificationHashEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['VerificationHash'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentBatchEventNewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentBatchEventNew'] = ResolversParentTypes['CommitmentBatchEventNew']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentBatchEventNewsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentBatchEventNewsConnection'] = ResolversParentTypes['CommitmentBatchEventNewsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['CommitmentBatchEventNewEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentBatchEventNewEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentBatchEventNewEdge'] = ResolversParentTypes['CommitmentBatchEventNewEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['CommitmentBatchEventNew'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type SquidStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SquidStatus'] = ResolversParentTypes['SquidStatus']> = ResolversObject<{\n  height?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type Resolvers<ContextType = MeshContext> = ResolversObject<{\n  Query?: QueryResolvers<ContextType>;\n  Token?: TokenResolvers<ContextType>;\n  Bytes?: GraphQLScalarType;\n  TokensConnection?: TokensConnectionResolvers<ContextType>;\n  TokenEdge?: TokenEdgeResolvers<ContextType>;\n  PageInfo?: PageInfoResolvers<ContextType>;\n  CommitmentPreimage?: CommitmentPreimageResolvers<ContextType>;\n  BigInt?: GraphQLScalarType;\n  CommitmentPreimagesConnection?: CommitmentPreimagesConnectionResolvers<ContextType>;\n  CommitmentPreimageEdge?: CommitmentPreimageEdgeResolvers<ContextType>;\n  Ciphertext?: CiphertextResolvers<ContextType>;\n  CiphertextsConnection?: CiphertextsConnectionResolvers<ContextType>;\n  CiphertextEdge?: CiphertextEdgeResolvers<ContextType>;\n  LegacyCommitmentCiphertext?: LegacyCommitmentCiphertextResolvers<ContextType>;\n  LegacyCommitmentCiphertextsConnection?: LegacyCommitmentCiphertextsConnectionResolvers<ContextType>;\n  LegacyCommitmentCiphertextEdge?: LegacyCommitmentCiphertextEdgeResolvers<ContextType>;\n  CommitmentCiphertext?: CommitmentCiphertextResolvers<ContextType>;\n  CommitmentCiphertextsConnection?: CommitmentCiphertextsConnectionResolvers<ContextType>;\n  CommitmentCiphertextEdge?: CommitmentCiphertextEdgeResolvers<ContextType>;\n  LegacyGeneratedCommitment?: LegacyGeneratedCommitmentResolvers<ContextType>;\n  Commitment?: CommitmentResolvers<ContextType>;\n  LegacyGeneratedCommitmentsConnection?: LegacyGeneratedCommitmentsConnectionResolvers<ContextType>;\n  LegacyGeneratedCommitmentEdge?: LegacyGeneratedCommitmentEdgeResolvers<ContextType>;\n  CommitmentsConnection?: CommitmentsConnectionResolvers<ContextType>;\n  CommitmentEdge?: CommitmentEdgeResolvers<ContextType>;\n  LegacyEncryptedCommitment?: LegacyEncryptedCommitmentResolvers<ContextType>;\n  LegacyEncryptedCommitmentsConnection?: LegacyEncryptedCommitmentsConnectionResolvers<ContextType>;\n  LegacyEncryptedCommitmentEdge?: LegacyEncryptedCommitmentEdgeResolvers<ContextType>;\n  ShieldCommitment?: ShieldCommitmentResolvers<ContextType>;\n  ShieldCommitmentsConnection?: ShieldCommitmentsConnectionResolvers<ContextType>;\n  ShieldCommitmentEdge?: ShieldCommitmentEdgeResolvers<ContextType>;\n  TransactCommitment?: TransactCommitmentResolvers<ContextType>;\n  TransactCommitmentsConnection?: TransactCommitmentsConnectionResolvers<ContextType>;\n  TransactCommitmentEdge?: TransactCommitmentEdgeResolvers<ContextType>;\n  Unshield?: UnshieldResolvers<ContextType>;\n  UnshieldsConnection?: UnshieldsConnectionResolvers<ContextType>;\n  UnshieldEdge?: UnshieldEdgeResolvers<ContextType>;\n  Nullifier?: NullifierResolvers<ContextType>;\n  NullifiersConnection?: NullifiersConnectionResolvers<ContextType>;\n  NullifierEdge?: NullifierEdgeResolvers<ContextType>;\n  Transaction?: TransactionResolvers<ContextType>;\n  TransactionInterface?: TransactionInterfaceResolvers<ContextType>;\n  TransactionsConnection?: TransactionsConnectionResolvers<ContextType>;\n  TransactionEdge?: TransactionEdgeResolvers<ContextType>;\n  VerificationHash?: VerificationHashResolvers<ContextType>;\n  VerificationHashesConnection?: VerificationHashesConnectionResolvers<ContextType>;\n  VerificationHashEdge?: VerificationHashEdgeResolvers<ContextType>;\n  CommitmentBatchEventNew?: CommitmentBatchEventNewResolvers<ContextType>;\n  CommitmentBatchEventNewsConnection?: CommitmentBatchEventNewsConnectionResolvers<ContextType>;\n  CommitmentBatchEventNewEdge?: CommitmentBatchEventNewEdgeResolvers<ContextType>;\n  SquidStatus?: SquidStatusResolvers<ContextType>;\n}>;\n\n\nexport type MeshContext = ArbitrumOneTypes.Context & SepoliaTypes.Context & BscTypes.Context & EthereumTypes.Context & MaticTypes.Context & BaseMeshContext;\n\n\nconst baseDir = pathModule.join(typeof __dirname === 'string' ? __dirname : '/', '..');\n\nconst importFn: ImportFn = <T>(moduleId: string) => {\n  const relativeModuleId = (pathModule.isAbsolute(moduleId) ? pathModule.relative(baseDir, moduleId) : moduleId).split('\\\\').join('/').replace(baseDir + '/', '');\n  switch(relativeModuleId) {\n    case \".graphclient/sources/arbitrum-one/introspectionSchema\":\n      return import(\"./.graphclient/sources/arbitrum-one/introspectionSchema\") as T;\n    \n    case \".graphclient/sources/sepolia/introspectionSchema\":\n      return import(\"./.graphclient/sources/sepolia/introspectionSchema\") as T;\n    \n    case \".graphclient/sources/bsc/introspectionSchema\":\n      return import(\"./.graphclient/sources/bsc/introspectionSchema\") as T;\n    \n    case \".graphclient/sources/ethereum/introspectionSchema\":\n      return import(\"./.graphclient/sources/ethereum/introspectionSchema\") as T;\n    \n    case \".graphclient/sources/matic/introspectionSchema\":\n      return import(\"./.graphclient/sources/matic/introspectionSchema\") as T;\n    \n    default:\n      return Promise.reject(new Error(`Cannot find module '${relativeModuleId}'.`));\n  }\n};\n\nconst rootStore = new MeshStore('.graphclient', new FsStoreStorageAdapter({\n  cwd: baseDir,\n  importFn,\n  fileType: \"ts\",\n}), {\n  readonly: true,\n  validate: false\n});\n\nexport const rawServeConfig: YamlConfig.Config['serve'] = undefined as any\nexport async function getMeshOptions(): Promise<GetMeshOptions> {\nconst pubsub = new PubSub();\nconst sourcesStore = rootStore.child('sources');\nconst logger = new DefaultLogger(\"GraphClient\");\nconst cache = new (MeshCache as any)({\n      ...({} as any),\n      importFn,\n      store: rootStore.child('cache'),\n      pubsub,\n      logger,\n    } as any)\n\nconst sources: MeshResolvedSource[] = [];\nconst transforms: MeshTransform[] = [];\nconst additionalEnvelopPlugins: MeshPlugin<any>[] = [];\nconst ethereumTransforms = [];\nconst bscTransforms = [];\nconst maticTransforms = [];\nconst arbitrumOneTransforms = [];\nconst sepoliaTransforms = [];\nconst additionalTypeDefs = [] as any[];\nconst ethereumHandler = new GraphqlHandler({\n              name: \"ethereum\",\n              config: {\"endpoint\":\"https://rail-squid.squids.live/squid-railgun-ethereum-v2/graphql\"},\n              baseDir,\n              cache,\n              pubsub,\n              store: sourcesStore.child(\"ethereum\"),\n              logger: logger.child(\"ethereum\"),\n              importFn,\n            });\nconst bscHandler = new GraphqlHandler({\n              name: \"bsc\",\n              config: {\"endpoint\":\"https://rail-squid.squids.live/squid-railgun-bsc-v2/graphql\"},\n              baseDir,\n              cache,\n              pubsub,\n              store: sourcesStore.child(\"bsc\"),\n              logger: logger.child(\"bsc\"),\n              importFn,\n            });\nconst maticHandler = new GraphqlHandler({\n              name: \"matic\",\n              config: {\"endpoint\":\"https://rail-squid.squids.live/squid-railgun-polygon-v2/graphql\"},\n              baseDir,\n              cache,\n              pubsub,\n              store: sourcesStore.child(\"matic\"),\n              logger: logger.child(\"matic\"),\n              importFn,\n            });\nconst arbitrumOneHandler = new GraphqlHandler({\n              name: \"arbitrum-one\",\n              config: {\"endpoint\":\"https://rail-squid.squids.live/squid-railgun-arbitrum-v2/graphql\"},\n              baseDir,\n              cache,\n              pubsub,\n              store: sourcesStore.child(\"arbitrum-one\"),\n              logger: logger.child(\"arbitrum-one\"),\n              importFn,\n            });\nconst sepoliaHandler = new GraphqlHandler({\n              name: \"sepolia\",\n              config: {\"endpoint\":\"https://rail-squid.squids.live/squid-railgun-eth-sepolia-v2/graphql\"},\n              baseDir,\n              cache,\n              pubsub,\n              store: sourcesStore.child(\"sepolia\"),\n              logger: logger.child(\"sepolia\"),\n              importFn,\n            });\nsources[0] = {\n          name: 'ethereum',\n          handler: ethereumHandler,\n          transforms: ethereumTransforms\n        }\nsources[1] = {\n          name: 'bsc',\n          handler: bscHandler,\n          transforms: bscTransforms\n        }\nsources[2] = {\n          name: 'matic',\n          handler: maticHandler,\n          transforms: maticTransforms\n        }\nsources[3] = {\n          name: 'arbitrum-one',\n          handler: arbitrumOneHandler,\n          transforms: arbitrumOneTransforms\n        }\nsources[4] = {\n          name: 'sepolia',\n          handler: sepoliaHandler,\n          transforms: sepoliaTransforms\n        }\nconst additionalResolvers = [] as any[]\nconst merger = new(StitchingMerger as any)({\n        cache,\n        pubsub,\n        logger: logger.child('stitchingMerger'),\n        store: rootStore.child('stitchingMerger')\n      })\n\n  return {\n    sources,\n    transforms,\n    additionalTypeDefs,\n    additionalResolvers,\n    cache,\n    pubsub,\n    merger,\n    logger,\n    additionalEnvelopPlugins,\n    get documents() {\n      return [\n      {\n        document: NullifiersDocument,\n        get rawSDL() {\n          return printWithCache(NullifiersDocument);\n        },\n        location: 'NullifiersDocument.graphql'\n      },{\n        document: UnshieldsDocument,\n        get rawSDL() {\n          return printWithCache(UnshieldsDocument);\n        },\n        location: 'UnshieldsDocument.graphql'\n      },{\n        document: CommitmentsDocument,\n        get rawSDL() {\n          return printWithCache(CommitmentsDocument);\n        },\n        location: 'CommitmentsDocument.graphql'\n      }\n    ];\n    },\n    fetchFn,\n  };\n}\n\nexport function createBuiltMeshHTTPHandler<TServerContext = {}>(): MeshHTTPHandler<TServerContext> {\n  return createMeshHTTPHandler<TServerContext>({\n    baseDir,\n    getBuiltMesh: getBuiltGraphClient,\n    rawServeConfig: undefined,\n  })\n}\n\n\nlet meshInstance$: Promise<MeshInstance> | undefined;\n\nexport function getBuiltGraphClient(): Promise<MeshInstance> {\n  if (meshInstance$ == null) {\n    meshInstance$ = getMeshOptions().then(meshOptions => getMesh(meshOptions)).then(mesh => {\n      const id = mesh.pubsub.subscribe('destroy', () => {\n        meshInstance$ = undefined;\n        mesh.pubsub.unsubscribe(id);\n      });\n      return mesh;\n    });\n  }\n  return meshInstance$;\n}\n\nexport const execute: ExecuteMeshFn = (...args) => getBuiltGraphClient().then(({ execute }) => execute(...args));\n\nexport const subscribe: SubscribeMeshFn = (...args) => getBuiltGraphClient().then(({ subscribe }) => subscribe(...args));\nexport function getBuiltGraphSDK<TGlobalContext = any, TOperationContext = any>(globalContext?: TGlobalContext) {\n  const sdkRequester$ = getBuiltGraphClient().then(({ sdkRequesterFactory }) => sdkRequesterFactory(globalContext));\n  return getSdk<TOperationContext, TGlobalContext>((...args) => sdkRequester$.then(sdkRequester => sdkRequester(...args)));\n}\nexport type NullifiersQueryVariables = Exact<{\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n}>;\n\n\nexport type NullifiersQuery = { nullifiers: Array<Pick<Nullifier, 'id' | 'blockNumber' | 'nullifier' | 'transactionHash' | 'blockTimestamp' | 'treeNumber'>> };\n\nexport type UnshieldsQueryVariables = Exact<{\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n}>;\n\n\nexport type UnshieldsQuery = { unshields: Array<(\n    Pick<Unshield, 'id' | 'blockNumber' | 'to' | 'transactionHash' | 'fee' | 'blockTimestamp' | 'amount' | 'eventLogIndex'>\n    & { token: Pick<Token, 'id' | 'tokenType' | 'tokenSubID' | 'tokenAddress'> }\n  )> };\n\nexport type CommitmentsQueryVariables = Exact<{\n  blockNumber?: InputMaybe<Scalars['BigInt']>;\n}>;\n\n\nexport type CommitmentsQuery = { commitments: Array<(\n    Pick<LegacyGeneratedCommitment, 'id' | 'treeNumber' | 'batchStartTreePosition' | 'treePosition' | 'blockNumber' | 'transactionHash' | 'blockTimestamp' | 'commitmentType' | 'hash' | 'encryptedRandom'>\n    & { preimage: (\n      Pick<CommitmentPreimage, 'id' | 'npk' | 'value'>\n      & { token: Pick<Token, 'id' | 'tokenType' | 'tokenSubID' | 'tokenAddress'> }\n    ) }\n  ) | (\n    Pick<LegacyEncryptedCommitment, 'id' | 'blockNumber' | 'blockTimestamp' | 'transactionHash' | 'treeNumber' | 'batchStartTreePosition' | 'treePosition' | 'commitmentType' | 'hash'>\n    & { legacyCiphertext: (\n      Pick<LegacyCommitmentCiphertext, 'id' | 'ephemeralKeys' | 'memo'>\n      & { ciphertext: Pick<Ciphertext, 'id' | 'iv' | 'tag' | 'data'> }\n    ) }\n  ) | (\n    Pick<ShieldCommitment, 'id' | 'blockNumber' | 'blockTimestamp' | 'transactionHash' | 'treeNumber' | 'batchStartTreePosition' | 'treePosition' | 'commitmentType' | 'hash' | 'shieldKey' | 'fee' | 'encryptedBundle'>\n    & { preimage: (\n      Pick<CommitmentPreimage, 'id' | 'npk' | 'value'>\n      & { token: Pick<Token, 'id' | 'tokenType' | 'tokenSubID' | 'tokenAddress'> }\n    ) }\n  ) | (\n    Pick<TransactCommitment, 'id' | 'blockNumber' | 'blockTimestamp' | 'transactionHash' | 'treeNumber' | 'batchStartTreePosition' | 'treePosition' | 'commitmentType' | 'hash'>\n    & { ciphertext: (\n      Pick<CommitmentCiphertext, 'id' | 'blindedSenderViewingKey' | 'blindedReceiverViewingKey' | 'annotationData' | 'memo'>\n      & { ciphertext: Pick<Ciphertext, 'id' | 'iv' | 'tag' | 'data'> }\n    ) }\n  )> };\n\n\nexport const NullifiersDocument = gql`\n    query Nullifiers($blockNumber: BigInt = 0) {\n  nullifiers(\n    orderBy: [blockNumber_ASC, nullifier_DESC]\n    where: {blockNumber_gte: $blockNumber}\n    limit: 10000\n  ) {\n    id\n    blockNumber\n    nullifier\n    transactionHash\n    blockTimestamp\n    treeNumber\n  }\n}\n    ` as unknown as DocumentNode<NullifiersQuery, NullifiersQueryVariables>;\nexport const UnshieldsDocument = gql`\n    query Unshields($blockNumber: BigInt = 0) {\n  unshields(\n    orderBy: [blockNumber_ASC, eventLogIndex_ASC]\n    where: {blockNumber_gte: $blockNumber}\n    limit: 10000\n  ) {\n    id\n    blockNumber\n    to\n    transactionHash\n    fee\n    blockTimestamp\n    amount\n    eventLogIndex\n    token {\n      id\n      tokenType\n      tokenSubID\n      tokenAddress\n    }\n  }\n}\n    ` as unknown as DocumentNode<UnshieldsQuery, UnshieldsQueryVariables>;\nexport const CommitmentsDocument = gql`\n    query Commitments($blockNumber: BigInt = 0) {\n  commitments(\n    orderBy: [blockNumber_ASC, treePosition_ASC]\n    where: {blockNumber_gte: $blockNumber}\n    limit: 10000\n  ) {\n    id\n    treeNumber\n    batchStartTreePosition\n    treePosition\n    blockNumber\n    transactionHash\n    blockTimestamp\n    commitmentType\n    hash\n    ... on LegacyGeneratedCommitment {\n      id\n      treeNumber\n      batchStartTreePosition\n      treePosition\n      blockNumber\n      transactionHash\n      blockTimestamp\n      commitmentType\n      hash\n      encryptedRandom\n      preimage {\n        id\n        npk\n        value\n        token {\n          id\n          tokenType\n          tokenSubID\n          tokenAddress\n        }\n      }\n    }\n    ... on LegacyEncryptedCommitment {\n      id\n      blockNumber\n      blockTimestamp\n      transactionHash\n      treeNumber\n      batchStartTreePosition\n      treePosition\n      commitmentType\n      hash\n      legacyCiphertext: ciphertext {\n        id\n        ciphertext {\n          id\n          iv\n          tag\n          data\n        }\n        ephemeralKeys\n        memo\n      }\n    }\n    ... on ShieldCommitment {\n      id\n      blockNumber\n      blockTimestamp\n      transactionHash\n      treeNumber\n      batchStartTreePosition\n      treePosition\n      commitmentType\n      hash\n      shieldKey\n      fee\n      encryptedBundle\n      preimage {\n        id\n        npk\n        value\n        token {\n          id\n          tokenType\n          tokenSubID\n          tokenAddress\n        }\n      }\n    }\n    ... on TransactCommitment {\n      id\n      blockNumber\n      blockTimestamp\n      transactionHash\n      treeNumber\n      batchStartTreePosition\n      treePosition\n      commitmentType\n      hash\n      ciphertext {\n        id\n        ciphertext {\n          id\n          iv\n          tag\n          data\n        }\n        blindedSenderViewingKey\n        blindedReceiverViewingKey\n        annotationData\n        memo\n      }\n    }\n  }\n}\n    ` as unknown as DocumentNode<CommitmentsQuery, CommitmentsQueryVariables>;\n\n\n\n\nexport type Requester<C = {}, E = unknown> = <R, V>(doc: DocumentNode, vars?: V, options?: C) => Promise<R> | AsyncIterable<R>\nexport function getSdk<C, E>(requester: Requester<C, E>) {\n  return {\n    Nullifiers(variables?: NullifiersQueryVariables, options?: C): Promise<NullifiersQuery> {\n      return requester<NullifiersQuery, NullifiersQueryVariables>(NullifiersDocument, variables, options) as Promise<NullifiersQuery>;\n    },\n    Unshields(variables?: UnshieldsQueryVariables, options?: C): Promise<UnshieldsQuery> {\n      return requester<UnshieldsQuery, UnshieldsQueryVariables>(UnshieldsDocument, variables, options) as Promise<UnshieldsQuery>;\n    },\n    Commitments(variables?: CommitmentsQueryVariables, options?: C): Promise<CommitmentsQuery> {\n      return requester<CommitmentsQuery, CommitmentsQueryVariables>(CommitmentsDocument, variables, options) as Promise<CommitmentsQuery>;\n    }\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;"]}