"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NFTTokenType = exports.TokenType = exports.getTokenDataERC20 = exports.getTokenDataNFT = exports.getTokenDataHash = exports.balanceForNFT = exports.balanceForERC20Token = exports.onWalletPOIProofProgress = exports.onBalancesUpdate = exports.getSerializedNFTBalances = exports.getSerializedERC20Balances = exports.setOnWalletPOIProofProgressCallback = exports.setOnBalanceUpdateCallback = void 0;
const engine_1 = require("@railgun-community/engine");
Object.defineProperty(exports, "TokenType", { enumerable: true, get: function () { return engine_1.TokenType; } });
Object.defineProperty(exports, "getTokenDataHash", { enumerable: true, get: function () { return engine_1.getTokenDataHash; } });
Object.defineProperty(exports, "getTokenDataNFT", { enumerable: true, get: function () { return engine_1.getTokenDataNFT; } });
Object.defineProperty(exports, "getTokenDataERC20", { enumerable: true, get: function () { return engine_1.getTokenDataERC20; } });
const shared_models_1 = require("@railgun-community/shared-models");
Object.defineProperty(exports, "NFTTokenType", { enumerable: true, get: function () { return shared_models_1.NFTTokenType; } });
const logger_1 = require("../../../utils/logger");
const bytes_1 = require("../util/bytes");
const poi_required_1 = require("../../poi/poi-required");
let onBalanceUpdateCallback;
const setOnBalanceUpdateCallback = (callback) => {
    onBalanceUpdateCallback = callback;
};
exports.setOnBalanceUpdateCallback = setOnBalanceUpdateCallback;
let onWalletPOIProofProgressCallback;
const setOnWalletPOIProofProgressCallback = (callback) => {
    onWalletPOIProofProgressCallback = callback;
};
exports.setOnWalletPOIProofProgressCallback = setOnWalletPOIProofProgressCallback;
const getSerializedERC20Balances = (balances) => {
    const tokenHashes = Object.keys(balances);
    return tokenHashes
        .filter(tokenHash => {
        return balances[tokenHash].tokenData.tokenType === engine_1.TokenType.ERC20;
    })
        .map(railgunBalanceAddress => {
        const erc20Balance = {
            tokenAddress: (0, bytes_1.parseRailgunTokenAddress)(balances[railgunBalanceAddress].tokenData.tokenAddress).toLowerCase(),
            amount: balances[railgunBalanceAddress].balance,
        };
        return erc20Balance;
    });
};
exports.getSerializedERC20Balances = getSerializedERC20Balances;
const getSerializedNFTBalances = (balances) => {
    const tokenHashes = Object.keys(balances);
    return tokenHashes
        .filter(tokenHash => {
        return [engine_1.TokenType.ERC721, engine_1.TokenType.ERC1155].includes(balances[tokenHash].tokenData.tokenType);
    })
        .map(railgunBalanceAddress => {
        const balanceForToken = balances[railgunBalanceAddress];
        const tokenData = balanceForToken.tokenData;
        const nftBalance = {
            nftAddress: (0, bytes_1.parseRailgunTokenAddress)(tokenData.tokenAddress).toLowerCase(),
            tokenSubID: tokenData.tokenSubID,
            nftTokenType: tokenData.tokenType,
            amount: balanceForToken.balance,
        };
        return nftBalance;
    });
};
exports.getSerializedNFTBalances = getSerializedNFTBalances;
const getNFTBalances = (balances) => {
    const tokenHashes = Object.keys(balances);
    return tokenHashes
        .filter(tokenHash => {
        return ([engine_1.TokenType.ERC721, engine_1.TokenType.ERC1155].includes(balances[tokenHash].tokenData.tokenType) && balances[tokenHash].balance > BigInt(0));
    })
        .map(tokenHash => {
        const tokenData = balances[tokenHash].tokenData;
        const nftBalance = {
            nftAddress: (0, bytes_1.parseRailgunTokenAddress)(tokenData.tokenAddress).toLowerCase(),
            nftTokenType: tokenData.tokenType,
            tokenSubID: tokenData.tokenSubID,
            amount: balances[tokenHash].balance,
        };
        return nftBalance;
    });
};
const onBalancesUpdate = async (txidVersion, wallet, chain) => {
    try {
        if (!onBalanceUpdateCallback) {
            return;
        }
        (0, logger_1.sendMessage)(`Wallet balance SCANNED. Getting balances for chain ${chain.type}:${chain.id}.`);
        const network = (0, shared_models_1.networkForChain)(chain);
        if (!network) {
            return;
        }
        if (!(await poi_required_1.POIRequired.isRequiredForNetwork(network.name))) {
            // POI not required for this network
            return getAllBalancesAsSpendable(txidVersion, wallet, chain);
        }
        // POI required for this network
        const tokenBalancesByBucket = await wallet.getTokenBalancesByBucket(txidVersion, chain);
        const balanceBuckets = Object.values(shared_models_1.RailgunWalletBalanceBucket);
        balanceBuckets.forEach(balanceBucket => {
            if (!onBalanceUpdateCallback) {
                return;
            }
            const tokenBalances = tokenBalancesByBucket[balanceBucket];
            if (!(0, shared_models_1.isDefined)(tokenBalances)) {
                return;
            }
            const erc20Amounts = (0, exports.getSerializedERC20Balances)(tokenBalances);
            const nftAmounts = getNFTBalances(tokenBalances);
            const balancesEvent = {
                txidVersion,
                chain,
                erc20Amounts,
                nftAmounts,
                railgunWalletID: wallet.id,
                balanceBucket,
            };
            onBalanceUpdateCallback(balancesEvent);
        });
    }
    catch (err) {
        if (!(err instanceof Error)) {
            return;
        }
        (0, logger_1.sendMessage)(`Error getting balances for chain ${chain.type}:${chain.id}: ${err.message}`);
        (0, logger_1.sendErrorMessage)(err);
    }
};
exports.onBalancesUpdate = onBalancesUpdate;
const getAllBalancesAsSpendable = async (txidVersion, wallet, chain) => {
    if (!onBalanceUpdateCallback) {
        return;
    }
    const tokenBalances = await wallet.getTokenBalances(txidVersion, chain, false);
    const erc20Amounts = (0, exports.getSerializedERC20Balances)(tokenBalances);
    const nftAmounts = getNFTBalances(tokenBalances);
    const balancesEvent = {
        txidVersion,
        chain,
        erc20Amounts,
        nftAmounts,
        railgunWalletID: wallet.id,
        balanceBucket: shared_models_1.RailgunWalletBalanceBucket.Spendable,
    };
    onBalanceUpdateCallback(balancesEvent);
};
const onWalletPOIProofProgress = (status, txidVersion, wallet, chain, progress, listKey, txid, railgunTxid, index, totalCount, errMessage) => {
    (0, logger_1.sendMessage)(`[${listKey}, ${chain.type}:${chain.id}] Wallet POI proof progress: ${progress}.`);
    if (!onWalletPOIProofProgressCallback) {
        return;
    }
    const poiProofEvent = {
        status,
        txidVersion,
        chain,
        railgunWalletID: wallet.id,
        progress,
        listKey,
        txid,
        railgunTxid,
        index,
        totalCount,
        errMessage,
    };
    onWalletPOIProofProgressCallback(poiProofEvent);
};
exports.onWalletPOIProofProgress = onWalletPOIProofProgress;
const balanceForERC20Token = async (txidVersion, wallet, networkName, tokenAddress, onlySpendable) => {
    const { chain } = shared_models_1.NETWORK_CONFIG[networkName];
    const balances = await wallet.getTokenBalances(txidVersion, chain, onlySpendable);
    const tokenBalances = (0, exports.getSerializedERC20Balances)(balances);
    const matchingTokenBalance = tokenBalances.find(tokenBalance => tokenBalance.tokenAddress.toLowerCase() === tokenAddress.toLowerCase());
    if (!matchingTokenBalance) {
        return 0n;
    }
    return matchingTokenBalance.amount;
};
exports.balanceForERC20Token = balanceForERC20Token;
const balanceForNFT = async (txidVersion, wallet, networkName, nftTokenData, onlySpendable) => {
    const { chain } = shared_models_1.NETWORK_CONFIG[networkName];
    const balances = await wallet.getTokenBalances(txidVersion, chain, onlySpendable);
    const nftBalances = (0, exports.getSerializedNFTBalances)(balances);
    const matchingNFTBalance = nftBalances.find(nftBalance => nftBalance.nftAddress.toLowerCase() ===
        nftTokenData.tokenAddress.toLowerCase() &&
        BigInt(nftBalance.tokenSubID) === BigInt(nftTokenData.tokenSubID));
    if (!matchingNFTBalance) {
        return 0n;
    }
    return matchingNFTBalance.amount;
};
exports.balanceForNFT = balanceForNFT;
//# sourceMappingURL=balance-update.js.map