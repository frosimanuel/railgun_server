"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = __importDefault(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const mocks_test_1 = require("../../../../tests/mocks.test");
const setup_test_1 = require("../../../../tests/setup.test");
const wallets_1 = require("../wallets");
const balances_1 = require("../balances");
const shared_models_1 = require("@railgun-community/shared-models");
const load_provider_1 = require("../../core/load-provider");
const merkletree_1 = require("../../core/merkletree");
const helper_test_1 = require("../../../../tests/helper.test");
const engine_1 = require("../../core/engine");
chai_1.default.use(chai_as_promised_1.default);
const { expect } = chai_1.default;
let railgunWalletID;
const txidVersion = (0, helper_test_1.getTestTXIDVersion)();
const networkName = shared_models_1.NetworkName.EthereumSepolia;
const chain = shared_models_1.NETWORK_CONFIG[networkName].chain;
describe('balances-live', () => {
    before(async function run() {
        this.timeout(360000);
        await (0, setup_test_1.initTestEngine)();
        const railgunWalletInfo = await (0, wallets_1.createRailgunWallet)(mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MNEMONIC, undefined);
        if (!(0, shared_models_1.isDefined)(railgunWalletInfo)) {
            throw new Error('Expected railgunWalletInfo');
        }
        railgunWalletID = railgunWalletInfo.id;
        await (0, load_provider_1.loadProvider)(mocks_test_1.MOCK_FALLBACK_PROVIDER_JSON_CONFIG_SEPOLIA, networkName, 10000);
        const { chain } = shared_models_1.NETWORK_CONFIG[networkName];
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        (0, engine_1.getEngine)().scanContractHistory(chain, undefined);
        await Promise.all([
            (0, setup_test_1.pollUntilUTXOMerkletreeScanned)(),
            // Enable this when running on a network supporting PPOI:
            (0, setup_test_1.pollUntilTXIDMerkletreeScanned)(),
        ]);
    });
    after(async () => {
        await (0, setup_test_1.closeTestEngine)();
    });
    it('[V2] Should run live balance fetch, transaction history scan, and POI status info scan', async function run() {
        if (!(0, helper_test_1.isV2Test)()) {
            this.skip();
            return;
        }
        await (0, balances_1.rescanFullUTXOMerkletreesAndWallets)(chain, [railgunWalletID]);
        const wallet = (0, wallets_1.fullWalletForID)(railgunWalletID);
        const balances = await wallet.getTokenBalances(txidVersion, chain, false);
        // Note: railgunWallet above needs to perform transactions on above network to have balances
        expect(Object.keys(balances).length).to.be.greaterThanOrEqual(1);
        const transactionHistory = await wallet.getTransactionHistory(chain, undefined);
        expect(transactionHistory.length).to.be.greaterThanOrEqual(2);
        const poiStatusReceived = await wallet.getTXOsReceivedPOIStatusInfo(txidVersion, chain);
        expect(poiStatusReceived.length).to.be.greaterThanOrEqual(2);
        expect(poiStatusReceived[0].strings.blindedCommitment).to.not.equal('Missing');
        const txidMerkletree = (0, merkletree_1.getTXIDMerkletreeForNetwork)(txidVersion, networkName);
        expect(txidMerkletree.savedPOILaunchSnapshot).to.equal(true);
        const poiStatusSpent = await wallet.getTXOsSpentPOIStatusInfo(txidVersion, chain);
        expect(poiStatusSpent.length).to.be.greaterThanOrEqual(1);
        expect(poiStatusSpent[0].strings.railgunTransactionInfo).to.not.equal('Not found');
    }).timeout(90000);
});
//# sourceMappingURL=balances-live.test.js.map