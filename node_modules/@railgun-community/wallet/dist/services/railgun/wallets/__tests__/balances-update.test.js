"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = __importDefault(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const engine_1 = require("@railgun-community/engine");
const sinon_1 = __importDefault(require("sinon"));
const shared_models_1 = require("@railgun-community/shared-models");
const balance_update_1 = require("../balance-update");
const wallets_1 = require("../wallets");
const mocks_test_1 = require("../../../../tests/mocks.test");
const setup_test_1 = require("../../../../tests/setup.test");
const load_provider_1 = require("../../core/load-provider");
const helper_test_1 = require("../../../../tests/helper.test");
const engine_2 = require("../../core/engine");
chai_1.default.use(chai_as_promised_1.default);
const { expect } = chai_1.default;
const MOCK_TOKEN_ADDRESS = '0x012536';
const txidVersion = (0, helper_test_1.getTestTXIDVersion)();
let wallet;
let walletBalanceStub;
let walletBalancesByBucketStub;
let walletTokenBalanceStub;
describe('balances-update', () => {
    before(async function run() {
        this.timeout(60000);
        await (0, setup_test_1.initTestEngine)();
        const railgunWalletInfo = await (0, wallets_1.createRailgunWallet)(mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MNEMONIC, undefined);
        if (!(0, shared_models_1.isDefined)(railgunWalletInfo)) {
            throw new Error('Expected railgunWalletInfo');
        }
        await (0, load_provider_1.loadProvider)(mocks_test_1.MOCK_FALLBACK_PROVIDER_JSON_CONFIG_SEPOLIA, shared_models_1.NetworkName.EthereumSepolia, 10000);
        const { chain } = shared_models_1.NETWORK_CONFIG[shared_models_1.NetworkName.EthereumSepolia];
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        (0, engine_2.getEngine)().scanContractHistory(chain, undefined);
        wallet = (0, wallets_1.fullWalletForID)(railgunWalletInfo.id);
        const tokenAddress = MOCK_TOKEN_ADDRESS.replace('0x', '');
        const tokenData = (0, engine_1.getTokenDataERC20)(tokenAddress);
        const balances = {
            [tokenAddress]: {
                balance: BigInt(10),
                utxos: [],
                tokenData,
            },
        };
        walletBalanceStub = sinon_1.default.stub(engine_1.RailgunWallet, 'getTokenBalancesByTxidVersion').resolves(balances);
        walletBalancesByBucketStub = sinon_1.default.stub(engine_1.RailgunWallet.prototype, 'getTokenBalancesByBucket').resolves({ Spendable: balances });
        walletTokenBalanceStub = sinon_1.default.stub(engine_1.RailgunWallet.prototype, 'getTokenBalances').resolves(balances);
    });
    afterEach(() => {
        walletBalanceStub.resetHistory();
        walletBalancesByBucketStub.resetHistory();
        walletTokenBalanceStub.resetHistory();
    });
    after(async () => {
        walletBalanceStub.restore();
        walletBalancesByBucketStub.restore();
        walletTokenBalanceStub.restore();
        await (0, setup_test_1.closeTestEngine)();
    });
    it('Should not pull balances without callback', async () => {
        (0, balance_update_1.setOnBalanceUpdateCallback)(undefined);
        const chain = { type: engine_1.ChainType.EVM, id: 1 };
        await expect((0, balance_update_1.onBalancesUpdate)(txidVersion, wallet, chain)).to.be.fulfilled;
        expect(walletBalanceStub.notCalled).to.be.true;
        expect(walletBalancesByBucketStub.notCalled).to.be.true;
    });
    it('Should parse wallet balances response', async () => {
        let formattedBalances;
        const callback = (balancesFormatted) => {
            formattedBalances = balancesFormatted;
        };
        (0, balance_update_1.setOnBalanceUpdateCallback)(callback);
        const chain = { type: engine_1.ChainType.EVM, id: 80001 };
        await expect((0, balance_update_1.onBalancesUpdate)(txidVersion, wallet, chain)).to.be.fulfilled;
        // TODO: enable this assertion once we have PPOI on PolygonMumbai
        // because `onBalancesUpdate` only runs it if PPOI is required:
        // expect(walletBalancesByBucketStub.calledOnce).to.be.true;
        expect(formattedBalances.balanceBucket).to.deep.equal(shared_models_1.RailgunWalletBalanceBucket.Spendable);
        expect(formattedBalances.chain).to.deep.equal(chain);
        expect(formattedBalances.erc20Amounts.length).to.equal(1);
        expect(formattedBalances.erc20Amounts[0]).to.deep.equal({
            tokenAddress: '0x0000000000000000000000000000000000012536',
            amount: 10n,
        });
    });
    it('Should parse poi proof progress response', async () => {
        let proofProgress;
        const callback = (proofProgressEvent) => {
            proofProgress = proofProgressEvent;
        };
        (0, balance_update_1.setOnWalletPOIProofProgressCallback)(callback);
        const chain = { type: engine_1.ChainType.EVM, id: 69 };
        const status = engine_1.POIProofEventStatus.InProgress;
        const progress = 5;
        const listKey = 'listKey';
        const txid = 'txid';
        const railgunTxid = 'railgunTxid';
        const index = 2;
        const totalCount = 10;
        (0, balance_update_1.onWalletPOIProofProgress)(status, txidVersion, wallet, chain, progress, listKey, txid, railgunTxid, index, totalCount, undefined);
        expect(proofProgress.chain).to.deep.equal(chain);
        expect(proofProgress.railgunWalletID).to.equal(wallet.id);
        expect(proofProgress.progress).to.equal(progress);
        expect(proofProgress.listKey).to.equal(listKey);
        expect(proofProgress.txid).to.equal(txid);
        expect(proofProgress.railgunTxid).to.equal(railgunTxid);
        expect(proofProgress.index).to.equal(index);
        expect(proofProgress.totalCount).to.equal(totalCount);
        expect(proofProgress.txidVersion).to.equal(txidVersion);
        expect(proofProgress.errMessage).to.be.undefined;
    });
});
//# sourceMappingURL=balances-update.test.js.map