"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWalletShareableViewingKey = exports.getRailgunAddress = exports.validateEthAddress = exports.assertValidEthAddress = exports.validateRailgunAddress = exports.assertValidRailgunAddress = exports.signWithWalletViewingKey = exports.getRailgunWalletPrivateViewingKey = exports.getRailgunWalletAddressData = exports.getWalletMnemonic = exports.deleteWalletByID = exports.unloadWalletByID = exports.loadWalletByID = exports.createViewOnlyRailgunWallet = exports.createRailgunWallet = exports.viewOnlyWalletForID = exports.fullWalletForID = exports.walletForID = exports.awaitMultipleWalletScans = exports.awaitWalletScan = void 0;
const engine_1 = require("@railgun-community/engine");
const shared_models_1 = require("@railgun-community/shared-models");
const balance_update_1 = require("./balance-update");
const error_1 = require("../../../utils/error");
const ethers_1 = require("ethers");
const engine_2 = require("../core/engine");
const awaitWalletScan = (walletID, chain) => {
    const wallet = (0, exports.walletForID)(walletID);
    return new Promise((resolve, reject) => wallet.once(engine_1.EngineEvent.WalletDecryptBalancesComplete, ({ chain: returnedChain }) => returnedChain.type === chain.type && returnedChain.id === chain.id
        ? resolve(returnedChain)
        : reject()));
};
exports.awaitWalletScan = awaitWalletScan;
const awaitMultipleWalletScans = async (walletID, chain, numScans) => {
    let i = 0;
    while (i < numScans) {
        // eslint-disable-next-line no-await-in-loop
        await (0, exports.awaitWalletScan)(walletID, chain);
        i += 1;
    }
    return Promise.resolve();
};
exports.awaitMultipleWalletScans = awaitMultipleWalletScans;
const walletForID = (id) => {
    const engine = (0, engine_2.getEngine)();
    const wallet = engine.wallets[id];
    if (!(0, shared_models_1.isDefined)(wallet)) {
        throw new Error('No RAILGUN wallet for ID');
    }
    return wallet;
};
exports.walletForID = walletForID;
const fullWalletForID = (id) => {
    const wallet = (0, exports.walletForID)(id);
    if (!(wallet instanceof engine_1.RailgunWallet)) {
        throw new Error('Can not load View-Only wallet.');
    }
    return wallet;
};
exports.fullWalletForID = fullWalletForID;
const viewOnlyWalletForID = (id) => {
    const wallet = (0, exports.walletForID)(id);
    if (!(wallet instanceof engine_1.ViewOnlyWallet)) {
        throw new Error('Can only load View-Only wallet.');
    }
    return wallet;
};
exports.viewOnlyWalletForID = viewOnlyWalletForID;
const subscribeToEvents = (wallet) => {
    wallet.on(engine_1.EngineEvent.WalletDecryptBalancesComplete, ({ txidVersion, chain }) => {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        (0, balance_update_1.onBalancesUpdate)(txidVersion, wallet, chain);
    });
    wallet.on(engine_1.EngineEvent.POIProofUpdate, ({ status, txidVersion, chain, progress, listKey, txid, railgunTxid, index, totalCount, errorMsg, }) => {
        (0, balance_update_1.onWalletPOIProofProgress)(status, txidVersion, wallet, chain, progress, listKey, txid, railgunTxid, index, totalCount, errorMsg);
    });
};
const addressForWallet = (wallet) => {
    return wallet.getAddress();
};
const infoForWallet = (wallet) => {
    const railgunAddress = addressForWallet(wallet);
    return {
        id: wallet.id,
        railgunAddress,
    };
};
const getExistingWallet = (railgunWalletID) => {
    try {
        const existingWallet = (0, exports.walletForID)(railgunWalletID);
        return existingWallet;
    }
    catch (_err) {
        return undefined;
    }
};
const loadExistingWallet = async (encryptionKey, railgunWalletID, isViewOnlyWallet) => {
    const existingWallet = getExistingWallet(railgunWalletID);
    if (existingWallet) {
        return infoForWallet(existingWallet);
    }
    const engine = (0, engine_2.getEngine)();
    let wallet;
    if (isViewOnlyWallet) {
        wallet = await engine.loadExistingViewOnlyWallet(encryptionKey, railgunWalletID);
    }
    else {
        wallet = await engine.loadExistingWallet(encryptionKey, railgunWalletID);
    }
    subscribeToEvents(wallet);
    return infoForWallet(wallet);
};
const createWallet = async (encryptionKey, mnemonic, creationBlockNumbers, railgunWalletDerivationIndex) => {
    const formattedCreationBlockNumbers = formatCreationBlockNumbers(creationBlockNumbers);
    const engine = (0, engine_2.getEngine)();
    const wallet = await engine.createWalletFromMnemonic(encryptionKey, mnemonic, railgunWalletDerivationIndex ?? 0, formattedCreationBlockNumbers);
    subscribeToEvents(wallet);
    return infoForWallet(wallet);
};
const createViewOnlyWallet = async (encryptionKey, shareableViewingKey, creationBlockNumbers) => {
    const formattedCreationBlockNumbers = formatCreationBlockNumbers(creationBlockNumbers);
    const engine = (0, engine_2.getEngine)();
    const wallet = await engine.createViewOnlyWalletFromShareableViewingKey(encryptionKey, shareableViewingKey, formattedCreationBlockNumbers);
    subscribeToEvents(wallet);
    return infoForWallet(wallet);
};
const createRailgunWallet = async (encryptionKey, mnemonic, creationBlockNumbers, railgunWalletDerivationIndex) => {
    try {
        return await createWallet(encryptionKey, mnemonic, creationBlockNumbers, railgunWalletDerivationIndex);
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.createRailgunWallet.name, err);
    }
};
exports.createRailgunWallet = createRailgunWallet;
const createViewOnlyRailgunWallet = async (encryptionKey, shareableViewingKey, creationBlockNumbers) => {
    try {
        return await createViewOnlyWallet(encryptionKey, shareableViewingKey, creationBlockNumbers);
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.createViewOnlyRailgunWallet.name, err);
    }
};
exports.createViewOnlyRailgunWallet = createViewOnlyRailgunWallet;
const loadWalletByID = async (encryptionKey, railgunWalletID, isViewOnlyWallet) => {
    try {
        return await loadExistingWallet(encryptionKey, railgunWalletID, isViewOnlyWallet);
    }
    catch (err) {
        const sanitizedError = (0, error_1.reportAndSanitizeError)(exports.loadWalletByID.name, err);
        throw new Error(`Could not load RAILGUN wallet`, { cause: sanitizedError });
    }
};
exports.loadWalletByID = loadWalletByID;
const unloadWalletByID = (railgunWalletID) => {
    try {
        const engine = (0, engine_2.getEngine)();
        engine.unloadWallet(railgunWalletID);
    }
    catch (err) {
        throw new Error('Could not unload RAILGUN wallet.', { cause: err });
    }
};
exports.unloadWalletByID = unloadWalletByID;
const deleteWalletByID = async (railgunWalletID) => {
    try {
        const engine = (0, engine_2.getEngine)();
        await engine.deleteWallet(railgunWalletID);
    }
    catch (err) {
        throw new Error('Could not delete RAILGUN wallet.', { cause: err });
    }
};
exports.deleteWalletByID = deleteWalletByID;
const getWalletMnemonic = async (encryptionKey, railgunWalletID) => {
    const { db } = (0, engine_2.getEngine)();
    // Reload wallet to ensure that encryption key is valid.
    const walletData = (await engine_1.RailgunWallet.getEncryptedData(db, encryptionKey, railgunWalletID));
    if (!walletData.mnemonic) {
        throw new Error('No mnemonic for wallet.');
    }
    return walletData.mnemonic;
};
exports.getWalletMnemonic = getWalletMnemonic;
const getRailgunWalletAddressData = (address) => {
    (0, exports.assertValidRailgunAddress)(address);
    return engine_1.RailgunEngine.decodeAddress(address);
};
exports.getRailgunWalletAddressData = getRailgunWalletAddressData;
const getRailgunWalletPrivateViewingKey = (railgunWalletID) => {
    const wallet = (0, exports.walletForID)(railgunWalletID);
    return wallet.getViewingKeyPair().privateKey;
};
exports.getRailgunWalletPrivateViewingKey = getRailgunWalletPrivateViewingKey;
const signWithWalletViewingKey = async (railgunWalletID, message) => {
    const wallet = (0, exports.walletForID)(railgunWalletID);
    const signature = await wallet.signWithViewingKey(engine_1.ByteUtils.hexStringToBytes(message));
    return engine_1.ByteUtils.hexlify(signature);
};
exports.signWithWalletViewingKey = signWithWalletViewingKey;
const assertValidRailgunAddress = (address) => {
    if (!(0, exports.validateRailgunAddress)(address)) {
        throw new Error('Invalid RAILGUN address.');
    }
};
exports.assertValidRailgunAddress = assertValidRailgunAddress;
const validateRailgunAddress = (address) => {
    try {
        return engine_1.RailgunEngine.decodeAddress(address) != null;
    }
    catch (err) {
        return false;
    }
};
exports.validateRailgunAddress = validateRailgunAddress;
const assertValidEthAddress = (address) => {
    if (!(0, exports.validateEthAddress)(address)) {
        throw new Error('Invalid wallet address.');
    }
};
exports.assertValidEthAddress = assertValidEthAddress;
const validateEthAddress = (address) => {
    try {
        (0, ethers_1.getAddress)(address);
        return true;
    }
    catch (err) {
        return false;
    }
};
exports.validateEthAddress = validateEthAddress;
const getRailgunAddress = (railgunWalletID) => {
    try {
        const wallet = (0, exports.walletForID)(railgunWalletID);
        return wallet.getAddress();
    }
    catch (err) {
        (0, error_1.reportAndSanitizeError)(exports.getRailgunAddress.name, err);
        return undefined;
    }
};
exports.getRailgunAddress = getRailgunAddress;
const getWalletShareableViewingKey = async (railgunWalletID) => {
    try {
        const wallet = (0, exports.walletForID)(railgunWalletID);
        return wallet.generateShareableViewingKey();
    }
    catch (err) {
        (0, error_1.reportAndSanitizeError)(exports.getWalletShareableViewingKey.name, err);
        return undefined;
    }
};
exports.getWalletShareableViewingKey = getWalletShareableViewingKey;
const formatCreationBlockNumbers = (creationBlockNumbers) => {
    // Format creationBlockNumbers from client side { <NetworkName>: <BlockNumber> } map to @railgun-community/engine's number[][] type
    if (!creationBlockNumbers)
        return;
    const formattedCreationBlockNumbers = [];
    const networksNames = Object.keys(creationBlockNumbers);
    for (const networkName of networksNames) {
        const network = shared_models_1.NETWORK_CONFIG[networkName];
        const blockNumber = creationBlockNumbers[networkName];
        if (!(0, shared_models_1.isDefined)(blockNumber)) {
            continue;
        }
        formattedCreationBlockNumbers[network.chain.type] ??= [];
        formattedCreationBlockNumbers[network.chain.type][network.chain.id] =
            blockNumber;
    }
    return formattedCreationBlockNumbers;
};
//# sourceMappingURL=wallets.js.map