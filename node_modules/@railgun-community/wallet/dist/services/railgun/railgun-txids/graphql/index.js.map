{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../src/services/railgun/railgun-txids/graphql/index.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;AACH,cAAc;AACd,sDAAsD;AACtD,uDAAuD;AACvD,sDAAsD;AACtD,4DAA4D;AAC5D,yCAAyC;AACzC,iDAAiD;AACjD,qEAAqE;AACrE,gDAAgD;AAChD,oCAAoC;AACpC,wDAAwD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIxD,+CAA0C;AAI1C,+CAA6C;AAC7C,+CAAoD;AACpD,wFAAwD;AACxD,8CAAsD;AAItD,oEAAkD;AAClD,4EAAmD;AACnD,+CAAqD;AACrD,6CAA4E;AAC5E,mDAA8H;AAC9H,+CAAuE;AACvE,+DAAiE;AA8gGjE,MAAM,OAAO,GAAG,oBAAU,CAAC,IAAI,CAAC,OAAO,SAAS,KAAK,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AAEvF,MAAM,QAAQ,GAAa,CAAI,QAAgB,EAAE,EAAE;IACjD,MAAM,gBAAgB,GAAG,CAAC,oBAAU,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,oBAAU,CAAC,QAAQ,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,OAAO,GAAG,GAAG,EAAE,EAAE,CAAC,CAAC;IAChK,QAAO,gBAAgB,EAAE;QACvB,KAAK,uDAAuD;YAC1D,OAAO,kDAAO,yDAAyD,GAAM,CAAC;QAChF,KAAK,sDAAsD;YACzD,OAAO,kDAAO,wDAAwD,GAAM,CAAC;QAC/E,KAAK,uDAAuD;YACxD,OAAO,kDAAO,yDAAyD,GAAM,CAAC;QAClF,KAAK,kDAAkD;YACrD,OAAO,kDAAO,oDAAoD,GAAM,CAAC;QAC3E,KAAK,oDAAoD;YACvD,OAAO,kDAAO,sDAAsD,GAAM,CAAC;QAC7E;YACE,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,uBAAuB,gBAAgB,IAAI,CAAC,CAAC,CAAC;KACjF;AACH,CAAC,CAAC;AAEF,MAAM,SAAS,GAAG,IAAI,iBAAS,CAAC,cAAc,EAAE,IAAI,6BAAqB,CAAC;IACxE,GAAG,EAAE,OAAO;IACZ,QAAQ;IACR,QAAQ,EAAE,IAAI;CACf,CAAC,EAAE;IACF,QAAQ,EAAE,IAAI;IACd,QAAQ,EAAE,KAAK;CAChB,CAAC,CAAC;AAEU,QAAA,cAAc,GAA+B,SAAgB,CAAA;AACnE,KAAK,UAAU,cAAc;IACpC,MAAM,MAAM,GAAG,IAAI,cAAM,EAAE,CAAC;IAC5B,MAAM,YAAY,GAAG,SAAS,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IAChD,MAAM,MAAM,GAAG,IAAI,qBAAa,CAAC,aAAa,CAAC,CAAC;IAChD,MAAM,KAAK,GAAG,IAAK,2BAAiB,CAAC;QAC/B,GAAI,EAAU;QACd,QAAQ;QACR,KAAK,EAAE,SAAS,CAAC,KAAK,CAAC,OAAO,CAAC;QAC/B,MAAM;QACN,MAAM;KACA,CAAC,CAAA;IAEb,MAAM,OAAO,GAAyB,EAAE,CAAC;IACzC,MAAM,UAAU,GAAoB,EAAE,CAAC;IACvC,MAAM,wBAAwB,GAAsB,EAAE,CAAC;IACvD,MAAM,qBAAqB,GAAG,EAAE,CAAC;IACjC,MAAM,oBAAoB,GAAG,EAAE,CAAC;IAChC,MAAM,qBAAqB,GAAG,EAAE,CAAC;IACjC,MAAM,gBAAgB,GAAG,EAAE,CAAC;IAC5B,MAAM,kBAAkB,GAAG,EAAE,CAAC;IAC9B,MAAM,kBAAkB,GAAG,EAAW,CAAC;IACvC,MAAM,kBAAkB,GAAG,IAAI,iBAAc,CAAC;QAChC,IAAI,EAAE,cAAc;QACpB,MAAM,EAAE,EAAC,UAAU,EAAC,kEAAkE,EAAC;QACvF,OAAO;QACP,KAAK;QACL,MAAM;QACN,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,cAAc,CAAC;QACzC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC;QACpC,QAAQ;KACT,CAAC,CAAC;IACf,MAAM,iBAAiB,GAAG,IAAI,iBAAc,CAAC;QAC/B,IAAI,EAAE,aAAa;QACnB,MAAM,EAAE,EAAC,UAAU,EAAC,qEAAqE,EAAC;QAC1F,OAAO;QACP,KAAK;QACL,MAAM;QACN,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,aAAa,CAAC;QACxC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,aAAa,CAAC;QACnC,QAAQ;KACT,CAAC,CAAC;IACf,MAAM,kBAAkB,GAAG,IAAI,iBAAc,CAAC;QAChC,IAAI,EAAE,cAAc;QACpB,MAAM,EAAE,EAAC,UAAU,EAAC,kEAAkE,EAAC;QACvF,OAAO;QACP,KAAK;QACL,MAAM;QACN,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,cAAc,CAAC;QACzC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC;QACpC,QAAQ;KACT,CAAC,CAAC;IACf,MAAM,aAAa,GAAG,IAAI,iBAAc,CAAC;QAC3B,IAAI,EAAE,SAAS;QACf,MAAM,EAAE,EAAC,UAAU,EAAC,6DAA6D,EAAC;QAClF,OAAO;QACP,KAAK;QACL,MAAM;QACN,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC;QACpC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC;QAC/B,QAAQ;KACT,CAAC,CAAC;IACf,MAAM,eAAe,GAAG,IAAI,iBAAc,CAAC;QAC7B,IAAI,EAAE,WAAW;QACjB,MAAM,EAAE,EAAC,UAAU,EAAC,iEAAiE,EAAC;QACtF,OAAO;QACP,KAAK;QACL,MAAM;QACN,KAAK,EAAE,YAAY,CAAC,KAAK,CAAC,WAAW,CAAC;QACtC,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC;QACjC,QAAQ;KACT,CAAC,CAAC;IACf,OAAO,CAAC,CAAC,CAAC,GAAG;QACH,IAAI,EAAE,cAAc;QACpB,OAAO,EAAE,kBAAkB;QAC3B,UAAU,EAAE,qBAAqB;KAClC,CAAA;IACT,OAAO,CAAC,CAAC,CAAC,GAAG;QACH,IAAI,EAAE,aAAa;QACnB,OAAO,EAAE,iBAAiB;QAC1B,UAAU,EAAE,oBAAoB;KACjC,CAAA;IACT,OAAO,CAAC,CAAC,CAAC,GAAG;QACH,IAAI,EAAE,cAAc;QACpB,OAAO,EAAE,kBAAkB;QAC3B,UAAU,EAAE,qBAAqB;KAClC,CAAA;IACT,OAAO,CAAC,CAAC,CAAC,GAAG;QACH,IAAI,EAAE,SAAS;QACf,OAAO,EAAE,aAAa;QACtB,UAAU,EAAE,gBAAgB;KAC7B,CAAA;IACT,OAAO,CAAC,CAAC,CAAC,GAAG;QACH,IAAI,EAAE,WAAW;QACjB,OAAO,EAAE,eAAe;QACxB,UAAU,EAAE,kBAAkB;KAC/B,CAAA;IACT,MAAM,mBAAmB,GAAG,EAAW,CAAA;IACvC,MAAM,MAAM,GAAG,IAAI,qBAAkB,CAAC;QAC9B,KAAK;QACL,MAAM;QACN,MAAM,EAAE,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC;QAClC,KAAK,EAAE,SAAS,CAAC,KAAK,CAAC,YAAY,CAAC;KACrC,CAAC,CAAA;IAEN,OAAO;QACL,OAAO;QACP,UAAU;QACV,kBAAkB;QAClB,mBAAmB;QACnB,KAAK;QACL,MAAM;QACN,MAAM;QACN,MAAM;QACN,wBAAwB;QACxB,IAAI,SAAS;YACX,OAAO;gBACP;oBACE,QAAQ,EAAE,0CAA0C;oBACpD,IAAI,MAAM;wBACR,OAAO,IAAA,sBAAc,EAAC,0CAA0C,CAAC,CAAC;oBACpE,CAAC;oBACD,QAAQ,EAAE,oDAAoD;iBAC/D,EAAC;oBACA,QAAQ,EAAE,4CAAoC;oBAC9C,IAAI,MAAM;wBACR,OAAO,IAAA,sBAAc,EAAC,4CAAoC,CAAC,CAAC;oBAC9D,CAAC;oBACD,QAAQ,EAAE,8CAA8C;iBACzD,EAAC;oBACA,QAAQ,EAAE,yDAAiD;oBAC3D,IAAI,MAAM;wBACR,OAAO,IAAA,sBAAc,EAAC,yDAAiD,CAAC,CAAC;oBAC3E,CAAC;oBACD,QAAQ,EAAE,2DAA2D;iBACtE;aACF,CAAC;QACF,CAAC;QACD,OAAO,EAAP,aAAO;KACR,CAAC;AACJ,CAAC;AA3ID,wCA2IC;AAED,SAAgB,0BAA0B;IACxC,OAAO,IAAA,4BAAqB,EAAiB;QAC3C,OAAO;QACP,YAAY,EAAE,mBAAmB;QACjC,cAAc,EAAE,SAAS;KAC1B,CAAC,CAAA;AACJ,CAAC;AAND,gEAMC;AAGD,IAAI,aAAgD,CAAC;AAErD,SAAgB,mBAAmB;IACjC,IAAI,aAAa,IAAI,IAAI,EAAE;QACzB,aAAa,GAAG,cAAc,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,IAAA,iBAAO,EAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YACrF,MAAM,EAAE,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,SAAS,EAAE,GAAG,EAAE;gBAC/C,aAAa,GAAG,SAAS,CAAC;gBAC1B,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;YAC9B,CAAC,CAAC,CAAC;YACH,OAAO,IAAI,CAAC;QACd,CAAC,CAAC,CAAC;KACJ;IACD,OAAO,aAAa,CAAC;AACvB,CAAC;AAXD,kDAWC;AAEM,MAAM,OAAO,GAAkB,CAAC,GAAG,IAAI,EAAE,EAAE,CAAC,mBAAmB,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,OAAO,EAAE,EAAE,EAAE,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;AAApG,QAAA,OAAO,WAA6F;AAE1G,MAAM,SAAS,GAAoB,CAAC,GAAG,IAAI,EAAE,EAAE,CAAC,mBAAmB,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,SAAS,EAAE,EAAE,EAAE,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;AAA5G,QAAA,SAAS,aAAmG;AACzH,SAAgB,gBAAgB,CAAgD,aAA8B;IAC5G,MAAM,aAAa,GAAG,mBAAmB,EAAE,CAAC,IAAI,CAAC,CAAC,EAAE,mBAAmB,EAAE,EAAE,EAAE,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC,CAAC;IAClH,OAAO,MAAM,CAAoC,CAAC,GAAG,IAAI,EAAE,EAAE,CAAC,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;AAC3H,CAAC;AAHD,4CAGC;AAgCY,QAAA,0CAA0C,GAAG,IAAA,WAAG,EAAA;;;;;;;;;;;;;;;;;;;;;;;;KAwB8D,CAAC;AAC/G,QAAA,oCAAoC,GAAG,IAAA,WAAG,EAAA;;;;;;;;;;;;;;;;;;;;;;;;KAwBwD,CAAC;AACnG,QAAA,iDAAiD,GAAG,IAAA,WAAG,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;KA4BqE,CAAC;AAM1I,SAAgB,MAAM,CAAO,SAA0B;IACrD,OAAO;QACL,kCAAkC,CAAC,SAA4D,EAAE,OAAW;YAC1G,OAAO,SAAS,CAA4F,kDAA0C,EAAE,SAAS,EAAE,OAAO,CAAqD,CAAC;QAClO,CAAC;QACD,4BAA4B,CAAC,SAAsD,EAAE,OAAW;YAC9F,OAAO,SAAS,CAAgF,4CAAoC,EAAE,SAAS,EAAE,OAAO,CAA+C,CAAC;QAC1M,CAAC;QACD,yCAAyC,CAAC,SAAmE,EAAE,OAAW;YACxH,OAAO,SAAS,CAA0G,yDAAiD,EAAE,SAAS,EAAE,OAAO,CAA4D,CAAC;QAC9P,CAAC;KACF,CAAC;AACJ,CAAC;AAZD,wBAYC","sourcesContent":["/**\n * TO UPDATE:\n * 1. Find all places that are \"MODIFIED\", move them into the new built index.ts (in .graphclient)\n * 2. add these comments (including eslint disables)\n * 3. move the modified index file to quick-sync/graphql/ (NOTE: MAKE SURE TO DRAG AND DROP IN VSCODE SO THE SOURCE LOCATIONS CHANGE!)\n */\n// @ts-nocheck\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-unsafe-call */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/* eslint-disable import/no-duplicates */\n/* eslint-disable @typescript-eslint/ban-types */\n/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\n/* eslint-disable import/newline-after-import */\n/* eslint-disable prefer-template */\n/* eslint-disable @typescript-eslint/no-unsafe-return */\n\nimport { GraphQLResolveInfo, SelectionSetNode, FieldNode, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';\nimport { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';\nimport { gql } from '@graphql-mesh/utils';\n\nimport type { GetMeshOptions } from '@graphql-mesh/runtime';\nimport type { YamlConfig } from '@graphql-mesh/types';\nimport { PubSub } from '@graphql-mesh/utils';\nimport { DefaultLogger } from '@graphql-mesh/utils';\nimport MeshCache from \"@graphql-mesh/cache-localforage\";\nimport { fetch as fetchFn } from '@whatwg-node/fetch';\n\nimport { MeshResolvedSource } from '@graphql-mesh/runtime';\nimport { MeshTransform, MeshPlugin } from '@graphql-mesh/types';\nimport GraphqlHandler from \"@graphql-mesh/graphql\"\nimport BareMerger from \"@graphql-mesh/merger-bare\";\nimport { printWithCache } from '@graphql-mesh/utils';\nimport { createMeshHTTPHandler, MeshHTTPHandler } from '@graphql-mesh/http';\nimport { getMesh, ExecuteMeshFn, SubscribeMeshFn, MeshContext as BaseMeshContext, MeshInstance } from '@graphql-mesh/runtime';\nimport { MeshStore, FsStoreStorageAdapter } from '@graphql-mesh/store';\nimport { path as pathModule } from '@graphql-mesh/cross-helpers';\nimport { ImportFn } from '@graphql-mesh/types';\nimport type { TxsEthereumTypes } from './.graphclient/sources/txs-ethereum/types';\nimport type { TxsSepoliaTypes } from './.graphclient/sources/txs-sepolia/types';\nimport type { TxsBscTypes } from './.graphclient/sources/txs-bsc/types';\nimport type { TxsMaticTypes } from './.graphclient/sources/txs-matic/types';\nimport type { TxsArbitrumTypes } from './.graphclient/sources/txs-arbitrum/types';\nexport type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };\n\n\n\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  Bytes: string;  // MODIFIED\n  BigInt: string; // MODIFIED\n};\n\nexport type Query = {\n  tokens: Array<Token>;\n  tokenById?: Maybe<Token>;\n  /** @deprecated Use tokenById */\n  tokenByUniqueInput?: Maybe<Token>;\n  tokensConnection: TokensConnection;\n  commitmentPreimages: Array<CommitmentPreimage>;\n  commitmentPreimageById?: Maybe<CommitmentPreimage>;\n  /** @deprecated Use commitmentPreimageById */\n  commitmentPreimageByUniqueInput?: Maybe<CommitmentPreimage>;\n  commitmentPreimagesConnection: CommitmentPreimagesConnection;\n  ciphertexts: Array<Ciphertext>;\n  ciphertextById?: Maybe<Ciphertext>;\n  /** @deprecated Use ciphertextById */\n  ciphertextByUniqueInput?: Maybe<Ciphertext>;\n  ciphertextsConnection: CiphertextsConnection;\n  legacyCommitmentCiphertexts: Array<LegacyCommitmentCiphertext>;\n  legacyCommitmentCiphertextById?: Maybe<LegacyCommitmentCiphertext>;\n  /** @deprecated Use legacyCommitmentCiphertextById */\n  legacyCommitmentCiphertextByUniqueInput?: Maybe<LegacyCommitmentCiphertext>;\n  legacyCommitmentCiphertextsConnection: LegacyCommitmentCiphertextsConnection;\n  commitmentCiphertexts: Array<CommitmentCiphertext>;\n  commitmentCiphertextById?: Maybe<CommitmentCiphertext>;\n  /** @deprecated Use commitmentCiphertextById */\n  commitmentCiphertextByUniqueInput?: Maybe<CommitmentCiphertext>;\n  commitmentCiphertextsConnection: CommitmentCiphertextsConnection;\n  legacyGeneratedCommitments: Array<LegacyGeneratedCommitment>;\n  legacyGeneratedCommitmentById?: Maybe<LegacyGeneratedCommitment>;\n  /** @deprecated Use legacyGeneratedCommitmentById */\n  legacyGeneratedCommitmentByUniqueInput?: Maybe<LegacyGeneratedCommitment>;\n  legacyGeneratedCommitmentsConnection: LegacyGeneratedCommitmentsConnection;\n  commitments: Array<Commitment>;\n  commitmentsConnection: CommitmentsConnection;\n  legacyEncryptedCommitments: Array<LegacyEncryptedCommitment>;\n  legacyEncryptedCommitmentById?: Maybe<LegacyEncryptedCommitment>;\n  /** @deprecated Use legacyEncryptedCommitmentById */\n  legacyEncryptedCommitmentByUniqueInput?: Maybe<LegacyEncryptedCommitment>;\n  legacyEncryptedCommitmentsConnection: LegacyEncryptedCommitmentsConnection;\n  shieldCommitments: Array<ShieldCommitment>;\n  shieldCommitmentById?: Maybe<ShieldCommitment>;\n  /** @deprecated Use shieldCommitmentById */\n  shieldCommitmentByUniqueInput?: Maybe<ShieldCommitment>;\n  shieldCommitmentsConnection: ShieldCommitmentsConnection;\n  transactCommitments: Array<TransactCommitment>;\n  transactCommitmentById?: Maybe<TransactCommitment>;\n  /** @deprecated Use transactCommitmentById */\n  transactCommitmentByUniqueInput?: Maybe<TransactCommitment>;\n  transactCommitmentsConnection: TransactCommitmentsConnection;\n  unshields: Array<Unshield>;\n  unshieldById?: Maybe<Unshield>;\n  /** @deprecated Use unshieldById */\n  unshieldByUniqueInput?: Maybe<Unshield>;\n  unshieldsConnection: UnshieldsConnection;\n  nullifiers: Array<Nullifier>;\n  nullifierById?: Maybe<Nullifier>;\n  /** @deprecated Use nullifierById */\n  nullifierByUniqueInput?: Maybe<Nullifier>;\n  nullifiersConnection: NullifiersConnection;\n  transactions: Array<Transaction>;\n  transactionById?: Maybe<Transaction>;\n  /** @deprecated Use transactionById */\n  transactionByUniqueInput?: Maybe<Transaction>;\n  transactionsConnection: TransactionsConnection;\n  verificationHashes: Array<VerificationHash>;\n  verificationHashById?: Maybe<VerificationHash>;\n  /** @deprecated Use verificationHashById */\n  verificationHashByUniqueInput?: Maybe<VerificationHash>;\n  verificationHashesConnection: VerificationHashesConnection;\n  commitmentBatchEventNews: Array<CommitmentBatchEventNew>;\n  commitmentBatchEventNewById?: Maybe<CommitmentBatchEventNew>;\n  /** @deprecated Use commitmentBatchEventNewById */\n  commitmentBatchEventNewByUniqueInput?: Maybe<CommitmentBatchEventNew>;\n  commitmentBatchEventNewsConnection: CommitmentBatchEventNewsConnection;\n  squidStatus?: Maybe<SquidStatus>;\n};\n\n\nexport type QuerytokensArgs = {\n  where?: InputMaybe<TokenWhereInput>;\n  orderBy?: InputMaybe<Array<TokenOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerytokenByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerytokenByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerytokensConnectionArgs = {\n  orderBy: Array<TokenOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<TokenWhereInput>;\n};\n\n\nexport type QuerycommitmentPreimagesArgs = {\n  where?: InputMaybe<CommitmentPreimageWhereInput>;\n  orderBy?: InputMaybe<Array<CommitmentPreimageOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerycommitmentPreimageByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerycommitmentPreimageByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerycommitmentPreimagesConnectionArgs = {\n  orderBy: Array<CommitmentPreimageOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<CommitmentPreimageWhereInput>;\n};\n\n\nexport type QueryciphertextsArgs = {\n  where?: InputMaybe<CiphertextWhereInput>;\n  orderBy?: InputMaybe<Array<CiphertextOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QueryciphertextByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QueryciphertextByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryciphertextsConnectionArgs = {\n  orderBy: Array<CiphertextOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<CiphertextWhereInput>;\n};\n\n\nexport type QuerylegacyCommitmentCiphertextsArgs = {\n  where?: InputMaybe<LegacyCommitmentCiphertextWhereInput>;\n  orderBy?: InputMaybe<Array<LegacyCommitmentCiphertextOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerylegacyCommitmentCiphertextByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerylegacyCommitmentCiphertextByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerylegacyCommitmentCiphertextsConnectionArgs = {\n  orderBy: Array<LegacyCommitmentCiphertextOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<LegacyCommitmentCiphertextWhereInput>;\n};\n\n\nexport type QuerycommitmentCiphertextsArgs = {\n  where?: InputMaybe<CommitmentCiphertextWhereInput>;\n  orderBy?: InputMaybe<Array<CommitmentCiphertextOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerycommitmentCiphertextByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerycommitmentCiphertextByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerycommitmentCiphertextsConnectionArgs = {\n  orderBy: Array<CommitmentCiphertextOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<CommitmentCiphertextWhereInput>;\n};\n\n\nexport type QuerylegacyGeneratedCommitmentsArgs = {\n  where?: InputMaybe<LegacyGeneratedCommitmentWhereInput>;\n  orderBy?: InputMaybe<Array<LegacyGeneratedCommitmentOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerylegacyGeneratedCommitmentByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerylegacyGeneratedCommitmentByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerylegacyGeneratedCommitmentsConnectionArgs = {\n  orderBy: Array<LegacyGeneratedCommitmentOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<LegacyGeneratedCommitmentWhereInput>;\n};\n\n\nexport type QuerycommitmentsArgs = {\n  where?: InputMaybe<CommitmentWhereInput>;\n  orderBy?: InputMaybe<Array<CommitmentOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerycommitmentsConnectionArgs = {\n  orderBy: Array<CommitmentOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<CommitmentWhereInput>;\n};\n\n\nexport type QuerylegacyEncryptedCommitmentsArgs = {\n  where?: InputMaybe<LegacyEncryptedCommitmentWhereInput>;\n  orderBy?: InputMaybe<Array<LegacyEncryptedCommitmentOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerylegacyEncryptedCommitmentByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerylegacyEncryptedCommitmentByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerylegacyEncryptedCommitmentsConnectionArgs = {\n  orderBy: Array<LegacyEncryptedCommitmentOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<LegacyEncryptedCommitmentWhereInput>;\n};\n\n\nexport type QueryshieldCommitmentsArgs = {\n  where?: InputMaybe<ShieldCommitmentWhereInput>;\n  orderBy?: InputMaybe<Array<ShieldCommitmentOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QueryshieldCommitmentByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QueryshieldCommitmentByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryshieldCommitmentsConnectionArgs = {\n  orderBy: Array<ShieldCommitmentOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<ShieldCommitmentWhereInput>;\n};\n\n\nexport type QuerytransactCommitmentsArgs = {\n  where?: InputMaybe<TransactCommitmentWhereInput>;\n  orderBy?: InputMaybe<Array<TransactCommitmentOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerytransactCommitmentByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerytransactCommitmentByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerytransactCommitmentsConnectionArgs = {\n  orderBy: Array<TransactCommitmentOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<TransactCommitmentWhereInput>;\n};\n\n\nexport type QueryunshieldsArgs = {\n  where?: InputMaybe<UnshieldWhereInput>;\n  orderBy?: InputMaybe<Array<UnshieldOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QueryunshieldByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QueryunshieldByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryunshieldsConnectionArgs = {\n  orderBy: Array<UnshieldOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<UnshieldWhereInput>;\n};\n\n\nexport type QuerynullifiersArgs = {\n  where?: InputMaybe<NullifierWhereInput>;\n  orderBy?: InputMaybe<Array<NullifierOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerynullifierByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerynullifierByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerynullifiersConnectionArgs = {\n  orderBy: Array<NullifierOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<NullifierWhereInput>;\n};\n\n\nexport type QuerytransactionsArgs = {\n  where?: InputMaybe<TransactionWhereInput>;\n  orderBy?: InputMaybe<Array<TransactionOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerytransactionByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerytransactionByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerytransactionsConnectionArgs = {\n  orderBy: Array<TransactionOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<TransactionWhereInput>;\n};\n\n\nexport type QueryverificationHashesArgs = {\n  where?: InputMaybe<VerificationHashWhereInput>;\n  orderBy?: InputMaybe<Array<VerificationHashOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QueryverificationHashByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QueryverificationHashByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QueryverificationHashesConnectionArgs = {\n  orderBy: Array<VerificationHashOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<VerificationHashWhereInput>;\n};\n\n\nexport type QuerycommitmentBatchEventNewsArgs = {\n  where?: InputMaybe<CommitmentBatchEventNewWhereInput>;\n  orderBy?: InputMaybe<Array<CommitmentBatchEventNewOrderByInput>>;\n  offset?: InputMaybe<Scalars['Int']>;\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\nexport type QuerycommitmentBatchEventNewByIdArgs = {\n  id: Scalars['String'];\n};\n\n\nexport type QuerycommitmentBatchEventNewByUniqueInputArgs = {\n  where: WhereIdInput;\n};\n\n\nexport type QuerycommitmentBatchEventNewsConnectionArgs = {\n  orderBy: Array<CommitmentBatchEventNewOrderByInput>;\n  after?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  where?: InputMaybe<CommitmentBatchEventNewWhereInput>;\n};\n\nexport type Token = {\n  id: Scalars['String'];\n  tokenType: TokenType;\n  tokenAddress: Scalars['Bytes'];\n  tokenSubID: Scalars['String'];\n};\n\nexport type TokenType =\n  | 'ERC20'\n  | 'ERC721'\n  | 'ERC1155';\n\nexport type TokenWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  tokenType_isNull?: InputMaybe<Scalars['Boolean']>;\n  tokenType_eq?: InputMaybe<TokenType>;\n  tokenType_not_eq?: InputMaybe<TokenType>;\n  tokenType_in?: InputMaybe<Array<TokenType>>;\n  tokenType_not_in?: InputMaybe<Array<TokenType>>;\n  tokenAddress_isNull?: InputMaybe<Scalars['Boolean']>;\n  tokenAddress_eq?: InputMaybe<Scalars['Bytes']>;\n  tokenAddress_not_eq?: InputMaybe<Scalars['Bytes']>;\n  tokenSubID_isNull?: InputMaybe<Scalars['Boolean']>;\n  tokenSubID_eq?: InputMaybe<Scalars['String']>;\n  tokenSubID_not_eq?: InputMaybe<Scalars['String']>;\n  tokenSubID_gt?: InputMaybe<Scalars['String']>;\n  tokenSubID_gte?: InputMaybe<Scalars['String']>;\n  tokenSubID_lt?: InputMaybe<Scalars['String']>;\n  tokenSubID_lte?: InputMaybe<Scalars['String']>;\n  tokenSubID_in?: InputMaybe<Array<Scalars['String']>>;\n  tokenSubID_not_in?: InputMaybe<Array<Scalars['String']>>;\n  tokenSubID_contains?: InputMaybe<Scalars['String']>;\n  tokenSubID_not_contains?: InputMaybe<Scalars['String']>;\n  tokenSubID_containsInsensitive?: InputMaybe<Scalars['String']>;\n  tokenSubID_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  tokenSubID_startsWith?: InputMaybe<Scalars['String']>;\n  tokenSubID_not_startsWith?: InputMaybe<Scalars['String']>;\n  tokenSubID_endsWith?: InputMaybe<Scalars['String']>;\n  tokenSubID_not_endsWith?: InputMaybe<Scalars['String']>;\n  AND?: InputMaybe<Array<TokenWhereInput>>;\n  OR?: InputMaybe<Array<TokenWhereInput>>;\n};\n\nexport type TokenOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'tokenType_ASC'\n  | 'tokenType_DESC'\n  | 'tokenType_ASC_NULLS_FIRST'\n  | 'tokenType_DESC_NULLS_LAST'\n  | 'tokenAddress_ASC'\n  | 'tokenAddress_DESC'\n  | 'tokenAddress_ASC_NULLS_FIRST'\n  | 'tokenAddress_DESC_NULLS_LAST'\n  | 'tokenSubID_ASC'\n  | 'tokenSubID_DESC'\n  | 'tokenSubID_ASC_NULLS_FIRST'\n  | 'tokenSubID_DESC_NULLS_LAST';\n\nexport type WhereIdInput = {\n  id: Scalars['String'];\n};\n\nexport type TokensConnection = {\n  edges: Array<TokenEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type TokenEdge = {\n  node: Token;\n  cursor: Scalars['String'];\n};\n\nexport type PageInfo = {\n  hasNextPage: Scalars['Boolean'];\n  hasPreviousPage: Scalars['Boolean'];\n  startCursor: Scalars['String'];\n  endCursor: Scalars['String'];\n};\n\nexport type CommitmentPreimage = {\n  id: Scalars['String'];\n  npk: Scalars['Bytes'];\n  token: Token;\n  value: Scalars['BigInt'];\n};\n\nexport type CommitmentPreimageWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  npk_isNull?: InputMaybe<Scalars['Boolean']>;\n  npk_eq?: InputMaybe<Scalars['Bytes']>;\n  npk_not_eq?: InputMaybe<Scalars['Bytes']>;\n  token_isNull?: InputMaybe<Scalars['Boolean']>;\n  token?: InputMaybe<TokenWhereInput>;\n  value_isNull?: InputMaybe<Scalars['Boolean']>;\n  value_eq?: InputMaybe<Scalars['BigInt']>;\n  value_not_eq?: InputMaybe<Scalars['BigInt']>;\n  value_gt?: InputMaybe<Scalars['BigInt']>;\n  value_gte?: InputMaybe<Scalars['BigInt']>;\n  value_lt?: InputMaybe<Scalars['BigInt']>;\n  value_lte?: InputMaybe<Scalars['BigInt']>;\n  value_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  value_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  AND?: InputMaybe<Array<CommitmentPreimageWhereInput>>;\n  OR?: InputMaybe<Array<CommitmentPreimageWhereInput>>;\n};\n\nexport type CommitmentPreimageOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'npk_ASC'\n  | 'npk_DESC'\n  | 'npk_ASC_NULLS_FIRST'\n  | 'npk_DESC_NULLS_LAST'\n  | 'token_id_ASC'\n  | 'token_id_DESC'\n  | 'token_id_ASC_NULLS_FIRST'\n  | 'token_id_DESC_NULLS_LAST'\n  | 'token_tokenType_ASC'\n  | 'token_tokenType_DESC'\n  | 'token_tokenType_ASC_NULLS_FIRST'\n  | 'token_tokenType_DESC_NULLS_LAST'\n  | 'token_tokenAddress_ASC'\n  | 'token_tokenAddress_DESC'\n  | 'token_tokenAddress_ASC_NULLS_FIRST'\n  | 'token_tokenAddress_DESC_NULLS_LAST'\n  | 'token_tokenSubID_ASC'\n  | 'token_tokenSubID_DESC'\n  | 'token_tokenSubID_ASC_NULLS_FIRST'\n  | 'token_tokenSubID_DESC_NULLS_LAST'\n  | 'value_ASC'\n  | 'value_DESC'\n  | 'value_ASC_NULLS_FIRST'\n  | 'value_DESC_NULLS_LAST';\n\nexport type CommitmentPreimagesConnection = {\n  edges: Array<CommitmentPreimageEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CommitmentPreimageEdge = {\n  node: CommitmentPreimage;\n  cursor: Scalars['String'];\n};\n\nexport type Ciphertext = {\n  id: Scalars['String'];\n  iv: Scalars['Bytes'];\n  tag: Scalars['Bytes'];\n  data: Array<Scalars['Bytes']>;\n};\n\nexport type CiphertextWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  iv_isNull?: InputMaybe<Scalars['Boolean']>;\n  iv_eq?: InputMaybe<Scalars['Bytes']>;\n  iv_not_eq?: InputMaybe<Scalars['Bytes']>;\n  tag_isNull?: InputMaybe<Scalars['Boolean']>;\n  tag_eq?: InputMaybe<Scalars['Bytes']>;\n  tag_not_eq?: InputMaybe<Scalars['Bytes']>;\n  data_isNull?: InputMaybe<Scalars['Boolean']>;\n  data_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  data_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  data_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  AND?: InputMaybe<Array<CiphertextWhereInput>>;\n  OR?: InputMaybe<Array<CiphertextWhereInput>>;\n};\n\nexport type CiphertextOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'iv_ASC'\n  | 'iv_DESC'\n  | 'iv_ASC_NULLS_FIRST'\n  | 'iv_DESC_NULLS_LAST'\n  | 'tag_ASC'\n  | 'tag_DESC'\n  | 'tag_ASC_NULLS_FIRST'\n  | 'tag_DESC_NULLS_LAST';\n\nexport type CiphertextsConnection = {\n  edges: Array<CiphertextEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CiphertextEdge = {\n  node: Ciphertext;\n  cursor: Scalars['String'];\n};\n\nexport type LegacyCommitmentCiphertext = {\n  id: Scalars['String'];\n  ciphertext: Ciphertext;\n  ephemeralKeys: Array<Scalars['Bytes']>;\n  memo: Array<Scalars['Bytes']>;\n};\n\nexport type LegacyCommitmentCiphertextWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  ciphertext_isNull?: InputMaybe<Scalars['Boolean']>;\n  ciphertext?: InputMaybe<CiphertextWhereInput>;\n  ephemeralKeys_isNull?: InputMaybe<Scalars['Boolean']>;\n  ephemeralKeys_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  ephemeralKeys_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  ephemeralKeys_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  memo_isNull?: InputMaybe<Scalars['Boolean']>;\n  memo_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  memo_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  memo_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  AND?: InputMaybe<Array<LegacyCommitmentCiphertextWhereInput>>;\n  OR?: InputMaybe<Array<LegacyCommitmentCiphertextWhereInput>>;\n};\n\nexport type LegacyCommitmentCiphertextOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'ciphertext_id_ASC'\n  | 'ciphertext_id_DESC'\n  | 'ciphertext_id_ASC_NULLS_FIRST'\n  | 'ciphertext_id_DESC_NULLS_LAST'\n  | 'ciphertext_iv_ASC'\n  | 'ciphertext_iv_DESC'\n  | 'ciphertext_iv_ASC_NULLS_FIRST'\n  | 'ciphertext_iv_DESC_NULLS_LAST'\n  | 'ciphertext_tag_ASC'\n  | 'ciphertext_tag_DESC'\n  | 'ciphertext_tag_ASC_NULLS_FIRST'\n  | 'ciphertext_tag_DESC_NULLS_LAST';\n\nexport type LegacyCommitmentCiphertextsConnection = {\n  edges: Array<LegacyCommitmentCiphertextEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type LegacyCommitmentCiphertextEdge = {\n  node: LegacyCommitmentCiphertext;\n  cursor: Scalars['String'];\n};\n\nexport type CommitmentCiphertext = {\n  id: Scalars['String'];\n  ciphertext: Ciphertext;\n  blindedSenderViewingKey: Scalars['Bytes'];\n  blindedReceiverViewingKey: Scalars['Bytes'];\n  annotationData: Scalars['Bytes'];\n  memo: Scalars['Bytes'];\n};\n\nexport type CommitmentCiphertextWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  ciphertext_isNull?: InputMaybe<Scalars['Boolean']>;\n  ciphertext?: InputMaybe<CiphertextWhereInput>;\n  blindedSenderViewingKey_isNull?: InputMaybe<Scalars['Boolean']>;\n  blindedSenderViewingKey_eq?: InputMaybe<Scalars['Bytes']>;\n  blindedSenderViewingKey_not_eq?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey_isNull?: InputMaybe<Scalars['Boolean']>;\n  blindedReceiverViewingKey_eq?: InputMaybe<Scalars['Bytes']>;\n  blindedReceiverViewingKey_not_eq?: InputMaybe<Scalars['Bytes']>;\n  annotationData_isNull?: InputMaybe<Scalars['Boolean']>;\n  annotationData_eq?: InputMaybe<Scalars['Bytes']>;\n  annotationData_not_eq?: InputMaybe<Scalars['Bytes']>;\n  memo_isNull?: InputMaybe<Scalars['Boolean']>;\n  memo_eq?: InputMaybe<Scalars['Bytes']>;\n  memo_not_eq?: InputMaybe<Scalars['Bytes']>;\n  AND?: InputMaybe<Array<CommitmentCiphertextWhereInput>>;\n  OR?: InputMaybe<Array<CommitmentCiphertextWhereInput>>;\n};\n\nexport type CommitmentCiphertextOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'ciphertext_id_ASC'\n  | 'ciphertext_id_DESC'\n  | 'ciphertext_id_ASC_NULLS_FIRST'\n  | 'ciphertext_id_DESC_NULLS_LAST'\n  | 'ciphertext_iv_ASC'\n  | 'ciphertext_iv_DESC'\n  | 'ciphertext_iv_ASC_NULLS_FIRST'\n  | 'ciphertext_iv_DESC_NULLS_LAST'\n  | 'ciphertext_tag_ASC'\n  | 'ciphertext_tag_DESC'\n  | 'ciphertext_tag_ASC_NULLS_FIRST'\n  | 'ciphertext_tag_DESC_NULLS_LAST'\n  | 'blindedSenderViewingKey_ASC'\n  | 'blindedSenderViewingKey_DESC'\n  | 'blindedSenderViewingKey_ASC_NULLS_FIRST'\n  | 'blindedSenderViewingKey_DESC_NULLS_LAST'\n  | 'blindedReceiverViewingKey_ASC'\n  | 'blindedReceiverViewingKey_DESC'\n  | 'blindedReceiverViewingKey_ASC_NULLS_FIRST'\n  | 'blindedReceiverViewingKey_DESC_NULLS_LAST'\n  | 'annotationData_ASC'\n  | 'annotationData_DESC'\n  | 'annotationData_ASC_NULLS_FIRST'\n  | 'annotationData_DESC_NULLS_LAST'\n  | 'memo_ASC'\n  | 'memo_DESC'\n  | 'memo_ASC_NULLS_FIRST'\n  | 'memo_DESC_NULLS_LAST';\n\nexport type CommitmentCiphertextsConnection = {\n  edges: Array<CommitmentCiphertextEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CommitmentCiphertextEdge = {\n  node: CommitmentCiphertext;\n  cursor: Scalars['String'];\n};\n\nexport type LegacyGeneratedCommitment = Commitment & {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  batchStartTreePosition: Scalars['Int'];\n  treePosition: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hash: Scalars['BigInt'];\n  preimage: CommitmentPreimage;\n  encryptedRandom: Array<Scalars['Bytes']>;\n};\n\nexport type Commitment = {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  batchStartTreePosition: Scalars['Int'];\n  treePosition: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hash: Scalars['BigInt'];\n};\n\nexport type CommitmentType =\n  | 'ShieldCommitment'\n  | 'TransactCommitment'\n  | 'LegacyGeneratedCommitment'\n  | 'LegacyEncryptedCommitment';\n\nexport type LegacyGeneratedCommitmentWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  treePosition_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_gt?: InputMaybe<Scalars['Int']>;\n  treePosition_gte?: InputMaybe<Scalars['Int']>;\n  treePosition_lt?: InputMaybe<Scalars['Int']>;\n  treePosition_lte?: InputMaybe<Scalars['Int']>;\n  treePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitmentType_eq?: InputMaybe<CommitmentType>;\n  commitmentType_not_eq?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']>;\n  hash_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_not_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_gt?: InputMaybe<Scalars['BigInt']>;\n  hash_gte?: InputMaybe<Scalars['BigInt']>;\n  hash_lt?: InputMaybe<Scalars['BigInt']>;\n  hash_lte?: InputMaybe<Scalars['BigInt']>;\n  hash_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  hash_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  preimage_isNull?: InputMaybe<Scalars['Boolean']>;\n  preimage?: InputMaybe<CommitmentPreimageWhereInput>;\n  encryptedRandom_isNull?: InputMaybe<Scalars['Boolean']>;\n  encryptedRandom_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedRandom_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedRandom_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  AND?: InputMaybe<Array<LegacyGeneratedCommitmentWhereInput>>;\n  OR?: InputMaybe<Array<LegacyGeneratedCommitmentWhereInput>>;\n};\n\nexport type LegacyGeneratedCommitmentOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST'\n  | 'treePosition_ASC'\n  | 'treePosition_DESC'\n  | 'treePosition_ASC_NULLS_FIRST'\n  | 'treePosition_DESC_NULLS_LAST'\n  | 'commitmentType_ASC'\n  | 'commitmentType_DESC'\n  | 'commitmentType_ASC_NULLS_FIRST'\n  | 'commitmentType_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_DESC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC_NULLS_LAST'\n  | 'preimage_id_ASC'\n  | 'preimage_id_DESC'\n  | 'preimage_id_ASC_NULLS_FIRST'\n  | 'preimage_id_DESC_NULLS_LAST'\n  | 'preimage_npk_ASC'\n  | 'preimage_npk_DESC'\n  | 'preimage_npk_ASC_NULLS_FIRST'\n  | 'preimage_npk_DESC_NULLS_LAST'\n  | 'preimage_value_ASC'\n  | 'preimage_value_DESC'\n  | 'preimage_value_ASC_NULLS_FIRST'\n  | 'preimage_value_DESC_NULLS_LAST';\n\nexport type LegacyGeneratedCommitmentsConnection = {\n  edges: Array<LegacyGeneratedCommitmentEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type LegacyGeneratedCommitmentEdge = {\n  node: LegacyGeneratedCommitment;\n  cursor: Scalars['String'];\n};\n\nexport type CommitmentWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  treePosition_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_gt?: InputMaybe<Scalars['Int']>;\n  treePosition_gte?: InputMaybe<Scalars['Int']>;\n  treePosition_lt?: InputMaybe<Scalars['Int']>;\n  treePosition_lte?: InputMaybe<Scalars['Int']>;\n  treePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitmentType_eq?: InputMaybe<CommitmentType>;\n  commitmentType_not_eq?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']>;\n  hash_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_not_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_gt?: InputMaybe<Scalars['BigInt']>;\n  hash_gte?: InputMaybe<Scalars['BigInt']>;\n  hash_lt?: InputMaybe<Scalars['BigInt']>;\n  hash_lte?: InputMaybe<Scalars['BigInt']>;\n  hash_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  hash_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  AND?: InputMaybe<Array<CommitmentWhereInput>>;\n  OR?: InputMaybe<Array<CommitmentWhereInput>>;\n};\n\nexport type CommitmentOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST'\n  | 'treePosition_ASC'\n  | 'treePosition_DESC'\n  | 'treePosition_ASC_NULLS_FIRST'\n  | 'treePosition_DESC_NULLS_LAST'\n  | 'commitmentType_ASC'\n  | 'commitmentType_DESC'\n  | 'commitmentType_ASC_NULLS_FIRST'\n  | 'commitmentType_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_DESC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC_NULLS_LAST'\n  | '_type_ASC'\n  | '_type_DESC';\n\nexport type CommitmentsConnection = {\n  edges: Array<CommitmentEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CommitmentEdge = {\n  node: Commitment;\n  cursor: Scalars['String'];\n};\n\nexport type LegacyEncryptedCommitment = Commitment & {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  batchStartTreePosition: Scalars['Int'];\n  treePosition: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hash: Scalars['BigInt'];\n  ciphertext: LegacyCommitmentCiphertext;\n};\n\nexport type LegacyEncryptedCommitmentWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  treePosition_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_gt?: InputMaybe<Scalars['Int']>;\n  treePosition_gte?: InputMaybe<Scalars['Int']>;\n  treePosition_lt?: InputMaybe<Scalars['Int']>;\n  treePosition_lte?: InputMaybe<Scalars['Int']>;\n  treePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitmentType_eq?: InputMaybe<CommitmentType>;\n  commitmentType_not_eq?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']>;\n  hash_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_not_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_gt?: InputMaybe<Scalars['BigInt']>;\n  hash_gte?: InputMaybe<Scalars['BigInt']>;\n  hash_lt?: InputMaybe<Scalars['BigInt']>;\n  hash_lte?: InputMaybe<Scalars['BigInt']>;\n  hash_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  hash_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  ciphertext_isNull?: InputMaybe<Scalars['Boolean']>;\n  ciphertext?: InputMaybe<LegacyCommitmentCiphertextWhereInput>;\n  AND?: InputMaybe<Array<LegacyEncryptedCommitmentWhereInput>>;\n  OR?: InputMaybe<Array<LegacyEncryptedCommitmentWhereInput>>;\n};\n\nexport type LegacyEncryptedCommitmentOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST'\n  | 'treePosition_ASC'\n  | 'treePosition_DESC'\n  | 'treePosition_ASC_NULLS_FIRST'\n  | 'treePosition_DESC_NULLS_LAST'\n  | 'commitmentType_ASC'\n  | 'commitmentType_DESC'\n  | 'commitmentType_ASC_NULLS_FIRST'\n  | 'commitmentType_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_DESC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC_NULLS_LAST'\n  | 'ciphertext_id_ASC'\n  | 'ciphertext_id_DESC'\n  | 'ciphertext_id_ASC_NULLS_FIRST'\n  | 'ciphertext_id_DESC_NULLS_LAST';\n\nexport type LegacyEncryptedCommitmentsConnection = {\n  edges: Array<LegacyEncryptedCommitmentEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type LegacyEncryptedCommitmentEdge = {\n  node: LegacyEncryptedCommitment;\n  cursor: Scalars['String'];\n};\n\nexport type ShieldCommitment = Commitment & {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  batchStartTreePosition: Scalars['Int'];\n  treePosition: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hash: Scalars['BigInt'];\n  preimage: CommitmentPreimage;\n  encryptedBundle: Array<Scalars['Bytes']>;\n  shieldKey: Scalars['Bytes'];\n  fee?: Maybe<Scalars['BigInt']>;\n};\n\nexport type ShieldCommitmentWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  treePosition_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_gt?: InputMaybe<Scalars['Int']>;\n  treePosition_gte?: InputMaybe<Scalars['Int']>;\n  treePosition_lt?: InputMaybe<Scalars['Int']>;\n  treePosition_lte?: InputMaybe<Scalars['Int']>;\n  treePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitmentType_eq?: InputMaybe<CommitmentType>;\n  commitmentType_not_eq?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']>;\n  hash_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_not_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_gt?: InputMaybe<Scalars['BigInt']>;\n  hash_gte?: InputMaybe<Scalars['BigInt']>;\n  hash_lt?: InputMaybe<Scalars['BigInt']>;\n  hash_lte?: InputMaybe<Scalars['BigInt']>;\n  hash_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  hash_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  preimage_isNull?: InputMaybe<Scalars['Boolean']>;\n  preimage?: InputMaybe<CommitmentPreimageWhereInput>;\n  encryptedBundle_isNull?: InputMaybe<Scalars['Boolean']>;\n  encryptedBundle_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedBundle_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  encryptedBundle_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  shieldKey_isNull?: InputMaybe<Scalars['Boolean']>;\n  shieldKey_eq?: InputMaybe<Scalars['Bytes']>;\n  shieldKey_not_eq?: InputMaybe<Scalars['Bytes']>;\n  fee_isNull?: InputMaybe<Scalars['Boolean']>;\n  fee_eq?: InputMaybe<Scalars['BigInt']>;\n  fee_not_eq?: InputMaybe<Scalars['BigInt']>;\n  fee_gt?: InputMaybe<Scalars['BigInt']>;\n  fee_gte?: InputMaybe<Scalars['BigInt']>;\n  fee_lt?: InputMaybe<Scalars['BigInt']>;\n  fee_lte?: InputMaybe<Scalars['BigInt']>;\n  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  AND?: InputMaybe<Array<ShieldCommitmentWhereInput>>;\n  OR?: InputMaybe<Array<ShieldCommitmentWhereInput>>;\n};\n\nexport type ShieldCommitmentOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST'\n  | 'treePosition_ASC'\n  | 'treePosition_DESC'\n  | 'treePosition_ASC_NULLS_FIRST'\n  | 'treePosition_DESC_NULLS_LAST'\n  | 'commitmentType_ASC'\n  | 'commitmentType_DESC'\n  | 'commitmentType_ASC_NULLS_FIRST'\n  | 'commitmentType_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_DESC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC_NULLS_LAST'\n  | 'preimage_id_ASC'\n  | 'preimage_id_DESC'\n  | 'preimage_id_ASC_NULLS_FIRST'\n  | 'preimage_id_DESC_NULLS_LAST'\n  | 'preimage_npk_ASC'\n  | 'preimage_npk_DESC'\n  | 'preimage_npk_ASC_NULLS_FIRST'\n  | 'preimage_npk_DESC_NULLS_LAST'\n  | 'preimage_value_ASC'\n  | 'preimage_value_DESC'\n  | 'preimage_value_ASC_NULLS_FIRST'\n  | 'preimage_value_DESC_NULLS_LAST'\n  | 'shieldKey_ASC'\n  | 'shieldKey_DESC'\n  | 'shieldKey_ASC_NULLS_FIRST'\n  | 'shieldKey_DESC_NULLS_LAST'\n  | 'fee_ASC'\n  | 'fee_DESC'\n  | 'fee_ASC_NULLS_FIRST'\n  | 'fee_DESC_NULLS_LAST';\n\nexport type ShieldCommitmentsConnection = {\n  edges: Array<ShieldCommitmentEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type ShieldCommitmentEdge = {\n  node: ShieldCommitment;\n  cursor: Scalars['String'];\n};\n\nexport type TransactCommitment = Commitment & {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  batchStartTreePosition: Scalars['Int'];\n  treePosition: Scalars['Int'];\n  commitmentType: CommitmentType;\n  hash: Scalars['BigInt'];\n  ciphertext: CommitmentCiphertext;\n};\n\nexport type TransactCommitmentWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['Int']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  treePosition_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_not_eq?: InputMaybe<Scalars['Int']>;\n  treePosition_gt?: InputMaybe<Scalars['Int']>;\n  treePosition_gte?: InputMaybe<Scalars['Int']>;\n  treePosition_lt?: InputMaybe<Scalars['Int']>;\n  treePosition_lte?: InputMaybe<Scalars['Int']>;\n  treePosition_in?: InputMaybe<Array<Scalars['Int']>>;\n  treePosition_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  commitmentType_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitmentType_eq?: InputMaybe<CommitmentType>;\n  commitmentType_not_eq?: InputMaybe<CommitmentType>;\n  commitmentType_in?: InputMaybe<Array<CommitmentType>>;\n  commitmentType_not_in?: InputMaybe<Array<CommitmentType>>;\n  hash_isNull?: InputMaybe<Scalars['Boolean']>;\n  hash_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_not_eq?: InputMaybe<Scalars['BigInt']>;\n  hash_gt?: InputMaybe<Scalars['BigInt']>;\n  hash_gte?: InputMaybe<Scalars['BigInt']>;\n  hash_lt?: InputMaybe<Scalars['BigInt']>;\n  hash_lte?: InputMaybe<Scalars['BigInt']>;\n  hash_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  hash_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  ciphertext_isNull?: InputMaybe<Scalars['Boolean']>;\n  ciphertext?: InputMaybe<CommitmentCiphertextWhereInput>;\n  AND?: InputMaybe<Array<TransactCommitmentWhereInput>>;\n  OR?: InputMaybe<Array<TransactCommitmentWhereInput>>;\n};\n\nexport type TransactCommitmentOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST'\n  | 'treePosition_ASC'\n  | 'treePosition_DESC'\n  | 'treePosition_ASC_NULLS_FIRST'\n  | 'treePosition_DESC_NULLS_LAST'\n  | 'commitmentType_ASC'\n  | 'commitmentType_DESC'\n  | 'commitmentType_ASC_NULLS_FIRST'\n  | 'commitmentType_DESC_NULLS_LAST'\n  | 'hash_ASC'\n  | 'hash_DESC'\n  | 'hash_ASC_NULLS_FIRST'\n  | 'hash_DESC_NULLS_LAST'\n  | 'ciphertext_id_ASC'\n  | 'ciphertext_id_DESC'\n  | 'ciphertext_id_ASC_NULLS_FIRST'\n  | 'ciphertext_id_DESC_NULLS_LAST'\n  | 'ciphertext_blindedSenderViewingKey_ASC'\n  | 'ciphertext_blindedSenderViewingKey_DESC'\n  | 'ciphertext_blindedSenderViewingKey_ASC_NULLS_FIRST'\n  | 'ciphertext_blindedSenderViewingKey_DESC_NULLS_LAST'\n  | 'ciphertext_blindedReceiverViewingKey_ASC'\n  | 'ciphertext_blindedReceiverViewingKey_DESC'\n  | 'ciphertext_blindedReceiverViewingKey_ASC_NULLS_FIRST'\n  | 'ciphertext_blindedReceiverViewingKey_DESC_NULLS_LAST'\n  | 'ciphertext_annotationData_ASC'\n  | 'ciphertext_annotationData_DESC'\n  | 'ciphertext_annotationData_ASC_NULLS_FIRST'\n  | 'ciphertext_annotationData_DESC_NULLS_LAST'\n  | 'ciphertext_memo_ASC'\n  | 'ciphertext_memo_DESC'\n  | 'ciphertext_memo_ASC_NULLS_FIRST'\n  | 'ciphertext_memo_DESC_NULLS_LAST';\n\nexport type TransactCommitmentsConnection = {\n  edges: Array<TransactCommitmentEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type TransactCommitmentEdge = {\n  node: TransactCommitment;\n  cursor: Scalars['String'];\n};\n\nexport type Unshield = {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  to: Scalars['Bytes'];\n  token: Token;\n  amount: Scalars['BigInt'];\n  fee: Scalars['BigInt'];\n  eventLogIndex: Scalars['BigInt'];\n};\n\nexport type UnshieldWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  to_isNull?: InputMaybe<Scalars['Boolean']>;\n  to_eq?: InputMaybe<Scalars['Bytes']>;\n  to_not_eq?: InputMaybe<Scalars['Bytes']>;\n  token_isNull?: InputMaybe<Scalars['Boolean']>;\n  token?: InputMaybe<TokenWhereInput>;\n  amount_isNull?: InputMaybe<Scalars['Boolean']>;\n  amount_eq?: InputMaybe<Scalars['BigInt']>;\n  amount_not_eq?: InputMaybe<Scalars['BigInt']>;\n  amount_gt?: InputMaybe<Scalars['BigInt']>;\n  amount_gte?: InputMaybe<Scalars['BigInt']>;\n  amount_lt?: InputMaybe<Scalars['BigInt']>;\n  amount_lte?: InputMaybe<Scalars['BigInt']>;\n  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  fee_isNull?: InputMaybe<Scalars['Boolean']>;\n  fee_eq?: InputMaybe<Scalars['BigInt']>;\n  fee_not_eq?: InputMaybe<Scalars['BigInt']>;\n  fee_gt?: InputMaybe<Scalars['BigInt']>;\n  fee_gte?: InputMaybe<Scalars['BigInt']>;\n  fee_lt?: InputMaybe<Scalars['BigInt']>;\n  fee_lte?: InputMaybe<Scalars['BigInt']>;\n  fee_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  fee_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  eventLogIndex_isNull?: InputMaybe<Scalars['Boolean']>;\n  eventLogIndex_eq?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_not_eq?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_gt?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_gte?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_lt?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_lte?: InputMaybe<Scalars['BigInt']>;\n  eventLogIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  eventLogIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  AND?: InputMaybe<Array<UnshieldWhereInput>>;\n  OR?: InputMaybe<Array<UnshieldWhereInput>>;\n};\n\nexport type UnshieldOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'to_ASC'\n  | 'to_DESC'\n  | 'to_ASC_NULLS_FIRST'\n  | 'to_DESC_NULLS_LAST'\n  | 'token_id_ASC'\n  | 'token_id_DESC'\n  | 'token_id_ASC_NULLS_FIRST'\n  | 'token_id_DESC_NULLS_LAST'\n  | 'token_tokenType_ASC'\n  | 'token_tokenType_DESC'\n  | 'token_tokenType_ASC_NULLS_FIRST'\n  | 'token_tokenType_DESC_NULLS_LAST'\n  | 'token_tokenAddress_ASC'\n  | 'token_tokenAddress_DESC'\n  | 'token_tokenAddress_ASC_NULLS_FIRST'\n  | 'token_tokenAddress_DESC_NULLS_LAST'\n  | 'token_tokenSubID_ASC'\n  | 'token_tokenSubID_DESC'\n  | 'token_tokenSubID_ASC_NULLS_FIRST'\n  | 'token_tokenSubID_DESC_NULLS_LAST'\n  | 'amount_ASC'\n  | 'amount_DESC'\n  | 'amount_ASC_NULLS_FIRST'\n  | 'amount_DESC_NULLS_LAST'\n  | 'fee_ASC'\n  | 'fee_DESC'\n  | 'fee_ASC_NULLS_FIRST'\n  | 'fee_DESC_NULLS_LAST'\n  | 'eventLogIndex_ASC'\n  | 'eventLogIndex_DESC'\n  | 'eventLogIndex_ASC_NULLS_FIRST'\n  | 'eventLogIndex_DESC_NULLS_LAST';\n\nexport type UnshieldsConnection = {\n  edges: Array<UnshieldEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type UnshieldEdge = {\n  node: Unshield;\n  cursor: Scalars['String'];\n};\n\nexport type Nullifier = {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  treeNumber: Scalars['Int'];\n  nullifier: Scalars['Bytes'];\n};\n\nexport type NullifierWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['Int']>;\n  treeNumber_gt?: InputMaybe<Scalars['Int']>;\n  treeNumber_gte?: InputMaybe<Scalars['Int']>;\n  treeNumber_lt?: InputMaybe<Scalars['Int']>;\n  treeNumber_lte?: InputMaybe<Scalars['Int']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['Int']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['Int']>>;\n  nullifier_isNull?: InputMaybe<Scalars['Boolean']>;\n  nullifier_eq?: InputMaybe<Scalars['Bytes']>;\n  nullifier_not_eq?: InputMaybe<Scalars['Bytes']>;\n  AND?: InputMaybe<Array<NullifierWhereInput>>;\n  OR?: InputMaybe<Array<NullifierWhereInput>>;\n};\n\nexport type NullifierOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'nullifier_ASC'\n  | 'nullifier_DESC'\n  | 'nullifier_ASC_NULLS_FIRST'\n  | 'nullifier_DESC_NULLS_LAST';\n\nexport type NullifiersConnection = {\n  edges: Array<NullifierEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type NullifierEdge = {\n  node: Nullifier;\n  cursor: Scalars['String'];\n};\n\nexport type Transaction = TransactionInterface & {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  merkleRoot: Scalars['Bytes'];\n  nullifiers: Array<Scalars['Bytes']>;\n  commitments: Array<Scalars['Bytes']>;\n  boundParamsHash: Scalars['Bytes'];\n  hasUnshield: Scalars['Boolean'];\n  utxoTreeIn: Scalars['BigInt'];\n  utxoTreeOut: Scalars['BigInt'];\n  utxoBatchStartPositionOut: Scalars['BigInt'];\n  unshieldToken: Token;\n  unshieldToAddress: Scalars['Bytes'];\n  unshieldValue: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  verificationHash: Scalars['Bytes'];\n};\n\nexport type TransactionInterface = {\n  id: Scalars['String'];\n  blockNumber: Scalars['BigInt'];\n  transactionHash: Scalars['Bytes'];\n  merkleRoot: Scalars['Bytes'];\n  nullifiers: Array<Scalars['Bytes']>;\n  commitments: Array<Scalars['Bytes']>;\n  boundParamsHash: Scalars['Bytes'];\n  hasUnshield: Scalars['Boolean'];\n  utxoTreeIn: Scalars['BigInt'];\n  utxoTreeOut: Scalars['BigInt'];\n  utxoBatchStartPositionOut: Scalars['BigInt'];\n  unshieldToken: Token;\n  unshieldToAddress: Scalars['Bytes'];\n  unshieldValue: Scalars['BigInt'];\n  blockTimestamp: Scalars['BigInt'];\n  verificationHash: Scalars['Bytes'];\n};\n\nexport type TransactionWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  blockNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  transactionHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  transactionHash_eq?: InputMaybe<Scalars['Bytes']>;\n  transactionHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  merkleRoot_isNull?: InputMaybe<Scalars['Boolean']>;\n  merkleRoot_eq?: InputMaybe<Scalars['Bytes']>;\n  merkleRoot_not_eq?: InputMaybe<Scalars['Bytes']>;\n  nullifiers_isNull?: InputMaybe<Scalars['Boolean']>;\n  nullifiers_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  nullifiers_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  nullifiers_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments_isNull?: InputMaybe<Scalars['Boolean']>;\n  commitments_containsAll?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments_containsAny?: InputMaybe<Array<Scalars['Bytes']>>;\n  commitments_containsNone?: InputMaybe<Array<Scalars['Bytes']>>;\n  boundParamsHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  boundParamsHash_eq?: InputMaybe<Scalars['Bytes']>;\n  boundParamsHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  hasUnshield_isNull?: InputMaybe<Scalars['Boolean']>;\n  hasUnshield_eq?: InputMaybe<Scalars['Boolean']>;\n  hasUnshield_not_eq?: InputMaybe<Scalars['Boolean']>;\n  utxoTreeIn_isNull?: InputMaybe<Scalars['Boolean']>;\n  utxoTreeIn_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_not_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_gt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_gte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_lt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_lte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeIn_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoTreeIn_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoTreeOut_isNull?: InputMaybe<Scalars['Boolean']>;\n  utxoTreeOut_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_not_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_gt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_gte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_lt?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_lte?: InputMaybe<Scalars['BigInt']>;\n  utxoTreeOut_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoTreeOut_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoBatchStartPositionOut_isNull?: InputMaybe<Scalars['Boolean']>;\n  utxoBatchStartPositionOut_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_not_eq?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_gt?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_gte?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_lt?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_lte?: InputMaybe<Scalars['BigInt']>;\n  utxoBatchStartPositionOut_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  utxoBatchStartPositionOut_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  unshieldToken_isNull?: InputMaybe<Scalars['Boolean']>;\n  unshieldToken?: InputMaybe<TokenWhereInput>;\n  unshieldToAddress_isNull?: InputMaybe<Scalars['Boolean']>;\n  unshieldToAddress_eq?: InputMaybe<Scalars['Bytes']>;\n  unshieldToAddress_not_eq?: InputMaybe<Scalars['Bytes']>;\n  unshieldValue_isNull?: InputMaybe<Scalars['Boolean']>;\n  unshieldValue_eq?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_not_eq?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_gt?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_gte?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_lt?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_lte?: InputMaybe<Scalars['BigInt']>;\n  unshieldValue_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  unshieldValue_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_isNull?: InputMaybe<Scalars['Boolean']>;\n  blockTimestamp_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_not_eq?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_gte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lt?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_lte?: InputMaybe<Scalars['BigInt']>;\n  blockTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  blockTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  verificationHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  verificationHash_eq?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  AND?: InputMaybe<Array<TransactionWhereInput>>;\n  OR?: InputMaybe<Array<TransactionWhereInput>>;\n};\n\nexport type TransactionOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'blockNumber_ASC'\n  | 'blockNumber_DESC'\n  | 'blockNumber_ASC_NULLS_FIRST'\n  | 'blockNumber_DESC_NULLS_LAST'\n  | 'transactionHash_ASC'\n  | 'transactionHash_DESC'\n  | 'transactionHash_ASC_NULLS_FIRST'\n  | 'transactionHash_DESC_NULLS_LAST'\n  | 'merkleRoot_ASC'\n  | 'merkleRoot_DESC'\n  | 'merkleRoot_ASC_NULLS_FIRST'\n  | 'merkleRoot_DESC_NULLS_LAST'\n  | 'boundParamsHash_ASC'\n  | 'boundParamsHash_DESC'\n  | 'boundParamsHash_ASC_NULLS_FIRST'\n  | 'boundParamsHash_DESC_NULLS_LAST'\n  | 'hasUnshield_ASC'\n  | 'hasUnshield_DESC'\n  | 'hasUnshield_ASC_NULLS_FIRST'\n  | 'hasUnshield_DESC_NULLS_LAST'\n  | 'utxoTreeIn_ASC'\n  | 'utxoTreeIn_DESC'\n  | 'utxoTreeIn_ASC_NULLS_FIRST'\n  | 'utxoTreeIn_DESC_NULLS_LAST'\n  | 'utxoTreeOut_ASC'\n  | 'utxoTreeOut_DESC'\n  | 'utxoTreeOut_ASC_NULLS_FIRST'\n  | 'utxoTreeOut_DESC_NULLS_LAST'\n  | 'utxoBatchStartPositionOut_ASC'\n  | 'utxoBatchStartPositionOut_DESC'\n  | 'utxoBatchStartPositionOut_ASC_NULLS_FIRST'\n  | 'utxoBatchStartPositionOut_DESC_NULLS_LAST'\n  | 'unshieldToken_id_ASC'\n  | 'unshieldToken_id_DESC'\n  | 'unshieldToken_id_ASC_NULLS_FIRST'\n  | 'unshieldToken_id_DESC_NULLS_LAST'\n  | 'unshieldToken_tokenType_ASC'\n  | 'unshieldToken_tokenType_DESC'\n  | 'unshieldToken_tokenType_ASC_NULLS_FIRST'\n  | 'unshieldToken_tokenType_DESC_NULLS_LAST'\n  | 'unshieldToken_tokenAddress_ASC'\n  | 'unshieldToken_tokenAddress_DESC'\n  | 'unshieldToken_tokenAddress_ASC_NULLS_FIRST'\n  | 'unshieldToken_tokenAddress_DESC_NULLS_LAST'\n  | 'unshieldToken_tokenSubID_ASC'\n  | 'unshieldToken_tokenSubID_DESC'\n  | 'unshieldToken_tokenSubID_ASC_NULLS_FIRST'\n  | 'unshieldToken_tokenSubID_DESC_NULLS_LAST'\n  | 'unshieldToAddress_ASC'\n  | 'unshieldToAddress_DESC'\n  | 'unshieldToAddress_ASC_NULLS_FIRST'\n  | 'unshieldToAddress_DESC_NULLS_LAST'\n  | 'unshieldValue_ASC'\n  | 'unshieldValue_DESC'\n  | 'unshieldValue_ASC_NULLS_FIRST'\n  | 'unshieldValue_DESC_NULLS_LAST'\n  | 'blockTimestamp_ASC'\n  | 'blockTimestamp_DESC'\n  | 'blockTimestamp_ASC_NULLS_FIRST'\n  | 'blockTimestamp_DESC_NULLS_LAST'\n  | 'verificationHash_ASC'\n  | 'verificationHash_DESC'\n  | 'verificationHash_ASC_NULLS_FIRST'\n  | 'verificationHash_DESC_NULLS_LAST';\n\nexport type TransactionsConnection = {\n  edges: Array<TransactionEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type TransactionEdge = {\n  node: Transaction;\n  cursor: Scalars['String'];\n};\n\nexport type VerificationHash = {\n  id: Scalars['String'];\n  verificationHash: Scalars['Bytes'];\n};\n\nexport type VerificationHashWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  verificationHash_isNull?: InputMaybe<Scalars['Boolean']>;\n  verificationHash_eq?: InputMaybe<Scalars['Bytes']>;\n  verificationHash_not_eq?: InputMaybe<Scalars['Bytes']>;\n  AND?: InputMaybe<Array<VerificationHashWhereInput>>;\n  OR?: InputMaybe<Array<VerificationHashWhereInput>>;\n};\n\nexport type VerificationHashOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'verificationHash_ASC'\n  | 'verificationHash_DESC'\n  | 'verificationHash_ASC_NULLS_FIRST'\n  | 'verificationHash_DESC_NULLS_LAST';\n\nexport type VerificationHashesConnection = {\n  edges: Array<VerificationHashEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type VerificationHashEdge = {\n  node: VerificationHash;\n  cursor: Scalars['String'];\n};\n\nexport type CommitmentBatchEventNew = {\n  id: Scalars['String'];\n  treeNumber: Scalars['BigInt'];\n  batchStartTreePosition: Scalars['BigInt'];\n};\n\nexport type CommitmentBatchEventNewWhereInput = {\n  id_isNull?: InputMaybe<Scalars['Boolean']>;\n  id_eq?: InputMaybe<Scalars['String']>;\n  id_not_eq?: InputMaybe<Scalars['String']>;\n  id_gt?: InputMaybe<Scalars['String']>;\n  id_gte?: InputMaybe<Scalars['String']>;\n  id_lt?: InputMaybe<Scalars['String']>;\n  id_lte?: InputMaybe<Scalars['String']>;\n  id_in?: InputMaybe<Array<Scalars['String']>>;\n  id_not_in?: InputMaybe<Array<Scalars['String']>>;\n  id_contains?: InputMaybe<Scalars['String']>;\n  id_not_contains?: InputMaybe<Scalars['String']>;\n  id_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_not_containsInsensitive?: InputMaybe<Scalars['String']>;\n  id_startsWith?: InputMaybe<Scalars['String']>;\n  id_not_startsWith?: InputMaybe<Scalars['String']>;\n  id_endsWith?: InputMaybe<Scalars['String']>;\n  id_not_endsWith?: InputMaybe<Scalars['String']>;\n  treeNumber_isNull?: InputMaybe<Scalars['Boolean']>;\n  treeNumber_eq?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_not_eq?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_gt?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_gte?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_lt?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_lte?: InputMaybe<Scalars['BigInt']>;\n  treeNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  treeNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  batchStartTreePosition_isNull?: InputMaybe<Scalars['Boolean']>;\n  batchStartTreePosition_eq?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_not_eq?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_gt?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_gte?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_lt?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_lte?: InputMaybe<Scalars['BigInt']>;\n  batchStartTreePosition_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  batchStartTreePosition_not_in?: InputMaybe<Array<Scalars['BigInt']>>;\n  AND?: InputMaybe<Array<CommitmentBatchEventNewWhereInput>>;\n  OR?: InputMaybe<Array<CommitmentBatchEventNewWhereInput>>;\n};\n\nexport type CommitmentBatchEventNewOrderByInput =\n  | 'id_ASC'\n  | 'id_DESC'\n  | 'id_ASC_NULLS_FIRST'\n  | 'id_DESC_NULLS_LAST'\n  | 'treeNumber_ASC'\n  | 'treeNumber_DESC'\n  | 'treeNumber_ASC_NULLS_FIRST'\n  | 'treeNumber_DESC_NULLS_LAST'\n  | 'batchStartTreePosition_ASC'\n  | 'batchStartTreePosition_DESC'\n  | 'batchStartTreePosition_ASC_NULLS_FIRST'\n  | 'batchStartTreePosition_DESC_NULLS_LAST';\n\nexport type CommitmentBatchEventNewsConnection = {\n  edges: Array<CommitmentBatchEventNewEdge>;\n  pageInfo: PageInfo;\n  totalCount: Scalars['Int'];\n};\n\nexport type CommitmentBatchEventNewEdge = {\n  node: CommitmentBatchEventNew;\n  cursor: Scalars['String'];\n};\n\nexport type SquidStatus = {\n  /** The height of the processed part of the chain */\n  height?: Maybe<Scalars['Int']>;\n};\n\nexport type WithIndex<TObject> = TObject & Record<string, any>;\nexport type ResolversObject<TObject> = WithIndex<TObject>;\n\nexport type ResolverTypeWrapper<T> = Promise<T> | T;\n\n\nexport type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\n\nexport type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {\n  fragment: string;\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\n\nexport type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {\n  selectionSet: string | ((fieldNode: FieldNode) => SelectionSetNode);\n  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;\n};\nexport type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;\nexport type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =\n  | ResolverFn<TResult, TParent, TContext, TArgs>\n  | ResolverWithResolve<TResult, TParent, TContext, TArgs>\n  | StitchingResolver<TResult, TParent, TContext, TArgs>;\n\nexport type ResolverFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => Promise<TResult> | TResult;\n\nexport type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;\n\nexport type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n\nexport interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {\n  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;\n  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;\n}\n\nexport interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {\n  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;\n  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;\n}\n\nexport type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =\n  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>\n  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;\n\nexport type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =\n  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)\n  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;\n\nexport type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (\n  parent: TParent,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => Maybe<TTypes> | Promise<Maybe<TTypes>>;\n\nexport type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;\n\nexport type NextResolverFn<T> = () => Promise<T>;\n\nexport type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (\n  next: NextResolverFn<TResult>,\n  parent: TParent,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo\n) => TResult | Promise<TResult>;\n\n/** Mapping between all available schema types and the resolvers types */\nexport type ResolversTypes = ResolversObject<{\n  Query: ResolverTypeWrapper<{}>;\n  Int: ResolverTypeWrapper<Scalars['Int']>;\n  String: ResolverTypeWrapper<Scalars['String']>;\n  Token: ResolverTypeWrapper<Token>;\n  TokenType: TokenType;\n  Bytes: ResolverTypeWrapper<Scalars['Bytes']>;\n  TokenWhereInput: TokenWhereInput;\n  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;\n  TokenOrderByInput: TokenOrderByInput;\n  WhereIdInput: WhereIdInput;\n  TokensConnection: ResolverTypeWrapper<TokensConnection>;\n  TokenEdge: ResolverTypeWrapper<TokenEdge>;\n  PageInfo: ResolverTypeWrapper<PageInfo>;\n  CommitmentPreimage: ResolverTypeWrapper<CommitmentPreimage>;\n  BigInt: ResolverTypeWrapper<Scalars['BigInt']>;\n  CommitmentPreimageWhereInput: CommitmentPreimageWhereInput;\n  CommitmentPreimageOrderByInput: CommitmentPreimageOrderByInput;\n  CommitmentPreimagesConnection: ResolverTypeWrapper<CommitmentPreimagesConnection>;\n  CommitmentPreimageEdge: ResolverTypeWrapper<CommitmentPreimageEdge>;\n  Ciphertext: ResolverTypeWrapper<Ciphertext>;\n  CiphertextWhereInput: CiphertextWhereInput;\n  CiphertextOrderByInput: CiphertextOrderByInput;\n  CiphertextsConnection: ResolverTypeWrapper<CiphertextsConnection>;\n  CiphertextEdge: ResolverTypeWrapper<CiphertextEdge>;\n  LegacyCommitmentCiphertext: ResolverTypeWrapper<LegacyCommitmentCiphertext>;\n  LegacyCommitmentCiphertextWhereInput: LegacyCommitmentCiphertextWhereInput;\n  LegacyCommitmentCiphertextOrderByInput: LegacyCommitmentCiphertextOrderByInput;\n  LegacyCommitmentCiphertextsConnection: ResolverTypeWrapper<LegacyCommitmentCiphertextsConnection>;\n  LegacyCommitmentCiphertextEdge: ResolverTypeWrapper<LegacyCommitmentCiphertextEdge>;\n  CommitmentCiphertext: ResolverTypeWrapper<CommitmentCiphertext>;\n  CommitmentCiphertextWhereInput: CommitmentCiphertextWhereInput;\n  CommitmentCiphertextOrderByInput: CommitmentCiphertextOrderByInput;\n  CommitmentCiphertextsConnection: ResolverTypeWrapper<CommitmentCiphertextsConnection>;\n  CommitmentCiphertextEdge: ResolverTypeWrapper<CommitmentCiphertextEdge>;\n  LegacyGeneratedCommitment: ResolverTypeWrapper<LegacyGeneratedCommitment>;\n  Commitment: ResolversTypes['LegacyGeneratedCommitment'] | ResolversTypes['LegacyEncryptedCommitment'] | ResolversTypes['ShieldCommitment'] | ResolversTypes['TransactCommitment'];\n  CommitmentType: CommitmentType;\n  LegacyGeneratedCommitmentWhereInput: LegacyGeneratedCommitmentWhereInput;\n  LegacyGeneratedCommitmentOrderByInput: LegacyGeneratedCommitmentOrderByInput;\n  LegacyGeneratedCommitmentsConnection: ResolverTypeWrapper<LegacyGeneratedCommitmentsConnection>;\n  LegacyGeneratedCommitmentEdge: ResolverTypeWrapper<LegacyGeneratedCommitmentEdge>;\n  CommitmentWhereInput: CommitmentWhereInput;\n  CommitmentOrderByInput: CommitmentOrderByInput;\n  CommitmentsConnection: ResolverTypeWrapper<CommitmentsConnection>;\n  CommitmentEdge: ResolverTypeWrapper<CommitmentEdge>;\n  LegacyEncryptedCommitment: ResolverTypeWrapper<LegacyEncryptedCommitment>;\n  LegacyEncryptedCommitmentWhereInput: LegacyEncryptedCommitmentWhereInput;\n  LegacyEncryptedCommitmentOrderByInput: LegacyEncryptedCommitmentOrderByInput;\n  LegacyEncryptedCommitmentsConnection: ResolverTypeWrapper<LegacyEncryptedCommitmentsConnection>;\n  LegacyEncryptedCommitmentEdge: ResolverTypeWrapper<LegacyEncryptedCommitmentEdge>;\n  ShieldCommitment: ResolverTypeWrapper<ShieldCommitment>;\n  ShieldCommitmentWhereInput: ShieldCommitmentWhereInput;\n  ShieldCommitmentOrderByInput: ShieldCommitmentOrderByInput;\n  ShieldCommitmentsConnection: ResolverTypeWrapper<ShieldCommitmentsConnection>;\n  ShieldCommitmentEdge: ResolverTypeWrapper<ShieldCommitmentEdge>;\n  TransactCommitment: ResolverTypeWrapper<TransactCommitment>;\n  TransactCommitmentWhereInput: TransactCommitmentWhereInput;\n  TransactCommitmentOrderByInput: TransactCommitmentOrderByInput;\n  TransactCommitmentsConnection: ResolverTypeWrapper<TransactCommitmentsConnection>;\n  TransactCommitmentEdge: ResolverTypeWrapper<TransactCommitmentEdge>;\n  Unshield: ResolverTypeWrapper<Unshield>;\n  UnshieldWhereInput: UnshieldWhereInput;\n  UnshieldOrderByInput: UnshieldOrderByInput;\n  UnshieldsConnection: ResolverTypeWrapper<UnshieldsConnection>;\n  UnshieldEdge: ResolverTypeWrapper<UnshieldEdge>;\n  Nullifier: ResolverTypeWrapper<Nullifier>;\n  NullifierWhereInput: NullifierWhereInput;\n  NullifierOrderByInput: NullifierOrderByInput;\n  NullifiersConnection: ResolverTypeWrapper<NullifiersConnection>;\n  NullifierEdge: ResolverTypeWrapper<NullifierEdge>;\n  Transaction: ResolverTypeWrapper<Transaction>;\n  TransactionInterface: ResolversTypes['Transaction'];\n  TransactionWhereInput: TransactionWhereInput;\n  TransactionOrderByInput: TransactionOrderByInput;\n  TransactionsConnection: ResolverTypeWrapper<TransactionsConnection>;\n  TransactionEdge: ResolverTypeWrapper<TransactionEdge>;\n  VerificationHash: ResolverTypeWrapper<VerificationHash>;\n  VerificationHashWhereInput: VerificationHashWhereInput;\n  VerificationHashOrderByInput: VerificationHashOrderByInput;\n  VerificationHashesConnection: ResolverTypeWrapper<VerificationHashesConnection>;\n  VerificationHashEdge: ResolverTypeWrapper<VerificationHashEdge>;\n  CommitmentBatchEventNew: ResolverTypeWrapper<CommitmentBatchEventNew>;\n  CommitmentBatchEventNewWhereInput: CommitmentBatchEventNewWhereInput;\n  CommitmentBatchEventNewOrderByInput: CommitmentBatchEventNewOrderByInput;\n  CommitmentBatchEventNewsConnection: ResolverTypeWrapper<CommitmentBatchEventNewsConnection>;\n  CommitmentBatchEventNewEdge: ResolverTypeWrapper<CommitmentBatchEventNewEdge>;\n  SquidStatus: ResolverTypeWrapper<SquidStatus>;\n}>;\n\n/** Mapping between all available schema types and the resolvers parents */\nexport type ResolversParentTypes = ResolversObject<{\n  Query: {};\n  Int: Scalars['Int'];\n  String: Scalars['String'];\n  Token: Token;\n  Bytes: Scalars['Bytes'];\n  TokenWhereInput: TokenWhereInput;\n  Boolean: Scalars['Boolean'];\n  WhereIdInput: WhereIdInput;\n  TokensConnection: TokensConnection;\n  TokenEdge: TokenEdge;\n  PageInfo: PageInfo;\n  CommitmentPreimage: CommitmentPreimage;\n  BigInt: Scalars['BigInt'];\n  CommitmentPreimageWhereInput: CommitmentPreimageWhereInput;\n  CommitmentPreimagesConnection: CommitmentPreimagesConnection;\n  CommitmentPreimageEdge: CommitmentPreimageEdge;\n  Ciphertext: Ciphertext;\n  CiphertextWhereInput: CiphertextWhereInput;\n  CiphertextsConnection: CiphertextsConnection;\n  CiphertextEdge: CiphertextEdge;\n  LegacyCommitmentCiphertext: LegacyCommitmentCiphertext;\n  LegacyCommitmentCiphertextWhereInput: LegacyCommitmentCiphertextWhereInput;\n  LegacyCommitmentCiphertextsConnection: LegacyCommitmentCiphertextsConnection;\n  LegacyCommitmentCiphertextEdge: LegacyCommitmentCiphertextEdge;\n  CommitmentCiphertext: CommitmentCiphertext;\n  CommitmentCiphertextWhereInput: CommitmentCiphertextWhereInput;\n  CommitmentCiphertextsConnection: CommitmentCiphertextsConnection;\n  CommitmentCiphertextEdge: CommitmentCiphertextEdge;\n  LegacyGeneratedCommitment: LegacyGeneratedCommitment;\n  Commitment: ResolversParentTypes['LegacyGeneratedCommitment'] | ResolversParentTypes['LegacyEncryptedCommitment'] | ResolversParentTypes['ShieldCommitment'] | ResolversParentTypes['TransactCommitment'];\n  LegacyGeneratedCommitmentWhereInput: LegacyGeneratedCommitmentWhereInput;\n  LegacyGeneratedCommitmentsConnection: LegacyGeneratedCommitmentsConnection;\n  LegacyGeneratedCommitmentEdge: LegacyGeneratedCommitmentEdge;\n  CommitmentWhereInput: CommitmentWhereInput;\n  CommitmentsConnection: CommitmentsConnection;\n  CommitmentEdge: CommitmentEdge;\n  LegacyEncryptedCommitment: LegacyEncryptedCommitment;\n  LegacyEncryptedCommitmentWhereInput: LegacyEncryptedCommitmentWhereInput;\n  LegacyEncryptedCommitmentsConnection: LegacyEncryptedCommitmentsConnection;\n  LegacyEncryptedCommitmentEdge: LegacyEncryptedCommitmentEdge;\n  ShieldCommitment: ShieldCommitment;\n  ShieldCommitmentWhereInput: ShieldCommitmentWhereInput;\n  ShieldCommitmentsConnection: ShieldCommitmentsConnection;\n  ShieldCommitmentEdge: ShieldCommitmentEdge;\n  TransactCommitment: TransactCommitment;\n  TransactCommitmentWhereInput: TransactCommitmentWhereInput;\n  TransactCommitmentsConnection: TransactCommitmentsConnection;\n  TransactCommitmentEdge: TransactCommitmentEdge;\n  Unshield: Unshield;\n  UnshieldWhereInput: UnshieldWhereInput;\n  UnshieldsConnection: UnshieldsConnection;\n  UnshieldEdge: UnshieldEdge;\n  Nullifier: Nullifier;\n  NullifierWhereInput: NullifierWhereInput;\n  NullifiersConnection: NullifiersConnection;\n  NullifierEdge: NullifierEdge;\n  Transaction: Transaction;\n  TransactionInterface: ResolversParentTypes['Transaction'];\n  TransactionWhereInput: TransactionWhereInput;\n  TransactionsConnection: TransactionsConnection;\n  TransactionEdge: TransactionEdge;\n  VerificationHash: VerificationHash;\n  VerificationHashWhereInput: VerificationHashWhereInput;\n  VerificationHashesConnection: VerificationHashesConnection;\n  VerificationHashEdge: VerificationHashEdge;\n  CommitmentBatchEventNew: CommitmentBatchEventNew;\n  CommitmentBatchEventNewWhereInput: CommitmentBatchEventNewWhereInput;\n  CommitmentBatchEventNewsConnection: CommitmentBatchEventNewsConnection;\n  CommitmentBatchEventNewEdge: CommitmentBatchEventNewEdge;\n  SquidStatus: SquidStatus;\n}>;\n\nexport type QueryResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = ResolversObject<{\n  tokens?: Resolver<Array<ResolversTypes['Token']>, ParentType, ContextType, Partial<QuerytokensArgs>>;\n  tokenById?: Resolver<Maybe<ResolversTypes['Token']>, ParentType, ContextType, RequireFields<QuerytokenByIdArgs, 'id'>>;\n  tokenByUniqueInput?: Resolver<Maybe<ResolversTypes['Token']>, ParentType, ContextType, RequireFields<QuerytokenByUniqueInputArgs, 'where'>>;\n  tokensConnection?: Resolver<ResolversTypes['TokensConnection'], ParentType, ContextType, RequireFields<QuerytokensConnectionArgs, 'orderBy'>>;\n  commitmentPreimages?: Resolver<Array<ResolversTypes['CommitmentPreimage']>, ParentType, ContextType, Partial<QuerycommitmentPreimagesArgs>>;\n  commitmentPreimageById?: Resolver<Maybe<ResolversTypes['CommitmentPreimage']>, ParentType, ContextType, RequireFields<QuerycommitmentPreimageByIdArgs, 'id'>>;\n  commitmentPreimageByUniqueInput?: Resolver<Maybe<ResolversTypes['CommitmentPreimage']>, ParentType, ContextType, RequireFields<QuerycommitmentPreimageByUniqueInputArgs, 'where'>>;\n  commitmentPreimagesConnection?: Resolver<ResolversTypes['CommitmentPreimagesConnection'], ParentType, ContextType, RequireFields<QuerycommitmentPreimagesConnectionArgs, 'orderBy'>>;\n  ciphertexts?: Resolver<Array<ResolversTypes['Ciphertext']>, ParentType, ContextType, Partial<QueryciphertextsArgs>>;\n  ciphertextById?: Resolver<Maybe<ResolversTypes['Ciphertext']>, ParentType, ContextType, RequireFields<QueryciphertextByIdArgs, 'id'>>;\n  ciphertextByUniqueInput?: Resolver<Maybe<ResolversTypes['Ciphertext']>, ParentType, ContextType, RequireFields<QueryciphertextByUniqueInputArgs, 'where'>>;\n  ciphertextsConnection?: Resolver<ResolversTypes['CiphertextsConnection'], ParentType, ContextType, RequireFields<QueryciphertextsConnectionArgs, 'orderBy'>>;\n  legacyCommitmentCiphertexts?: Resolver<Array<ResolversTypes['LegacyCommitmentCiphertext']>, ParentType, ContextType, Partial<QuerylegacyCommitmentCiphertextsArgs>>;\n  legacyCommitmentCiphertextById?: Resolver<Maybe<ResolversTypes['LegacyCommitmentCiphertext']>, ParentType, ContextType, RequireFields<QuerylegacyCommitmentCiphertextByIdArgs, 'id'>>;\n  legacyCommitmentCiphertextByUniqueInput?: Resolver<Maybe<ResolversTypes['LegacyCommitmentCiphertext']>, ParentType, ContextType, RequireFields<QuerylegacyCommitmentCiphertextByUniqueInputArgs, 'where'>>;\n  legacyCommitmentCiphertextsConnection?: Resolver<ResolversTypes['LegacyCommitmentCiphertextsConnection'], ParentType, ContextType, RequireFields<QuerylegacyCommitmentCiphertextsConnectionArgs, 'orderBy'>>;\n  commitmentCiphertexts?: Resolver<Array<ResolversTypes['CommitmentCiphertext']>, ParentType, ContextType, Partial<QuerycommitmentCiphertextsArgs>>;\n  commitmentCiphertextById?: Resolver<Maybe<ResolversTypes['CommitmentCiphertext']>, ParentType, ContextType, RequireFields<QuerycommitmentCiphertextByIdArgs, 'id'>>;\n  commitmentCiphertextByUniqueInput?: Resolver<Maybe<ResolversTypes['CommitmentCiphertext']>, ParentType, ContextType, RequireFields<QuerycommitmentCiphertextByUniqueInputArgs, 'where'>>;\n  commitmentCiphertextsConnection?: Resolver<ResolversTypes['CommitmentCiphertextsConnection'], ParentType, ContextType, RequireFields<QuerycommitmentCiphertextsConnectionArgs, 'orderBy'>>;\n  legacyGeneratedCommitments?: Resolver<Array<ResolversTypes['LegacyGeneratedCommitment']>, ParentType, ContextType, Partial<QuerylegacyGeneratedCommitmentsArgs>>;\n  legacyGeneratedCommitmentById?: Resolver<Maybe<ResolversTypes['LegacyGeneratedCommitment']>, ParentType, ContextType, RequireFields<QuerylegacyGeneratedCommitmentByIdArgs, 'id'>>;\n  legacyGeneratedCommitmentByUniqueInput?: Resolver<Maybe<ResolversTypes['LegacyGeneratedCommitment']>, ParentType, ContextType, RequireFields<QuerylegacyGeneratedCommitmentByUniqueInputArgs, 'where'>>;\n  legacyGeneratedCommitmentsConnection?: Resolver<ResolversTypes['LegacyGeneratedCommitmentsConnection'], ParentType, ContextType, RequireFields<QuerylegacyGeneratedCommitmentsConnectionArgs, 'orderBy'>>;\n  commitments?: Resolver<Array<ResolversTypes['Commitment']>, ParentType, ContextType, Partial<QuerycommitmentsArgs>>;\n  commitmentsConnection?: Resolver<ResolversTypes['CommitmentsConnection'], ParentType, ContextType, RequireFields<QuerycommitmentsConnectionArgs, 'orderBy'>>;\n  legacyEncryptedCommitments?: Resolver<Array<ResolversTypes['LegacyEncryptedCommitment']>, ParentType, ContextType, Partial<QuerylegacyEncryptedCommitmentsArgs>>;\n  legacyEncryptedCommitmentById?: Resolver<Maybe<ResolversTypes['LegacyEncryptedCommitment']>, ParentType, ContextType, RequireFields<QuerylegacyEncryptedCommitmentByIdArgs, 'id'>>;\n  legacyEncryptedCommitmentByUniqueInput?: Resolver<Maybe<ResolversTypes['LegacyEncryptedCommitment']>, ParentType, ContextType, RequireFields<QuerylegacyEncryptedCommitmentByUniqueInputArgs, 'where'>>;\n  legacyEncryptedCommitmentsConnection?: Resolver<ResolversTypes['LegacyEncryptedCommitmentsConnection'], ParentType, ContextType, RequireFields<QuerylegacyEncryptedCommitmentsConnectionArgs, 'orderBy'>>;\n  shieldCommitments?: Resolver<Array<ResolversTypes['ShieldCommitment']>, ParentType, ContextType, Partial<QueryshieldCommitmentsArgs>>;\n  shieldCommitmentById?: Resolver<Maybe<ResolversTypes['ShieldCommitment']>, ParentType, ContextType, RequireFields<QueryshieldCommitmentByIdArgs, 'id'>>;\n  shieldCommitmentByUniqueInput?: Resolver<Maybe<ResolversTypes['ShieldCommitment']>, ParentType, ContextType, RequireFields<QueryshieldCommitmentByUniqueInputArgs, 'where'>>;\n  shieldCommitmentsConnection?: Resolver<ResolversTypes['ShieldCommitmentsConnection'], ParentType, ContextType, RequireFields<QueryshieldCommitmentsConnectionArgs, 'orderBy'>>;\n  transactCommitments?: Resolver<Array<ResolversTypes['TransactCommitment']>, ParentType, ContextType, Partial<QuerytransactCommitmentsArgs>>;\n  transactCommitmentById?: Resolver<Maybe<ResolversTypes['TransactCommitment']>, ParentType, ContextType, RequireFields<QuerytransactCommitmentByIdArgs, 'id'>>;\n  transactCommitmentByUniqueInput?: Resolver<Maybe<ResolversTypes['TransactCommitment']>, ParentType, ContextType, RequireFields<QuerytransactCommitmentByUniqueInputArgs, 'where'>>;\n  transactCommitmentsConnection?: Resolver<ResolversTypes['TransactCommitmentsConnection'], ParentType, ContextType, RequireFields<QuerytransactCommitmentsConnectionArgs, 'orderBy'>>;\n  unshields?: Resolver<Array<ResolversTypes['Unshield']>, ParentType, ContextType, Partial<QueryunshieldsArgs>>;\n  unshieldById?: Resolver<Maybe<ResolversTypes['Unshield']>, ParentType, ContextType, RequireFields<QueryunshieldByIdArgs, 'id'>>;\n  unshieldByUniqueInput?: Resolver<Maybe<ResolversTypes['Unshield']>, ParentType, ContextType, RequireFields<QueryunshieldByUniqueInputArgs, 'where'>>;\n  unshieldsConnection?: Resolver<ResolversTypes['UnshieldsConnection'], ParentType, ContextType, RequireFields<QueryunshieldsConnectionArgs, 'orderBy'>>;\n  nullifiers?: Resolver<Array<ResolversTypes['Nullifier']>, ParentType, ContextType, Partial<QuerynullifiersArgs>>;\n  nullifierById?: Resolver<Maybe<ResolversTypes['Nullifier']>, ParentType, ContextType, RequireFields<QuerynullifierByIdArgs, 'id'>>;\n  nullifierByUniqueInput?: Resolver<Maybe<ResolversTypes['Nullifier']>, ParentType, ContextType, RequireFields<QuerynullifierByUniqueInputArgs, 'where'>>;\n  nullifiersConnection?: Resolver<ResolversTypes['NullifiersConnection'], ParentType, ContextType, RequireFields<QuerynullifiersConnectionArgs, 'orderBy'>>;\n  transactions?: Resolver<Array<ResolversTypes['Transaction']>, ParentType, ContextType, Partial<QuerytransactionsArgs>>;\n  transactionById?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<QuerytransactionByIdArgs, 'id'>>;\n  transactionByUniqueInput?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<QuerytransactionByUniqueInputArgs, 'where'>>;\n  transactionsConnection?: Resolver<ResolversTypes['TransactionsConnection'], ParentType, ContextType, RequireFields<QuerytransactionsConnectionArgs, 'orderBy'>>;\n  verificationHashes?: Resolver<Array<ResolversTypes['VerificationHash']>, ParentType, ContextType, Partial<QueryverificationHashesArgs>>;\n  verificationHashById?: Resolver<Maybe<ResolversTypes['VerificationHash']>, ParentType, ContextType, RequireFields<QueryverificationHashByIdArgs, 'id'>>;\n  verificationHashByUniqueInput?: Resolver<Maybe<ResolversTypes['VerificationHash']>, ParentType, ContextType, RequireFields<QueryverificationHashByUniqueInputArgs, 'where'>>;\n  verificationHashesConnection?: Resolver<ResolversTypes['VerificationHashesConnection'], ParentType, ContextType, RequireFields<QueryverificationHashesConnectionArgs, 'orderBy'>>;\n  commitmentBatchEventNews?: Resolver<Array<ResolversTypes['CommitmentBatchEventNew']>, ParentType, ContextType, Partial<QuerycommitmentBatchEventNewsArgs>>;\n  commitmentBatchEventNewById?: Resolver<Maybe<ResolversTypes['CommitmentBatchEventNew']>, ParentType, ContextType, RequireFields<QuerycommitmentBatchEventNewByIdArgs, 'id'>>;\n  commitmentBatchEventNewByUniqueInput?: Resolver<Maybe<ResolversTypes['CommitmentBatchEventNew']>, ParentType, ContextType, RequireFields<QuerycommitmentBatchEventNewByUniqueInputArgs, 'where'>>;\n  commitmentBatchEventNewsConnection?: Resolver<ResolversTypes['CommitmentBatchEventNewsConnection'], ParentType, ContextType, RequireFields<QuerycommitmentBatchEventNewsConnectionArgs, 'orderBy'>>;\n  squidStatus?: Resolver<Maybe<ResolversTypes['SquidStatus']>, ParentType, ContextType>;\n}>;\n\nexport type TokenResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Token'] = ResolversParentTypes['Token']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  tokenType?: Resolver<ResolversTypes['TokenType'], ParentType, ContextType>;\n  tokenAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  tokenSubID?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport interface BytesScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Bytes'], any> {\n  name: 'Bytes';\n}\n\nexport type TokensConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TokensConnection'] = ResolversParentTypes['TokensConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['TokenEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TokenEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TokenEdge'] = ResolversParentTypes['TokenEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type PageInfoResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = ResolversObject<{\n  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;\n  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;\n  startCursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  endCursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentPreimageResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentPreimage'] = ResolversParentTypes['CommitmentPreimage']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  npk?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  token?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  value?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {\n  name: 'BigInt';\n}\n\nexport type CommitmentPreimagesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentPreimagesConnection'] = ResolversParentTypes['CommitmentPreimagesConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['CommitmentPreimageEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentPreimageEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentPreimageEdge'] = ResolversParentTypes['CommitmentPreimageEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['CommitmentPreimage'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CiphertextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Ciphertext'] = ResolversParentTypes['Ciphertext']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  iv?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  tag?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  data?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CiphertextsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CiphertextsConnection'] = ResolversParentTypes['CiphertextsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['CiphertextEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CiphertextEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CiphertextEdge'] = ResolversParentTypes['CiphertextEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Ciphertext'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyCommitmentCiphertextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyCommitmentCiphertext'] = ResolversParentTypes['LegacyCommitmentCiphertext']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  ciphertext?: Resolver<ResolversTypes['Ciphertext'], ParentType, ContextType>;\n  ephemeralKeys?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  memo?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyCommitmentCiphertextsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyCommitmentCiphertextsConnection'] = ResolversParentTypes['LegacyCommitmentCiphertextsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['LegacyCommitmentCiphertextEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyCommitmentCiphertextEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyCommitmentCiphertextEdge'] = ResolversParentTypes['LegacyCommitmentCiphertextEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['LegacyCommitmentCiphertext'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentCiphertextResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentCiphertext'] = ResolversParentTypes['CommitmentCiphertext']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  ciphertext?: Resolver<ResolversTypes['Ciphertext'], ParentType, ContextType>;\n  blindedSenderViewingKey?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  blindedReceiverViewingKey?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  annotationData?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  memo?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentCiphertextsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentCiphertextsConnection'] = ResolversParentTypes['CommitmentCiphertextsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['CommitmentCiphertextEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentCiphertextEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentCiphertextEdge'] = ResolversParentTypes['CommitmentCiphertextEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['CommitmentCiphertext'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyGeneratedCommitmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyGeneratedCommitment'] = ResolversParentTypes['LegacyGeneratedCommitment']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  treePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<ResolversTypes['CommitmentType'], ParentType, ContextType>;\n  hash?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  preimage?: Resolver<ResolversTypes['CommitmentPreimage'], ParentType, ContextType>;\n  encryptedRandom?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Commitment'] = ResolversParentTypes['Commitment']> = ResolversObject<{\n  __resolveType: TypeResolveFn<'LegacyGeneratedCommitment' | 'LegacyEncryptedCommitment' | 'ShieldCommitment' | 'TransactCommitment', ParentType, ContextType>;\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  treePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<ResolversTypes['CommitmentType'], ParentType, ContextType>;\n  hash?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n}>;\n\nexport type LegacyGeneratedCommitmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyGeneratedCommitmentsConnection'] = ResolversParentTypes['LegacyGeneratedCommitmentsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['LegacyGeneratedCommitmentEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyGeneratedCommitmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyGeneratedCommitmentEdge'] = ResolversParentTypes['LegacyGeneratedCommitmentEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['LegacyGeneratedCommitment'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentsConnection'] = ResolversParentTypes['CommitmentsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['CommitmentEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentEdge'] = ResolversParentTypes['CommitmentEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Commitment'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyEncryptedCommitmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyEncryptedCommitment'] = ResolversParentTypes['LegacyEncryptedCommitment']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  treePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<ResolversTypes['CommitmentType'], ParentType, ContextType>;\n  hash?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  ciphertext?: Resolver<ResolversTypes['LegacyCommitmentCiphertext'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyEncryptedCommitmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyEncryptedCommitmentsConnection'] = ResolversParentTypes['LegacyEncryptedCommitmentsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['LegacyEncryptedCommitmentEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type LegacyEncryptedCommitmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['LegacyEncryptedCommitmentEdge'] = ResolversParentTypes['LegacyEncryptedCommitmentEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['LegacyEncryptedCommitment'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type ShieldCommitmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ShieldCommitment'] = ResolversParentTypes['ShieldCommitment']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  treePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<ResolversTypes['CommitmentType'], ParentType, ContextType>;\n  hash?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  preimage?: Resolver<ResolversTypes['CommitmentPreimage'], ParentType, ContextType>;\n  encryptedBundle?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  shieldKey?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  fee?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type ShieldCommitmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ShieldCommitmentsConnection'] = ResolversParentTypes['ShieldCommitmentsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['ShieldCommitmentEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type ShieldCommitmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['ShieldCommitmentEdge'] = ResolversParentTypes['ShieldCommitmentEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['ShieldCommitment'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactCommitmentResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactCommitment'] = ResolversParentTypes['TransactCommitment']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  treePosition?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  commitmentType?: Resolver<ResolversTypes['CommitmentType'], ParentType, ContextType>;\n  hash?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  ciphertext?: Resolver<ResolversTypes['CommitmentCiphertext'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactCommitmentsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactCommitmentsConnection'] = ResolversParentTypes['TransactCommitmentsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['TransactCommitmentEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactCommitmentEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactCommitmentEdge'] = ResolversParentTypes['TransactCommitmentEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['TransactCommitment'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type UnshieldResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Unshield'] = ResolversParentTypes['Unshield']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  to?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  token?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  amount?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  fee?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  eventLogIndex?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type UnshieldsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnshieldsConnection'] = ResolversParentTypes['UnshieldsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['UnshieldEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type UnshieldEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['UnshieldEdge'] = ResolversParentTypes['UnshieldEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Unshield'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type NullifierResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Nullifier'] = ResolversParentTypes['Nullifier']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  nullifier?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type NullifiersConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['NullifiersConnection'] = ResolversParentTypes['NullifiersConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['NullifierEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type NullifierEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['NullifierEdge'] = ResolversParentTypes['NullifierEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Nullifier'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['Transaction'] = ResolversParentTypes['Transaction']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  merkleRoot?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  nullifiers?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  commitments?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  boundParamsHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  hasUnshield?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;\n  utxoTreeIn?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  utxoTreeOut?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  utxoBatchStartPositionOut?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  unshieldToken?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  unshieldToAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  unshieldValue?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  verificationHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactionInterfaceResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactionInterface'] = ResolversParentTypes['TransactionInterface']> = ResolversObject<{\n  __resolveType: TypeResolveFn<'Transaction', ParentType, ContextType>;\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  blockNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  transactionHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  merkleRoot?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  nullifiers?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  commitments?: Resolver<Array<ResolversTypes['Bytes']>, ParentType, ContextType>;\n  boundParamsHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  hasUnshield?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;\n  utxoTreeIn?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  utxoTreeOut?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  utxoBatchStartPositionOut?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  unshieldToken?: Resolver<ResolversTypes['Token'], ParentType, ContextType>;\n  unshieldToAddress?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  unshieldValue?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  blockTimestamp?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  verificationHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n}>;\n\nexport type TransactionsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactionsConnection'] = ResolversParentTypes['TransactionsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['TransactionEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type TransactionEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['TransactionEdge'] = ResolversParentTypes['TransactionEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type VerificationHashResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VerificationHash'] = ResolversParentTypes['VerificationHash']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  verificationHash?: Resolver<ResolversTypes['Bytes'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type VerificationHashesConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VerificationHashesConnection'] = ResolversParentTypes['VerificationHashesConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['VerificationHashEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type VerificationHashEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['VerificationHashEdge'] = ResolversParentTypes['VerificationHashEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['VerificationHash'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentBatchEventNewResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentBatchEventNew'] = ResolversParentTypes['CommitmentBatchEventNew']> = ResolversObject<{\n  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  treeNumber?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  batchStartTreePosition?: Resolver<ResolversTypes['BigInt'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentBatchEventNewsConnectionResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentBatchEventNewsConnection'] = ResolversParentTypes['CommitmentBatchEventNewsConnection']> = ResolversObject<{\n  edges?: Resolver<Array<ResolversTypes['CommitmentBatchEventNewEdge']>, ParentType, ContextType>;\n  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;\n  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type CommitmentBatchEventNewEdgeResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['CommitmentBatchEventNewEdge'] = ResolversParentTypes['CommitmentBatchEventNewEdge']> = ResolversObject<{\n  node?: Resolver<ResolversTypes['CommitmentBatchEventNew'], ParentType, ContextType>;\n  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type SquidStatusResolvers<ContextType = MeshContext, ParentType extends ResolversParentTypes['SquidStatus'] = ResolversParentTypes['SquidStatus']> = ResolversObject<{\n  height?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;\n  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;\n}>;\n\nexport type Resolvers<ContextType = MeshContext> = ResolversObject<{\n  Query?: QueryResolvers<ContextType>;\n  Token?: TokenResolvers<ContextType>;\n  Bytes?: GraphQLScalarType;\n  TokensConnection?: TokensConnectionResolvers<ContextType>;\n  TokenEdge?: TokenEdgeResolvers<ContextType>;\n  PageInfo?: PageInfoResolvers<ContextType>;\n  CommitmentPreimage?: CommitmentPreimageResolvers<ContextType>;\n  BigInt?: GraphQLScalarType;\n  CommitmentPreimagesConnection?: CommitmentPreimagesConnectionResolvers<ContextType>;\n  CommitmentPreimageEdge?: CommitmentPreimageEdgeResolvers<ContextType>;\n  Ciphertext?: CiphertextResolvers<ContextType>;\n  CiphertextsConnection?: CiphertextsConnectionResolvers<ContextType>;\n  CiphertextEdge?: CiphertextEdgeResolvers<ContextType>;\n  LegacyCommitmentCiphertext?: LegacyCommitmentCiphertextResolvers<ContextType>;\n  LegacyCommitmentCiphertextsConnection?: LegacyCommitmentCiphertextsConnectionResolvers<ContextType>;\n  LegacyCommitmentCiphertextEdge?: LegacyCommitmentCiphertextEdgeResolvers<ContextType>;\n  CommitmentCiphertext?: CommitmentCiphertextResolvers<ContextType>;\n  CommitmentCiphertextsConnection?: CommitmentCiphertextsConnectionResolvers<ContextType>;\n  CommitmentCiphertextEdge?: CommitmentCiphertextEdgeResolvers<ContextType>;\n  LegacyGeneratedCommitment?: LegacyGeneratedCommitmentResolvers<ContextType>;\n  Commitment?: CommitmentResolvers<ContextType>;\n  LegacyGeneratedCommitmentsConnection?: LegacyGeneratedCommitmentsConnectionResolvers<ContextType>;\n  LegacyGeneratedCommitmentEdge?: LegacyGeneratedCommitmentEdgeResolvers<ContextType>;\n  CommitmentsConnection?: CommitmentsConnectionResolvers<ContextType>;\n  CommitmentEdge?: CommitmentEdgeResolvers<ContextType>;\n  LegacyEncryptedCommitment?: LegacyEncryptedCommitmentResolvers<ContextType>;\n  LegacyEncryptedCommitmentsConnection?: LegacyEncryptedCommitmentsConnectionResolvers<ContextType>;\n  LegacyEncryptedCommitmentEdge?: LegacyEncryptedCommitmentEdgeResolvers<ContextType>;\n  ShieldCommitment?: ShieldCommitmentResolvers<ContextType>;\n  ShieldCommitmentsConnection?: ShieldCommitmentsConnectionResolvers<ContextType>;\n  ShieldCommitmentEdge?: ShieldCommitmentEdgeResolvers<ContextType>;\n  TransactCommitment?: TransactCommitmentResolvers<ContextType>;\n  TransactCommitmentsConnection?: TransactCommitmentsConnectionResolvers<ContextType>;\n  TransactCommitmentEdge?: TransactCommitmentEdgeResolvers<ContextType>;\n  Unshield?: UnshieldResolvers<ContextType>;\n  UnshieldsConnection?: UnshieldsConnectionResolvers<ContextType>;\n  UnshieldEdge?: UnshieldEdgeResolvers<ContextType>;\n  Nullifier?: NullifierResolvers<ContextType>;\n  NullifiersConnection?: NullifiersConnectionResolvers<ContextType>;\n  NullifierEdge?: NullifierEdgeResolvers<ContextType>;\n  Transaction?: TransactionResolvers<ContextType>;\n  TransactionInterface?: TransactionInterfaceResolvers<ContextType>;\n  TransactionsConnection?: TransactionsConnectionResolvers<ContextType>;\n  TransactionEdge?: TransactionEdgeResolvers<ContextType>;\n  VerificationHash?: VerificationHashResolvers<ContextType>;\n  VerificationHashesConnection?: VerificationHashesConnectionResolvers<ContextType>;\n  VerificationHashEdge?: VerificationHashEdgeResolvers<ContextType>;\n  CommitmentBatchEventNew?: CommitmentBatchEventNewResolvers<ContextType>;\n  CommitmentBatchEventNewsConnection?: CommitmentBatchEventNewsConnectionResolvers<ContextType>;\n  CommitmentBatchEventNewEdge?: CommitmentBatchEventNewEdgeResolvers<ContextType>;\n  SquidStatus?: SquidStatusResolvers<ContextType>;\n}>;\n\n\nexport type MeshContext = TxsEthereumTypes.Context & TxsSepoliaTypes.Context & TxsArbitrumTypes.Context & TxsBscTypes.Context & TxsMaticTypes.Context & BaseMeshContext;\n\n\nconst baseDir = pathModule.join(typeof __dirname === 'string' ? __dirname : '/', '..');\n\nconst importFn: ImportFn = <T>(moduleId: string) => {\n  const relativeModuleId = (pathModule.isAbsolute(moduleId) ? pathModule.relative(baseDir, moduleId) : moduleId).split('\\\\').join('/').replace(baseDir + '/', '');\n  switch(relativeModuleId) {\n    case \".graphclient/sources/txs-ethereum/introspectionSchema\":\n      return import(\"./.graphclient/sources/txs-ethereum/introspectionSchema\") as T;\n    case '.graphclient/sources/txs-sepolia/introspectionSchema':\n      return import(\"./.graphclient/sources/txs-sepolia/introspectionSchema\") as T;\n    case '.graphclient/sources/txs-arbitrum/introspectionSchema':\n        return import(\"./.graphclient/sources/txs-arbitrum/introspectionSchema\") as T;\n    case '.graphclient/sources/txs-bsc/introspectionSchema':\n      return import(\"./.graphclient/sources/txs-bsc/introspectionSchema\") as T;\n    case '.graphclient/sources/txs-matic/introspectionSchema':\n      return import(\"./.graphclient/sources/txs-matic/introspectionSchema\") as T;\n    default:\n      return Promise.reject(new Error(`Cannot find module '${relativeModuleId}'.`));\n  }\n};\n\nconst rootStore = new MeshStore('.graphclient', new FsStoreStorageAdapter({\n  cwd: baseDir,\n  importFn,\n  fileType: \"ts\",\n}), {\n  readonly: true,\n  validate: false\n});\n\nexport const rawServeConfig: YamlConfig.Config['serve'] = undefined as any\nexport async function getMeshOptions(): Promise<GetMeshOptions> {\nconst pubsub = new PubSub();\nconst sourcesStore = rootStore.child('sources');\nconst logger = new DefaultLogger(\"GraphClient\");\nconst cache = new (MeshCache as any)({\n      ...({} as any),\n      importFn,\n      store: rootStore.child('cache'),\n      pubsub,\n      logger,\n    } as any)\n\nconst sources: MeshResolvedSource[] = [];\nconst transforms: MeshTransform[] = [];\nconst additionalEnvelopPlugins: MeshPlugin<any>[] = [];\nconst txsEthereumTransforms = [];\nconst txsSepoliaTransforms = [];\nconst txsArbitrumTransforms = [];\nconst txsBscTransforms = [];\nconst txsMaticTransforms = [];\nconst additionalTypeDefs = [] as any[];\nconst txsEthereumHandler = new GraphqlHandler({\n              name: \"txs-ethereum\",\n              config: {\"endpoint\":\"https://rail-squid.squids.live/squid-railgun-ethereum-v2/graphql\"},\n              baseDir,\n              cache,\n              pubsub,\n              store: sourcesStore.child(\"txs-ethereum\"),\n              logger: logger.child(\"txs-ethereum\"),\n              importFn,\n            });\nconst txsSepoliaHandler = new GraphqlHandler({\n              name: \"txs-sepolia\",\n              config: {\"endpoint\":\"https://rail-squid.squids.live/squid-railgun-eth-sepolia-v2/graphql\"},\n              baseDir,\n              cache,\n              pubsub,\n              store: sourcesStore.child(\"txs-sepolia\"),\n              logger: logger.child(\"txs-sepolia\"),\n              importFn,\n            });\nconst txsArbitrumHandler = new GraphqlHandler({\n              name: \"txs-arbitrum\",\n              config: {\"endpoint\":\"https://rail-squid.squids.live/squid-railgun-arbitrum-v2/graphql\"},\n              baseDir,\n              cache,\n              pubsub,\n              store: sourcesStore.child(\"txs-arbitrum\"),\n              logger: logger.child(\"txs-arbitrum\"),\n              importFn,\n            });\nconst txsBscHandler = new GraphqlHandler({\n              name: \"txs-bsc\",\n              config: {\"endpoint\":\"https://rail-squid.squids.live/squid-railgun-bsc-v2/graphql\"},\n              baseDir,\n              cache,\n              pubsub,\n              store: sourcesStore.child(\"txs-bsc\"),\n              logger: logger.child(\"txs-bsc\"),\n              importFn,\n            });\nconst txsMaticHandler = new GraphqlHandler({\n              name: \"txs-matic\",\n              config: {\"endpoint\":\"https://rail-squid.squids.live/squid-railgun-polygon-v2/graphql\"},\n              baseDir,\n              cache,\n              pubsub,\n              store: sourcesStore.child(\"txs-matic\"),\n              logger: logger.child(\"txs-matic\"),\n              importFn,\n            });\nsources[0] = {\n          name: 'txs-ethereum',\n          handler: txsEthereumHandler,\n          transforms: txsEthereumTransforms\n        }\nsources[1] = {\n          name: 'txs-sepolia',\n          handler: txsSepoliaHandler,\n          transforms: txsSepoliaTransforms\n        }\nsources[2] = {\n          name: 'txs-arbitrum',\n          handler: txsArbitrumHandler,\n          transforms: txsArbitrumTransforms\n        }\nsources[3] = {\n          name: 'txs-bsc',\n          handler: txsBscHandler,\n          transforms: txsBscTransforms\n        }\nsources[4] = {\n          name: 'txs-matic',\n          handler: txsMaticHandler,\n          transforms: txsMaticTransforms\n        }\nconst additionalResolvers = [] as any[]\nconst merger = new(BareMerger as any)({\n        cache,\n        pubsub,\n        logger: logger.child('bareMerger'),\n        store: rootStore.child('bareMerger')\n      })\n\n  return {\n    sources,\n    transforms,\n    additionalTypeDefs,\n    additionalResolvers,\n    cache,\n    pubsub,\n    merger,\n    logger,\n    additionalEnvelopPlugins,\n    get documents() {\n      return [\n      {\n        document: GetRailgunTransactionsAfterGraphIdDocument,\n        get rawSDL() {\n          return printWithCache(GetRailgunTransactionsAfterGraphIdDocument);\n        },\n        location: 'GetRailgunTransactionsAfterGraphIdDocument.graphql'\n      },{\n        document: GetRailgunTransactionsByTxidDocument,\n        get rawSDL() {\n          return printWithCache(GetRailgunTransactionsByTxidDocument);\n        },\n        location: 'GetRailgunTransactionsByTxidDocument.graphql'\n      },{\n        document: GetRailgunTransactionsByUnshieldToAddressDocument,\n        get rawSDL() {\n          return printWithCache(GetRailgunTransactionsByUnshieldToAddressDocument);\n        },\n        location: 'GetRailgunTransactionsByUnshieldToAddressDocument.graphql'\n      }\n    ];\n    },\n    fetchFn,\n  };\n}\n\nexport function createBuiltMeshHTTPHandler<TServerContext = {}>(): MeshHTTPHandler<TServerContext> {\n  return createMeshHTTPHandler<TServerContext>({\n    baseDir,\n    getBuiltMesh: getBuiltGraphClient,\n    rawServeConfig: undefined,\n  })\n}\n\n\nlet meshInstance$: Promise<MeshInstance> | undefined;\n\nexport function getBuiltGraphClient(): Promise<MeshInstance> {\n  if (meshInstance$ == null) {\n    meshInstance$ = getMeshOptions().then(meshOptions => getMesh(meshOptions)).then(mesh => {\n      const id = mesh.pubsub.subscribe('destroy', () => {\n        meshInstance$ = undefined;\n        mesh.pubsub.unsubscribe(id);\n      });\n      return mesh;\n    });\n  }\n  return meshInstance$;\n}\n\nexport const execute: ExecuteMeshFn = (...args) => getBuiltGraphClient().then(({ execute }) => execute(...args));\n\nexport const subscribe: SubscribeMeshFn = (...args) => getBuiltGraphClient().then(({ subscribe }) => subscribe(...args));\nexport function getBuiltGraphSDK<TGlobalContext = any, TOperationContext = any>(globalContext?: TGlobalContext) {\n  const sdkRequester$ = getBuiltGraphClient().then(({ sdkRequesterFactory }) => sdkRequesterFactory(globalContext));\n  return getSdk<TOperationContext, TGlobalContext>((...args) => sdkRequester$.then(sdkRequester => sdkRequester(...args)));\n}\nexport type GetRailgunTransactionsAfterGraphIDQueryVariables = Exact<{\n  idLow?: InputMaybe<Scalars['String']>;\n}>;\n\n\nexport type GetRailgunTransactionsAfterGraphIDQuery = { transactions: Array<(\n    Pick<Transaction, 'id' | 'nullifiers' | 'commitments' | 'transactionHash' | 'boundParamsHash' | 'blockNumber' | 'utxoTreeIn' | 'utxoTreeOut' | 'utxoBatchStartPositionOut' | 'hasUnshield' | 'unshieldToAddress' | 'unshieldValue' | 'blockTimestamp' | 'verificationHash'>\n    & { unshieldToken: Pick<Token, 'tokenType' | 'tokenSubID' | 'tokenAddress'> }\n  )> };\n\nexport type GetRailgunTransactionsByTxidQueryVariables = Exact<{\n  txid?: InputMaybe<Scalars['Bytes']>;\n}>;\n\n\nexport type GetRailgunTransactionsByTxidQuery = { transactions: Array<(\n    Pick<Transaction, 'id' | 'nullifiers' | 'commitments' | 'transactionHash' | 'boundParamsHash' | 'blockNumber' | 'utxoTreeIn' | 'utxoTreeOut' | 'utxoBatchStartPositionOut' | 'hasUnshield' | 'unshieldToAddress' | 'unshieldValue' | 'blockTimestamp' | 'verificationHash'>\n    & { unshieldToken: Pick<Token, 'tokenType' | 'tokenSubID' | 'tokenAddress'> }\n  )> };\n\nexport type GetRailgunTransactionsByUnshieldToAddressQueryVariables = Exact<{\n  address?: InputMaybe<Scalars['Bytes']>;\n}>;\n\n\nexport type GetRailgunTransactionsByUnshieldToAddressQuery = { transactions: Array<(\n    Pick<Transaction, 'id' | 'nullifiers' | 'commitments' | 'transactionHash' | 'boundParamsHash' | 'blockNumber' | 'utxoTreeIn' | 'utxoTreeOut' | 'utxoBatchStartPositionOut' | 'hasUnshield' | 'unshieldToAddress' | 'unshieldValue' | 'blockTimestamp' | 'verificationHash'>\n    & { unshieldToken: Pick<Token, 'tokenType' | 'tokenSubID' | 'tokenAddress'> }\n  )> };\n\n\nexport const GetRailgunTransactionsAfterGraphIDDocument = gql`\n    query GetRailgunTransactionsAfterGraphID($idLow: String = \"0x00\") {\n  transactions(orderBy: id_ASC, limit: 5000, where: {id_gt: $idLow}) {\n    id\n    nullifiers\n    commitments\n    transactionHash\n    boundParamsHash\n    blockNumber\n    utxoTreeIn\n    utxoTreeOut\n    utxoBatchStartPositionOut\n    hasUnshield\n    unshieldToken {\n      tokenType\n      tokenSubID\n      tokenAddress\n    }\n    unshieldToAddress\n    unshieldValue\n    blockTimestamp\n    verificationHash\n  }\n}\n    ` as unknown as DocumentNode<GetRailgunTransactionsAfterGraphIDQuery, GetRailgunTransactionsAfterGraphIDQueryVariables>;\nexport const GetRailgunTransactionsByTxidDocument = gql`\n    query GetRailgunTransactionsByTxid($txid: Bytes) {\n  transactions(where: {transactionHash_eq: $txid}) {\n    id\n    nullifiers\n    commitments\n    transactionHash\n    boundParamsHash\n    blockNumber\n    utxoTreeIn\n    utxoTreeOut\n    utxoBatchStartPositionOut\n    hasUnshield\n    unshieldToken {\n      tokenType\n      tokenSubID\n      tokenAddress\n    }\n    unshieldToAddress\n    unshieldValue\n    blockTimestamp\n    verificationHash\n  }\n}\n    ` as unknown as DocumentNode<GetRailgunTransactionsByTxidQuery, GetRailgunTransactionsByTxidQueryVariables>;\nexport const GetRailgunTransactionsByUnshieldToAddressDocument = gql`\n    query GetRailgunTransactionsByUnshieldToAddress($address: Bytes) {\n  transactions(\n    orderBy: id_ASC\n    limit: 5000\n    where: {unshieldToAddress_eq: $address}\n  ) {\n    id\n    nullifiers\n    commitments\n    transactionHash\n    boundParamsHash\n    blockNumber\n    utxoTreeIn\n    utxoTreeOut\n    utxoBatchStartPositionOut\n    hasUnshield\n    unshieldToken {\n      tokenType\n      tokenSubID\n      tokenAddress\n    }\n    unshieldToAddress\n    unshieldValue\n    blockTimestamp\n    verificationHash\n  }\n}\n    ` as unknown as DocumentNode<GetRailgunTransactionsByUnshieldToAddressQuery, GetRailgunTransactionsByUnshieldToAddressQueryVariables>;\n\n\n\n\nexport type Requester<C = {}, E = unknown> = <R, V>(doc: DocumentNode, vars?: V, options?: C) => Promise<R> | AsyncIterable<R>\nexport function getSdk<C, E>(requester: Requester<C, E>) {\n  return {\n    GetRailgunTransactionsAfterGraphID(variables?: GetRailgunTransactionsAfterGraphIDQueryVariables, options?: C): Promise<GetRailgunTransactionsAfterGraphIDQuery> {\n      return requester<GetRailgunTransactionsAfterGraphIDQuery, GetRailgunTransactionsAfterGraphIDQueryVariables>(GetRailgunTransactionsAfterGraphIDDocument, variables, options) as Promise<GetRailgunTransactionsAfterGraphIDQuery>;\n    },\n    GetRailgunTransactionsByTxid(variables?: GetRailgunTransactionsByTxidQueryVariables, options?: C): Promise<GetRailgunTransactionsByTxidQuery> {\n      return requester<GetRailgunTransactionsByTxidQuery, GetRailgunTransactionsByTxidQueryVariables>(GetRailgunTransactionsByTxidDocument, variables, options) as Promise<GetRailgunTransactionsByTxidQuery>;\n    },\n    GetRailgunTransactionsByUnshieldToAddress(variables?: GetRailgunTransactionsByUnshieldToAddressQueryVariables, options?: C): Promise<GetRailgunTransactionsByUnshieldToAddressQuery> {\n      return requester<GetRailgunTransactionsByUnshieldToAddressQuery, GetRailgunTransactionsByUnshieldToAddressQueryVariables>(GetRailgunTransactionsByUnshieldToAddressDocument, variables, options) as Promise<GetRailgunTransactionsByUnshieldToAddressQuery>;\n    }\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;"]}