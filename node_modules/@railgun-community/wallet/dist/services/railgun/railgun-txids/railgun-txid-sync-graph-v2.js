"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.quickSyncRailgunTransactionsV2 = exports.getRailgunTransactionsForTxid = exports.getRailgunTransactionDataForUnshieldToAddress = exports.getRailgunTxidsForUnshields = exports.getRailgunTxDataForUnshields = void 0;
const engine_1 = require("@railgun-community/engine");
const shared_models_1 = require("@railgun-community/shared-models");
const graphql_1 = require("./graphql");
const runtime_1 = require("@graphql-mesh/runtime");
const railgun_txid_graph_type_formatters_1 = require("./railgun-txid-graph-type-formatters");
const graph_util_1 = require("../util/graph-util");
const meshes = {};
const MAX_QUERY_RESULTS = 5000;
const txsSubgraphSourceNameForNetwork = (networkName) => {
    switch (networkName) {
        case shared_models_1.NetworkName.Ethereum:
            return 'txs-ethereum';
        case shared_models_1.NetworkName.EthereumSepolia:
            return 'txs-sepolia';
        case shared_models_1.NetworkName.BNBChain:
            return 'txs-bsc';
        case shared_models_1.NetworkName.Arbitrum:
            return 'txs-arbitrum';
        case shared_models_1.NetworkName.Polygon:
            return 'txs-matic';
        case shared_models_1.NetworkName.PolygonAmoy:
        case shared_models_1.NetworkName.PolygonMumbai_DEPRECATED:
        case shared_models_1.NetworkName.ArbitrumGoerli_DEPRECATED:
        case shared_models_1.NetworkName.EthereumGoerli_DEPRECATED:
        case shared_models_1.NetworkName.EthereumRopsten_DEPRECATED:
        case shared_models_1.NetworkName.Hardhat:
        default:
            throw new Error('No railgun-transaction subsquid for this network');
    }
};
const getRailgunTxDataForUnshields = async (chain, txid) => {
    const network = (0, shared_models_1.networkForChain)(chain);
    if (!network) {
        return [];
    }
    const sdk = getBuiltGraphSDK(network.name);
    const transactions = (await sdk.GetRailgunTransactionsByTxid({ txid })).transactions;
    const railgunTxidsForUnshields = transactions
        .filter(transaction => transaction.hasUnshield)
        .map(transaction => {
        const railgunTransaction = (0, railgun_txid_graph_type_formatters_1.formatRailgunTransactions)([transaction])[0];
        const railgunTxid = (0, engine_1.getRailgunTransactionIDHex)(transaction);
        return { railgunTxid, railgunTransaction };
    });
    return railgunTxidsForUnshields;
};
exports.getRailgunTxDataForUnshields = getRailgunTxDataForUnshields;
const getRailgunTxidsForUnshields = async (chain, txid) => {
    const network = (0, shared_models_1.networkForChain)(chain);
    if (!network) {
        return [];
    }
    const sdk = getBuiltGraphSDK(network.name);
    const transactions = (await sdk.GetRailgunTransactionsByTxid({ txid })).transactions;
    const railgunTxidsForUnshields = transactions
        .filter(transaction => transaction.hasUnshield)
        .map(transaction => {
        const railgunTxid = (0, engine_1.getRailgunTransactionIDHex)(transaction);
        return railgunTxid;
    });
    return railgunTxidsForUnshields;
};
exports.getRailgunTxidsForUnshields = getRailgunTxidsForUnshields;
const getRailgunTransactionDataForUnshieldToAddress = async (chain, unshieldToAddress) => {
    const network = (0, shared_models_1.networkForChain)(chain);
    if (!network) {
        return [];
    }
    const sdk = getBuiltGraphSDK(network.name);
    const transactions = (await sdk.GetRailgunTransactionsByUnshieldToAddress({
        address: unshieldToAddress,
    })).transactions;
    const uniqueTxidMap = new Map();
    const railgunTxidToTransactionMap = new Map();
    transactions
        .filter(transaction => transaction.hasUnshield)
        .forEach(transaction => {
        const railgunTxid = (0, engine_1.getRailgunTransactionIDHex)(transaction);
        railgunTxidToTransactionMap.set(railgunTxid, (0, railgun_txid_graph_type_formatters_1.formatRailgunTransactions)([transaction])[0]);
        if (uniqueTxidMap.has(transaction.transactionHash)) {
            const railgunTxids = uniqueTxidMap.get(transaction.transactionHash);
            railgunTxids.push(railgunTxid);
            uniqueTxidMap.set(transaction.transactionHash, railgunTxids);
        }
        else {
            uniqueTxidMap.set(transaction.transactionHash, [railgunTxid]);
        }
    });
    const railgunTxidsForUnshields = [];
    uniqueTxidMap.forEach((railgunTxids, txid) => {
        railgunTxidsForUnshields.push({
            txid,
            transactionDatas: railgunTxids.map(railgunTxid => {
                const railgunTransaction = railgunTxidToTransactionMap.get(railgunTxid);
                if (!railgunTransaction) {
                    throw new Error(`Could not find railgun transaction for txid ${txid}`);
                }
                return { railgunTransaction, railgunTxid };
            }),
        });
    });
    return railgunTxidsForUnshields;
};
exports.getRailgunTransactionDataForUnshieldToAddress = getRailgunTransactionDataForUnshieldToAddress;
const getRailgunTransactionsForTxid = async (chain, txid) => {
    const network = (0, shared_models_1.networkForChain)(chain);
    if (!network) {
        return [];
    }
    const sdk = getBuiltGraphSDK(network.name);
    const railgunTransactions = (await sdk.GetRailgunTransactionsByTxid({ txid })).transactions;
    const filteredRailgunTransactions = (0, graph_util_1.removeDuplicatesByID)(railgunTransactions);
    const formattedRailgunTransactions = (0, railgun_txid_graph_type_formatters_1.formatRailgunTransactions)(filteredRailgunTransactions);
    return formattedRailgunTransactions;
};
exports.getRailgunTransactionsForTxid = getRailgunTransactionsForTxid;
const quickSyncRailgunTransactionsV2 = async (chain, latestGraphID) => {
    const network = (0, shared_models_1.networkForChain)(chain);
    if (!network || !(0, shared_models_1.isDefined)(network.poi)) {
        return [];
    }
    const sdk = getBuiltGraphSDK(network.name);
    const railgunTransactions = await autoPaginatingQuery(async (id) => (await sdk.GetRailgunTransactionsAfterGraphID({
        idLow: id,
    })).transactions, latestGraphID ?? '0x00');
    const filteredRailgunTransactions = (0, graph_util_1.removeDuplicatesByID)(railgunTransactions);
    const formattedRailgunTransactions = (0, railgun_txid_graph_type_formatters_1.formatRailgunTransactions)(filteredRailgunTransactions);
    return formattedRailgunTransactions;
};
exports.quickSyncRailgunTransactionsV2 = quickSyncRailgunTransactionsV2;
const autoPaginatingQuery = async (query, id, prevResults = []) => {
    const newResults = await (0, shared_models_1.promiseTimeout)(query(id), 20000, new Error('Timeout querying Graph for QuickSync of RAILGUN-TXID Events'));
    if (newResults.length === 0) {
        return prevResults;
    }
    const totalResults = prevResults.concat(newResults);
    const overLimit = totalResults.length >= MAX_QUERY_RESULTS;
    const lastResult = totalResults[totalResults.length - 1];
    const shouldQueryMore = newResults.length === 5000;
    // console.log("SHOULD QUERY MORE", shouldQueryMore, "OVER LIMIT", overLimit, "TOTAL RESULTS", totalResults.length)
    if (!overLimit && shouldQueryMore) {
        await (0, shared_models_1.delay)(250);
        return autoPaginatingQuery(query, lastResult.id, totalResults);
    }
    return totalResults;
};
const getBuiltGraphClient = async (networkName) => {
    const meshForNetwork = meshes[networkName];
    if ((0, shared_models_1.isDefined)(meshForNetwork)) {
        return meshForNetwork;
    }
    const sourceName = txsSubgraphSourceNameForNetwork(networkName);
    const meshOptions = await (0, graphql_1.getMeshOptions)();
    const filteredSources = meshOptions.sources.filter(source => {
        return source.name === sourceName;
    });
    if (filteredSources.length !== 1) {
        throw new Error(`Expected exactly one source for network ${networkName}, found ${filteredSources.length}`);
    }
    meshOptions.sources = [filteredSources[0]];
    try {
        const mesh = await (0, runtime_1.getMesh)(meshOptions);
        meshes[networkName] = mesh;
        const id = mesh.pubsub.subscribe('destroy', () => {
            meshes[networkName] = undefined;
            mesh.pubsub.unsubscribe(id);
        });
        return mesh;
    }
    catch (cause) {
        throw new Error(`ERROR getting mesh - if error includes "can't generate schema," make sure to check the filepaths for source schema imports in the built index file`, { cause });
    }
};
const getBuiltGraphSDK = (networkName, globalContext) => {
    const sdkRequester$ = getBuiltGraphClient(networkName).then(({ sdkRequesterFactory }) => sdkRequesterFactory(globalContext));
    return (0, graphql_1.getSdk)((...args) => sdkRequester$.then(sdkRequester => sdkRequester(...args)));
};
//# sourceMappingURL=railgun-txid-sync-graph-v2.js.map