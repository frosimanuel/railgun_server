{"version":3,"file":"artifact-hash.js","sourceRoot":"","sources":["../../../src/services/artifacts/artifact-hash.ts"],"names":[],"mappings":";;;;;;AAAA,mCAAoC;AACpC,oEAA2E;AAC3E,+DAAyD;AACzD,+CAAsD;AACtD,6FAAgE;AAChE,sDAAsD;AACtD,qDAAwD;AAOxD,MAAM,uBAAuB,GAAG,CAC9B,YAA0B,EAC1B,qBAA6B,EACrB,EAAE;IACV,MAAM,MAAM,GAAG,iCAAwC,CAAC;IACxD,MAAM,aAAa,GAAG,MAAM,CAAC,qBAAqB,CAAC,CAAC;IACpD,IAAI,CAAC,IAAA,yBAAS,EAAC,aAAa,CAAC,EAAE;QAC7B,MAAM,IAAI,KAAK,CACb,yBAAyB,YAAY,KAAK,qBAAqB,EAAE,CAClE,CAAC;KACH;IACD,IAAI,YAAY,KAAK,4BAAY,CAAC,IAAI,EAAE;QACtC,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;KACjD;IACD,MAAM,IAAI,GAAG,aAAa,CAAC,YAAY,CAAC,CAAC;IACzC,IAAI,CAAC,IAAI,EAAE;QACT,MAAM,IAAI,KAAK,CACb,wBAAwB,YAAY,KAAK,qBAAqB,EAAE,CACjE,CAAC;KACH;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AAEF,MAAM,YAAY,GAAG,CAAC,IAAkC,EAAc,EAAE;IACtE,IAAI,IAAI,YAAY,UAAU,EAAE;QAC9B,OAAO,IAAI,CAAC;KACb;IACD,IAAI,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;QACzB,OAAO,IAAI,CAAC,MAAoB,CAAC;KAClC;IACD,OAAO,kBAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;AAC1C,CAAC,CAAC;AAEK,MAAM,wBAAwB,GAAG,KAAK,EAC3C,IAAkC,EAClC,YAA0B,EAC1B,qBAA6B,EACX,EAAE;IACpB,IAAI,YAAY,KAAK,4BAAY,CAAC,IAAI,EAAE;QACtC,OAAO,IAAI,CAAC;KACb;IACD,MAAM,SAAS,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;IACrC,MAAM,IAAI,GAAG,uBAAa;QACxB,CAAC,CAAC,kBAAS,CAAC,OAAO,CAAC,IAAA,kBAAM,EAAC,SAAS,CAAC,CAAC;QACtC,CAAC,CAAC,IAAA,mBAAU,EAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IACzD,MAAM,YAAY,GAAG,uBAAuB,CAC1C,YAAY,EACZ,qBAAqB,CACtB,CAAC;IACF,IAAI,IAAI,KAAK,YAAY,EAAE;QACzB,IAAA,yBAAgB,EACd,8BAA8B,YAAY,KAAK,qBAAqB,SAAS,IAAI,cAAc,YAAY,GAAG,CAC/G,CAAC;KACH;IACD,OAAO,IAAI,KAAK,YAAY,CAAC;AAC/B,CAAC,CAAC;AAtBW,QAAA,wBAAwB,4BAsBnC","sourcesContent":["import { createHash } from 'crypto';\nimport { ArtifactName, isDefined } from '@railgun-community/shared-models';\nimport { sha256 } from 'ethereum-cryptography/sha256.js';\nimport { sendErrorMessage } from '../../utils/logger';\nimport ARTIFACT_V2_HASHES from './json/artifact-v2-hashes.json';\nimport { ByteUtils } from '@railgun-community/engine';\nimport { isReactNative } from '../railgun/util/runtime';\n\ntype ArtifactHashesJson = Record<\n  string,\n  Record<ArtifactName.DAT | ArtifactName.WASM | ArtifactName.ZKEY, string>\n>;\n\nconst getExpectedArtifactHash = (\n  artifactName: ArtifactName,\n  artifactVariantString: string,\n): string => {\n  const hashes = ARTIFACT_V2_HASHES as ArtifactHashesJson;\n  const variantHashes = hashes[artifactVariantString];\n  if (!isDefined(variantHashes)) {\n    throw new Error(\n      `No hashes for variant ${artifactName}: ${artifactVariantString}`,\n    );\n  }\n  if (artifactName === ArtifactName.VKEY) {\n    throw new Error(`No artifact hashes for vkey.`);\n  }\n  const hash = variantHashes[artifactName];\n  if (!hash) {\n    throw new Error(\n      `No hash for artifact ${artifactName}: ${artifactVariantString}`,\n    );\n  }\n  return hash;\n};\n\nconst getDataBytes = (data: Uint8Array | Buffer | string): Uint8Array => {\n  if (data instanceof Uint8Array) {\n    return data;\n  }\n  if (Buffer.isBuffer(data)) {\n    return data.buffer as Uint8Array;\n  }\n  return ByteUtils.hexStringToBytes(data);\n};\n\nexport const validateArtifactDownload = async (\n  data: Uint8Array | Buffer | string,\n  artifactName: ArtifactName,\n  artifactVariantString: string,\n): Promise<boolean> => {\n  if (artifactName === ArtifactName.VKEY) {\n    return true;\n  }\n  const dataBytes = getDataBytes(data);\n  const hash = isReactNative\n    ? ByteUtils.hexlify(sha256(dataBytes))\n    : createHash('sha256').update(dataBytes).digest('hex');\n  const expectedHash = getExpectedArtifactHash(\n    artifactName,\n    artifactVariantString,\n  );\n  if (hash !== expectedHash) {\n    sendErrorMessage(\n      `Validate artifact blob for ${artifactName}: ${artifactVariantString}. Got ${hash}, expected ${expectedHash}.`,\n    );\n  }\n  return hash === expectedHash;\n};\n"]}