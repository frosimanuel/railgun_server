"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.POINodeRequest = void 0;
const shared_models_1 = require("@railgun-community/shared-models");
const axios_1 = __importStar(require("axios"));
const utils_1 = require("../../utils");
class POINodeRequest {
    nodeURLs;
    constructor(nodeURLs) {
        this.nodeURLs = nodeURLs;
    }
    currentNodeURLIndex = 0;
    getNextNodeURL = () => {
        this.currentNodeURLIndex =
            (this.currentNodeURLIndex + 1) % this.nodeURLs.length;
        return this.getNodeURL(this.currentNodeURLIndex);
    };
    getNodeURL = (nodeUrlAttemptIndex) => {
        return `${this.nodeURLs[nodeUrlAttemptIndex]}`;
    };
    static async jsonRpcRequest(url, method, params) {
        const payload = {
            jsonrpc: '2.0',
            method,
            params,
            id: Date.now(),
        };
        try {
            const { data } = await axios_1.default.post(url, payload);
            // Check if the response contains an error
            if ('error' in data) {
                throw new Error(data.error.message);
            }
            // Assume the result will always be in the expected ResponseData format
            return data.result;
        }
        catch (cause) {
            if (!(cause instanceof axios_1.AxiosError)) {
                throw new Error('Non-error thrown in axios post request.', { cause });
            }
            const err = new Error(`POI request error ${url}`, { cause });
            (0, utils_1.sendErrorMessage)(err);
            throw err;
        }
    }
    async attemptRequestWithFallbacks(method, params, nodeUrlAttemptIndex = 0, finalAttempt = false) {
        try {
            const url = this.getNodeURL(nodeUrlAttemptIndex);
            const res = await (0, shared_models_1.promiseTimeout)(POINodeRequest.jsonRpcRequest(url, method, params), 60000);
            return res;
        }
        catch (err) {
            if (finalAttempt) {
                throw err;
            }
            // If nodeUrlAttemptIndex is already at the last index, try one final time with the priority 0 nodeUrl
            if (nodeUrlAttemptIndex === this.nodeURLs.length - 1) {
                return this.attemptRequestWithFallbacks(method, params, 0, // nodeUrlAttemptIndex
                true);
            }
            // Retry with next priority node URL.
            return this.attemptRequestWithFallbacks(method, params, nodeUrlAttemptIndex + 1, // nodeUrlAttemptIndex
            false);
        }
    }
    validateRailgunTxidMerkleroot = async (txidVersion, chain, tree, index, merkleroot) => {
        const method = shared_models_1.POIJSONRPCMethod.ValidateTXIDMerkleroot;
        const isValid = await this.attemptRequestWithFallbacks(method, {
            chainType: chain.type.toString(),
            chainID: chain.id.toString(),
            txidVersion,
            tree,
            index,
            merkleroot,
        });
        return isValid;
    };
    getLatestValidatedRailgunTxid = async (txidVersion, chain) => {
        const method = shared_models_1.POIJSONRPCMethod.ValidatedTXID;
        const status = await this.attemptRequestWithFallbacks(method, {
            chainType: chain.type.toString(),
            chainID: chain.id.toString(),
            txidVersion,
        });
        return status;
    };
    validatePOIMerkleroots = async (txidVersion, chain, listKey, poiMerkleroots, retryCount = 0) => {
        try {
            const method = shared_models_1.POIJSONRPCMethod.ValidatePOIMerkleroots;
            const validated = await this.attemptRequestWithFallbacks(method, {
                chainType: chain.type.toString(),
                chainID: chain.id.toString(),
                txidVersion,
                listKey,
                poiMerkleroots,
            });
            return validated;
        }
        catch (cause) {
            if (retryCount < 3) {
                // Delay 2.5s and try again.
                await (0, shared_models_1.delay)(2500);
                return this.validatePOIMerkleroots(txidVersion, chain, listKey, poiMerkleroots, retryCount + 1);
            }
            throw new Error('Failed to validate POI merkleroots.', { cause });
        }
    };
    getPOIsPerList = async (txidVersion, chain, listKeys, blindedCommitmentDatas) => {
        const method = shared_models_1.POIJSONRPCMethod.POIsPerList;
        const poiStatusListMap = await this.attemptRequestWithFallbacks(method, {
            chainType: chain.type.toString(),
            chainID: chain.id.toString(),
            txidVersion,
            listKeys,
            blindedCommitmentDatas,
        });
        return poiStatusListMap;
    };
    getPOIMerkleProofs = async (txidVersion, chain, listKey, blindedCommitments) => {
        const method = shared_models_1.POIJSONRPCMethod.MerkleProofs;
        const merkleProofs = await this.attemptRequestWithFallbacks(method, {
            chainType: chain.type.toString(),
            chainID: chain.id.toString(),
            txidVersion,
            listKey,
            blindedCommitments,
        });
        return merkleProofs;
    };
    submitPOI = async (txidVersion, chain, listKey, transactProofData) => {
        const method = shared_models_1.POIJSONRPCMethod.SubmitTransactProof;
        await this.attemptRequestWithFallbacks(method, {
            chainType: chain.type.toString(),
            chainID: chain.id.toString(),
            txidVersion,
            listKey,
            transactProofData,
        });
    };
    submitLegacyTransactProofs = async (txidVersion, chain, listKeys, legacyTransactProofDatas) => {
        const method = shared_models_1.POIJSONRPCMethod.SubmitLegacyTransactProofs;
        await this.attemptRequestWithFallbacks(method, {
            chainType: chain.type.toString(),
            chainID: chain.id.toString(),
            txidVersion,
            listKeys,
            legacyTransactProofDatas,
        });
    };
    submitSingleCommitmentProof = async (txidVersion, chain, singleCommitmentProofsData) => {
        const method = shared_models_1.POIJSONRPCMethod.SubmitSingleCommitmentProofs;
        await this.attemptRequestWithFallbacks(method, {
            chainType: chain.type.toString(),
            chainID: chain.id.toString(),
            txidVersion,
            singleCommitmentProofsData,
        });
    };
}
exports.POINodeRequest = POINodeRequest;
//# sourceMappingURL=poi-node-request.js.map