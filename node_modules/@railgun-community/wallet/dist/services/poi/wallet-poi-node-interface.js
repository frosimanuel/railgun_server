"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletPOINodeInterface = void 0;
const engine_1 = require("@railgun-community/engine");
const poi_node_request_1 = require("./poi-node-request");
const shared_models_1 = require("@railgun-community/shared-models");
const poi_required_1 = require("./poi-required");
class WalletPOINodeInterface extends engine_1.POINodeInterface {
    poiNodeRequest;
    batchSize = 20;
    static isPaused = false;
    static isPausedMap = {};
    static isPausedForChain(chain) {
        return WalletPOINodeInterface.isPausedMap[chain.type]?.[chain.id] ?? false;
    }
    static listBatchCallback;
    constructor(poiNodeURLs) {
        super();
        this.poiNodeRequest = new poi_node_request_1.POINodeRequest(poiNodeURLs);
    }
    static poiStatusToTXOPOIStatus = (poiStatus) => {
        switch (poiStatus) {
            case shared_models_1.POIStatus.Valid:
                return engine_1.TXOPOIListStatus.Valid;
            case shared_models_1.POIStatus.ShieldBlocked:
                return engine_1.TXOPOIListStatus.ShieldBlocked;
            case shared_models_1.POIStatus.ProofSubmitted:
                return engine_1.TXOPOIListStatus.ProofSubmitted;
            case shared_models_1.POIStatus.Missing:
                return engine_1.TXOPOIListStatus.Missing;
        }
    };
    static getPOISettings(chain) {
        const network = (0, shared_models_1.networkForChain)(chain);
        if (!network) {
            throw new Error(`No network found`);
        }
        const networkPOISettings = network.poi;
        if (!networkPOISettings) {
            throw new Error(`No POI settings found`);
        }
        return networkPOISettings;
    }
    // eslint-disable-next-line class-methods-use-this
    isActive(chain) {
        return WalletPOINodeInterface.getPOISettings(chain) != null;
    }
    static pause(chain) {
        WalletPOINodeInterface.isPausedMap[chain.type] ??= {};
        WalletPOINodeInterface.isPausedMap[chain.type][chain.id] = true;
    }
    static unpause(chain) {
        // would be good practice to unpause when loading providers, or resuming polling providers.
        WalletPOINodeInterface.isPausedMap[chain.type] ??= {};
        WalletPOINodeInterface.isPausedMap[chain.type][chain.id] = false;
    }
    // eslint-disable-next-line class-methods-use-this
    async isRequired(chain) {
        const network = (0, shared_models_1.networkForChain)(chain);
        if (!network) {
            throw new Error(`No network for chain ${chain.type}:${chain.id}`);
        }
        return poi_required_1.POIRequired.isRequiredForNetwork(network.name);
    }
    static setListBatchCallback = (callback) => {
        WalletPOINodeInterface.listBatchCallback = callback;
    };
    static clearListBatchStatus = () => {
        if ((0, shared_models_1.isDefined)(WalletPOINodeInterface.listBatchCallback)) {
            WalletPOINodeInterface.listBatchCallback({
                current: 0,
                total: 0,
                percent: 0,
                status: '',
            });
        }
    };
    static emitListBatchCallback = (current, total, message) => {
        if ((0, shared_models_1.isDefined)(WalletPOINodeInterface.listBatchCallback)) {
            const percent = (current / total) * 100;
            const status = `${message} PPOI Batch (${current} of ${total}) ${percent.toFixed(2)}%`;
            WalletPOINodeInterface.listBatchCallback({
                current,
                total,
                percent,
                status,
            });
        }
    };
    async getPOIsPerList(txidVersion, chain, listKeys, blindedCommitmentDatas) {
        const poisPerList = {};
        for (let i = 0; i < blindedCommitmentDatas.length; i += this.batchSize) {
            if (WalletPOINodeInterface.isPausedForChain(chain)) {
                WalletPOINodeInterface.clearListBatchStatus();
                continue;
            }
            const batch = blindedCommitmentDatas.slice(i, i + this.batchSize);
            const type = batch[0].type;
            WalletPOINodeInterface.emitListBatchCallback(i, blindedCommitmentDatas.length, `Verifying ${type}'s`);
            const batchPoisPerList = 
            // eslint-disable-next-line no-await-in-loop
            await this.poiNodeRequest
                .getPOIsPerList(txidVersion, chain, listKeys, batch)
                .catch(() => {
                return {};
            });
            WalletPOINodeInterface.emitListBatchCallback(i + batch.length, blindedCommitmentDatas.length, `Received results for ${type}'s now Analyzing`);
            // eslint-disable-next-line no-await-in-loop
            await (0, shared_models_1.delay)(100);
            for (const blindedCommitment of Object.keys(batchPoisPerList)) {
                poisPerList[blindedCommitment] = batchPoisPerList[blindedCommitment];
            }
        }
        const poisPerListConverted = {};
        for (const blindedCommitment of Object.keys(poisPerList)) {
            poisPerListConverted[blindedCommitment] = {};
            for (const listKey of Object.keys(poisPerList[blindedCommitment])) {
                const poiStatus = poisPerList[blindedCommitment][listKey];
                poisPerListConverted[blindedCommitment][listKey] =
                    WalletPOINodeInterface.poiStatusToTXOPOIStatus(poiStatus);
            }
        }
        return poisPerListConverted;
    }
    async getPOIMerkleProofs(txidVersion, chain, listKey, blindedCommitments) {
        return this.poiNodeRequest.getPOIMerkleProofs(txidVersion, chain, listKey, blindedCommitments);
    }
    async validatePOIMerkleroots(txidVersion, chain, listKey, poiMerkleroots) {
        return this.poiNodeRequest.validatePOIMerkleroots(txidVersion, chain, listKey, poiMerkleroots);
    }
    async submitPOI(txidVersion, chain, listKey, snarkProof, poiMerkleroots, txidMerkleroot, txidMerklerootIndex, blindedCommitmentsOut, railgunTxidIfHasUnshield) {
        const transactProofData = {
            snarkProof,
            poiMerkleroots,
            txidMerkleroot,
            txidMerklerootIndex,
            blindedCommitmentsOut,
            railgunTxidIfHasUnshield,
        };
        return this.poiNodeRequest.submitPOI(txidVersion, chain, listKey, transactProofData);
    }
    async submitLegacyTransactProofs(txidVersion, chain, listKeys, legacyTransactProofDatas) {
        for (let i = 0; i < legacyTransactProofDatas.length; i += this.batchSize) {
            if (WalletPOINodeInterface.isPausedForChain(chain)) {
                continue;
            }
            const batch = legacyTransactProofDatas.slice(i, i + this.batchSize);
            WalletPOINodeInterface.emitListBatchCallback(i, legacyTransactProofDatas.length, 'Submitting Legacy Transact Proofs');
            // eslint-disable-next-line no-await-in-loop
            await this.poiNodeRequest
                .submitLegacyTransactProofs(txidVersion, chain, listKeys, batch)
                .catch(() => {
                return undefined;
            });
            WalletPOINodeInterface.emitListBatchCallback(i + batch.length, legacyTransactProofDatas.length, 'Submitted Legacy Transact Proofs');
            // eslint-disable-next-line no-await-in-loop
            await (0, shared_models_1.delay)(100);
        }
    }
}
exports.WalletPOINodeInterface = WalletPOINodeInterface;
//# sourceMappingURL=wallet-poi-node-interface.js.map