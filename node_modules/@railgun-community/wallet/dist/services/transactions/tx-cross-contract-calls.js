"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRelayAdaptReturnValue = exports.getRelayAdaptTransactionError = exports.generateCrossContractCallsProof = exports.gasEstimateForUnprovenCrossContractCalls = exports.populateProvedCrossContractCalls = exports.createNFTTokenDataFromRailgunNFTAmount = exports.createRelayAdaptUnshieldNFTAmountRecipients = exports.createRelayAdaptUnshieldERC20AmountRecipients = void 0;
const shared_models_1 = require("@railgun-community/shared-models");
const tx_generator_1 = require("./tx-generator");
const proof_cache_1 = require("./proof-cache");
const logger_1 = require("../../utils/logger");
const engine_1 = require("@railgun-community/engine");
const blocked_address_1 = require("../../utils/blocked-address");
const tx_gas_broadcaster_fee_estimator_1 = require("./tx-gas-broadcaster-fee-estimator");
const error_1 = require("../../utils/error");
const utils_1 = require("../../utils");
const shared_formatters_1 = require("../railgun/quick-sync/shared-formatters");
const createValidCrossContractCalls = (crossContractCalls) => {
    if (!crossContractCalls.length) {
        throw new Error('No cross contract calls in transaction.');
    }
    try {
        return crossContractCalls.map(transactionRequest => {
            if (!transactionRequest.to || !transactionRequest.data) {
                throw new Error(`Cross-contract calls require 'to' and 'data' fields.`);
            }
            const transaction = {
                to: transactionRequest.to,
                value: transactionRequest.value,
                data: engine_1.ByteUtils.hexlify(transactionRequest.data, true),
            };
            (0, blocked_address_1.assertNotBlockedAddress)(transaction.to);
            return transaction;
        });
    }
    catch (cause) {
        if (!(cause instanceof Error)) {
            throw new Error('Non-error thrown from createValidCrossContractCalls', {
                cause,
            });
        }
        throw (0, error_1.reportAndSanitizeError)(createValidCrossContractCalls.name, cause);
    }
};
const createRelayAdaptUnshieldERC20AmountRecipients = (txidVersion, networkName, unshieldERC20Amounts) => {
    const chain = shared_models_1.NETWORK_CONFIG[networkName].chain;
    const relayAdaptContract = engine_1.RelayAdaptVersionedSmartContracts.getRelayAdaptContract(txidVersion, chain);
    const unshieldERC20AmountRecipients = unshieldERC20Amounts.map(unshieldERC20Amount => ({
        ...unshieldERC20Amount,
        recipientAddress: relayAdaptContract.address,
    }));
    return unshieldERC20AmountRecipients;
};
exports.createRelayAdaptUnshieldERC20AmountRecipients = createRelayAdaptUnshieldERC20AmountRecipients;
const createRelayAdaptUnshieldNFTAmountRecipients = (txidVersion, networkName, unshieldNFTAmounts) => {
    const chain = shared_models_1.NETWORK_CONFIG[networkName].chain;
    const relayAdaptContract = engine_1.RelayAdaptVersionedSmartContracts.getRelayAdaptContract(txidVersion, chain);
    const unshieldNFTAmountRecipients = unshieldNFTAmounts.map(unshieldNFTAmount => ({
        ...unshieldNFTAmount,
        recipientAddress: relayAdaptContract.address,
    }));
    return unshieldNFTAmountRecipients;
};
exports.createRelayAdaptUnshieldNFTAmountRecipients = createRelayAdaptUnshieldNFTAmountRecipients;
const createNFTTokenDataFromRailgunNFTAmount = (nftAmount) => {
    const tokenSubIDHex = (0, utils_1.isDecimalStr)(nftAmount.tokenSubID)
        ? (0, shared_formatters_1.bigIntStringToHex)(nftAmount.tokenSubID)
        : nftAmount.tokenSubID;
    return {
        tokenAddress: engine_1.ByteUtils.formatToByteLength(nftAmount.nftAddress, engine_1.ByteLength.Address, true),
        tokenType: nftAmount.nftTokenType,
        tokenSubID: engine_1.ByteUtils.formatToByteLength(tokenSubIDHex, engine_1.ByteLength.UINT_256, true),
    };
};
exports.createNFTTokenDataFromRailgunNFTAmount = createNFTTokenDataFromRailgunNFTAmount;
const createRelayAdaptShieldNFTRecipients = (relayAdaptShieldNFTRecipients) => {
    return relayAdaptShieldNFTRecipients.map((nftRecipient) => ({
        nftTokenData: (0, exports.createNFTTokenDataFromRailgunNFTAmount)(nftRecipient),
        recipientAddress: nftRecipient.recipientAddress,
    }));
};
const populateProvedCrossContractCalls = async (txidVersion, networkName, railgunWalletID, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice, gasDetails) => {
    try {
        const { transaction, nullifiers, preTransactionPOIsPerTxidLeafPerList } = await (0, proof_cache_1.populateProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.CrossContractCalls, railgunWalletID, false, // showSenderAddressToRecipient
        undefined, // memoText
        [], // erc20AmountRecipients
        [], // nftAmountRecipients
        relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice, gasDetails);
        delete transaction.from;
        return {
            nullifiers,
            transaction,
            preTransactionPOIsPerTxidLeafPerList,
        };
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.populateProvedCrossContractCalls.name, err);
    }
};
exports.populateProvedCrossContractCalls = populateProvedCrossContractCalls;
const gasEstimateForUnprovenCrossContractCalls = async (txidVersion, networkName, railgunWalletID, encryptionKey, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, originalGasDetails, feeTokenDetails, sendWithPublicWallet, minGasLimit) => {
    try {
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        const overallBatchMinGasPrice = 0n;
        const validCrossContractCalls = createValidCrossContractCalls(crossContractCalls);
        const chain = shared_models_1.NETWORK_CONFIG[networkName].chain;
        const relayAdaptUnshieldERC20AmountRecipients = (0, exports.createRelayAdaptUnshieldERC20AmountRecipients)(txidVersion, networkName, relayAdaptUnshieldERC20Amounts);
        const relayAdaptUnshieldNFTAmountRecipients = (0, exports.createRelayAdaptUnshieldNFTAmountRecipients)(txidVersion, networkName, relayAdaptUnshieldNFTAmounts);
        const shieldRandom = engine_1.ByteUtils.randomHex(16);
        const relayShieldRequests = await engine_1.RelayAdaptHelper.generateRelayShieldRequests(shieldRandom, relayAdaptShieldERC20Recipients, createRelayAdaptShieldNFTRecipients(relayAdaptShieldNFTRecipients));
        // TODO-V3: Needs modification
        const minimumGasLimit = minGasLimit ?? engine_1.MINIMUM_RELAY_ADAPT_CROSS_CONTRACT_CALLS_GAS_LIMIT_V2;
        const response = await (0, tx_gas_broadcaster_fee_estimator_1.gasEstimateResponseDummyProofIterativeBroadcasterFee)((broadcasterFeeERC20Amount) => (0, tx_generator_1.generateDummyProofTransactions)(shared_models_1.ProofType.CrossContractCalls, networkName, railgunWalletID, txidVersion, encryptionKey, false, // showSenderAddressToRecipient
        undefined, // memoText
        relayAdaptUnshieldERC20AmountRecipients, relayAdaptUnshieldNFTAmountRecipients, broadcasterFeeERC20Amount, sendWithPublicWallet, overallBatchMinGasPrice), async (txs) => {
            const relayAdaptParamsRandom = engine_1.ByteUtils.randomHex(31);
            // TODO: We should add the relay adapt contract gas limit here.
            const transaction = await engine_1.RelayAdaptVersionedSmartContracts.populateCrossContractCalls(txidVersion, chain, txs, validCrossContractCalls, relayShieldRequests, relayAdaptParamsRandom, true, // isGasEstimate
            !sendWithPublicWallet, // isBroadcasterTransaction
            minimumGasLimit);
            // Remove gasLimit, we'll set to the minimum below.
            // TODO: Remove after callbacks upgrade.
            delete transaction.gasLimit;
            return transaction;
        }, txidVersion, networkName, railgunWalletID, relayAdaptUnshieldERC20AmountRecipients, originalGasDetails, feeTokenDetails, sendWithPublicWallet, true);
        // TODO: Remove this after callbacks upgrade.
        // If gas estimate is under the cross-contract-minimum, replace it with the minimum.
        if (response.gasEstimate) {
            if (response.gasEstimate < minimumGasLimit) {
                response.gasEstimate = minimumGasLimit;
            }
        }
        return response;
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.gasEstimateForUnprovenCrossContractCalls.name, err);
    }
};
exports.gasEstimateForUnprovenCrossContractCalls = gasEstimateForUnprovenCrossContractCalls;
const generateCrossContractCallsProof = async (txidVersion, networkName, railgunWalletID, encryptionKey, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice, minGasLimit, progressCallback) => {
    try {
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        const validCrossContractCalls = createValidCrossContractCalls(crossContractCalls);
        const relayAdaptUnshieldERC20AmountRecipients = (0, exports.createRelayAdaptUnshieldERC20AmountRecipients)(txidVersion, networkName, relayAdaptUnshieldERC20Amounts);
        const relayAdaptUnshieldNFTAmountRecipients = (0, exports.createRelayAdaptUnshieldNFTAmountRecipients)(txidVersion, networkName, relayAdaptUnshieldNFTAmounts);
        // Generate dummy txs for relay adapt params.
        const dummyUnshieldTxs = await (0, tx_generator_1.generateDummyProofTransactions)(shared_models_1.ProofType.CrossContractCalls, networkName, railgunWalletID, txidVersion, encryptionKey, false, // showSenderAddressToRecipient
        undefined, // memoText
        relayAdaptUnshieldERC20AmountRecipients, relayAdaptUnshieldNFTAmountRecipients, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice);
        // Generate relay adapt params from dummy transactions.
        const shieldRandom = engine_1.ByteUtils.randomHex(16);
        const relayShieldRequests = await engine_1.RelayAdaptHelper.generateRelayShieldRequests(shieldRandom, relayAdaptShieldERC20Recipients, createRelayAdaptShieldNFTRecipients(relayAdaptShieldNFTRecipients));
        // TODO-V3: Needs modification
        const minimumGasLimit = minGasLimit ?? engine_1.MINIMUM_RELAY_ADAPT_CROSS_CONTRACT_CALLS_GAS_LIMIT_V2;
        const { chain } = shared_models_1.NETWORK_CONFIG[networkName];
        const isBroadcasterTransaction = !sendWithPublicWallet;
        const relayAdaptParamsRandom = engine_1.ByteUtils.randomHex(31);
        const relayAdaptParams = await engine_1.RelayAdaptVersionedSmartContracts.getRelayAdaptParamsCrossContractCalls(txidVersion, chain, dummyUnshieldTxs, validCrossContractCalls, relayShieldRequests, relayAdaptParamsRandom, isBroadcasterTransaction, minimumGasLimit);
        const relayAdaptContract = engine_1.RelayAdaptVersionedSmartContracts.getRelayAdaptContract(txidVersion, chain);
        const relayAdaptID = {
            contract: relayAdaptContract.address,
            parameters: relayAdaptParams,
        };
        // Create real transactions with relay adapt params.
        const { provedTransactions, preTransactionPOIsPerTxidLeafPerList } = await (0, tx_generator_1.generateProofTransactions)(shared_models_1.ProofType.CrossContractCalls, networkName, railgunWalletID, txidVersion, encryptionKey, false, // showSenderAddressToRecipient
        undefined, // memoText
        relayAdaptUnshieldERC20AmountRecipients, relayAdaptUnshieldNFTAmountRecipients, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, relayAdaptID, false, // useDummyProof
        overallBatchMinGasPrice, progressCallback);
        const nullifiers = (0, tx_generator_1.nullifiersForTransactions)(provedTransactions);
        const transaction = await engine_1.RelayAdaptVersionedSmartContracts.populateCrossContractCalls(txidVersion, chain, provedTransactions, validCrossContractCalls, relayShieldRequests, relayAdaptParamsRandom, false, // isGasEstimate
        isBroadcasterTransaction, minimumGasLimit);
        delete transaction.from;
        (0, proof_cache_1.setCachedProvedTransaction)({
            proofType: shared_models_1.ProofType.CrossContractCalls,
            txidVersion,
            railgunWalletID,
            showSenderAddressToRecipient: false,
            memoText: undefined,
            erc20AmountRecipients: [],
            nftAmountRecipients: [],
            relayAdaptUnshieldERC20Amounts,
            relayAdaptUnshieldNFTAmounts,
            relayAdaptShieldERC20Recipients,
            relayAdaptShieldNFTRecipients,
            crossContractCalls: validCrossContractCalls,
            broadcasterFeeERC20AmountRecipient,
            sendWithPublicWallet,
            transaction,
            preTransactionPOIsPerTxidLeafPerList,
            overallBatchMinGasPrice,
            nullifiers,
        });
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.generateCrossContractCallsProof.name, err);
    }
};
exports.generateCrossContractCallsProof = generateCrossContractCallsProof;
const getRelayAdaptTransactionError = (txidVersion, receiptLogs) => {
    try {
        const relayAdaptError = engine_1.RelayAdaptVersionedSmartContracts.getRelayAdaptCallError(txidVersion, receiptLogs);
        if ((0, shared_models_1.isDefined)(relayAdaptError)) {
            (0, logger_1.sendErrorMessage)(relayAdaptError);
            return relayAdaptError;
        }
        return undefined;
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.getRelayAdaptTransactionError.name, err);
    }
};
exports.getRelayAdaptTransactionError = getRelayAdaptTransactionError;
const parseRelayAdaptReturnValue = (txidVersion, data) => {
    try {
        const relayAdaptErrorParsed = engine_1.RelayAdaptVersionedSmartContracts.parseRelayAdaptReturnValue(txidVersion, data);
        if ((0, shared_models_1.isDefined)(relayAdaptErrorParsed)) {
            (0, logger_1.sendErrorMessage)(relayAdaptErrorParsed.error);
            return relayAdaptErrorParsed.error;
        }
        return undefined;
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.getRelayAdaptTransactionError.name, err);
    }
};
exports.parseRelayAdaptReturnValue = parseRelayAdaptReturnValue;
//# sourceMappingURL=tx-cross-contract-calls.js.map