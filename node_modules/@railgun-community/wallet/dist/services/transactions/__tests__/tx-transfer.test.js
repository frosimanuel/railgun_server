"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = __importDefault(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const sinon_1 = __importDefault(require("sinon"));
const engine_1 = require("@railgun-community/engine");
const shared_models_1 = require("@railgun-community/shared-models");
const setup_test_1 = require("../../../tests/setup.test");
const mocks_test_1 = require("../../../tests/mocks.test");
const tx_transfer_1 = require("../tx-transfer");
const txGasDetailsModule = __importStar(require("../tx-gas-details"));
const tx_proof_transfer_1 = require("../tx-proof-transfer");
const wallets_1 = require("../../railgun/wallets/wallets");
const proof_cache_1 = require("../proof-cache");
const txNotes = __importStar(require("../tx-notes"));
const helper_test_1 = require("../../../tests/helper.test");
let gasEstimateStub;
let railProveStub;
let railDummyProveStub;
let railTransactStub;
let relayAdaptPopulateUnshieldBaseToken;
let setUnshieldSpy;
let erc20NoteSpy;
let nftNoteSpy;
let railgunWallet;
let broadcasterFeeERC20AmountRecipient;
chai_1.default.use(chai_as_promised_1.default);
const { expect } = chai_1.default;
const txidVersion = (0, helper_test_1.getTestTXIDVersion)();
const MOCK_TOKEN_AMOUNTS_DIFFERENT = [
    {
        tokenAddress: mocks_test_1.MOCK_TOKEN_ADDRESS,
        amount: 100n,
    },
    {
        tokenAddress: mocks_test_1.MOCK_TOKEN_ADDRESS_2,
        amount: 300n,
    },
];
const overallBatchMinGasPrice = BigInt('0x1000');
const gasDetails = {
    evmGasType: shared_models_1.EVMGasType.Type1,
    gasEstimate: 1000n,
    gasPrice: overallBatchMinGasPrice,
};
const MOCK_TOKEN_AMOUNT_RECIPIENTS_INVALID = mocks_test_1.MOCK_TOKEN_AMOUNTS.map(erc20Amount => ({
    ...erc20Amount,
    recipientAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
}));
const MOCK_NFT_AMOUNT_RECIPIENTS_INVALID = mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS.map(nftAmountRecipient => ({
    ...nftAmountRecipient,
    recipientAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
}));
const MOCK_TOKEN_AMOUNT_RECIPIENTS = mocks_test_1.MOCK_TOKEN_AMOUNTS.map(erc20Amount => ({
    ...erc20Amount,
    recipientAddress: mocks_test_1.MOCK_RAILGUN_WALLET_ADDRESS,
}));
const MOCK_TOKEN_AMOUNT_RECIPIENTS_DIFFERENT = MOCK_TOKEN_AMOUNTS_DIFFERENT.map(erc20Amount => ({
    ...erc20Amount,
    recipientAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
}));
const stubGasEstimateSuccess = () => {
    gasEstimateStub = sinon_1.default.stub(txGasDetailsModule, 'getGasEstimate').resolves(BigInt('200'));
};
const stubGasEstimateFailure = () => {
    gasEstimateStub = sinon_1.default.stub(txGasDetailsModule, 'getGasEstimate').rejects(new Error('test rejection - gas estimate'));
};
const spyOnERC20Note = () => {
    erc20NoteSpy = sinon_1.default.spy(txNotes, 'erc20NoteFromERC20AmountRecipient');
};
const spyOnNFTNote = () => {
    nftNoteSpy = sinon_1.default.spy(txNotes, 'nftNoteFromNFTAmountRecipient');
};
describe('tx-transfer', () => {
    before(async function run() {
        this.timeout(60000);
        await (0, setup_test_1.initTestEngine)();
        await (0, setup_test_1.initTestEngineNetworks)();
        const railgunWalletInfo = await (0, wallets_1.createRailgunWallet)(mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MNEMONIC, undefined);
        if (!(0, shared_models_1.isDefined)(railgunWalletInfo)) {
            throw new Error('Expected railgunWalletInfo');
        }
        railgunWallet = (0, wallets_1.fullWalletForID)(railgunWalletInfo.id);
        const broadcasterWalletInfo = await (0, wallets_1.createRailgunWallet)(mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MNEMONIC, undefined);
        if (!(0, shared_models_1.isDefined)(broadcasterWalletInfo)) {
            throw new Error('Expected broadcasterWalletInfo');
        }
        const broadcasterRailgunAddress = broadcasterWalletInfo.railgunAddress;
        broadcasterFeeERC20AmountRecipient = {
            ...mocks_test_1.MOCK_TOKEN_FEE,
            recipientAddress: broadcasterRailgunAddress,
        };
        railProveStub = sinon_1.default.stub(engine_1.TransactionBatch.prototype, 'generateTransactions').resolves({
            provedTransactions: [
                {
                    nullifiers: mocks_test_1.MOCK_NULLIFIERS,
                },
            ],
            preTransactionPOIsPerTxidLeafPerList: {},
        });
        railDummyProveStub = sinon_1.default.stub(engine_1.TransactionBatch.prototype, 'generateDummyTransactions').resolves([
            {
                txidVersion,
                commitments: mocks_test_1.MOCK_COMMITMENTS,
                boundParams: (0, helper_test_1.isV2Test)() ? mocks_test_1.MOCK_BOUND_PARAMS_V2 : mocks_test_1.MOCK_BOUND_PARAMS_V3,
                nullifiers: mocks_test_1.MOCK_NULLIFIERS,
            },
        ]);
        railTransactStub = sinon_1.default.stub(engine_1.RailgunVersionedSmartContracts, 'generateTransact').resolves({ data: '0x0123' });
        relayAdaptPopulateUnshieldBaseToken = sinon_1.default.stub(engine_1.RelayAdaptVersionedSmartContracts, 'populateUnshieldBaseToken').resolves({ data: '0x0123' });
    });
    afterEach(() => {
        gasEstimateStub?.restore();
        setUnshieldSpy?.restore();
        erc20NoteSpy?.restore();
        nftNoteSpy?.restore();
    });
    after(async () => {
        railProveStub.restore();
        railDummyProveStub.restore();
        railTransactStub.restore();
        relayAdaptPopulateUnshieldBaseToken.restore();
        await (0, setup_test_1.closeTestEngine)();
    });
    // TRANSFER ERC20 - GAS ESTIMATE
    it('Should get gas estimates for valid erc20 transfer', async () => {
        stubGasEstimateSuccess();
        spyOnERC20Note();
        const rsp = await (0, tx_transfer_1.gasEstimateForUnprovenTransfer)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MEMO, MOCK_TOKEN_AMOUNT_RECIPIENTS, [], // nftAmountRecipients
        mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false);
        expect(erc20NoteSpy.called).to.be.true;
        expect(erc20NoteSpy.args.length).to.equal(6); // Number of calls - 3 for each of 2 broadcaster fee iterations
        expect(erc20NoteSpy.args[0][0].amount).to.equal(BigInt('0x00')); // original broadcaster fee
        expect(erc20NoteSpy.args[1][0].amount).to.equal(BigInt('0x100')); // token1
        expect(erc20NoteSpy.args[2][0].amount).to.equal(BigInt('0x200')); // token2
        expect(erc20NoteSpy.args[3][0].amount).to.equal(BigInt('0x0275a61bf8737eb4')); // New estimated Broadcaster Fee
        expect(erc20NoteSpy.args[4][0].amount).to.equal(BigInt('0x100')); // token1
        expect(erc20NoteSpy.args[5][0].amount).to.equal(BigInt('0x200')); // token2
        expect(rsp.broadcasterFeeCommitment).to.not.be.undefined;
        expect(rsp.broadcasterFeeCommitment?.commitmentCiphertext).to.deep.equal((0, helper_test_1.isV2Test)()
            ? mocks_test_1.MOCK_FORMATTED_BROADCASTER_FEE_COMMITMENT_CIPHERTEXT_V2
            : mocks_test_1.MOCK_FORMATTED_BROADCASTER_FEE_COMMITMENT_CIPHERTEXT_V3);
        // Add 9000 for the dummy tx variance
        expect(rsp.gasEstimate).to.equal(9000n + 200n);
    }).timeout(10000);
    it('Should get gas estimates for valid erc20 transfer: public wallet', async () => {
        stubGasEstimateSuccess();
        spyOnERC20Note();
        const rsp = await (0, tx_transfer_1.gasEstimateForUnprovenTransfer)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MEMO, MOCK_TOKEN_AMOUNT_RECIPIENTS, [], // nftAmountRecipients
        mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, true);
        expect(erc20NoteSpy.called).to.be.true;
        expect(erc20NoteSpy.args.length).to.equal(2); // Number of calls (without broadcaster fees)
        expect(erc20NoteSpy.args[0][0].amount).to.equal(BigInt('0x100')); // token1
        expect(erc20NoteSpy.args[1][0].amount).to.equal(BigInt('0x200')); // token2
        expect(rsp.broadcasterFeeCommitment).to.be.undefined;
        // Add 9000 for the dummy tx variance
        expect(rsp.gasEstimate).to.equal(9000n + 200n);
    }).timeout(10000);
    it('Should error on gas estimates for invalid erc20 transfer', async () => {
        stubGasEstimateSuccess();
        await expect((0, tx_transfer_1.gasEstimateForUnprovenTransfer)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MEMO, MOCK_TOKEN_AMOUNT_RECIPIENTS_INVALID, [], // nftAmountRecipients
        mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false)).rejectedWith('Invalid RAILGUN address.');
    });
    it('Should error on transfer gas estimate for ethers rejections', async () => {
        stubGasEstimateFailure();
        await expect((0, tx_transfer_1.gasEstimateForUnprovenTransfer)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MEMO, MOCK_TOKEN_AMOUNT_RECIPIENTS, [], // nftAmountRecipients
        mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false)).rejectedWith('test rejection - gas estimate');
    });
    // TRANSFER NFT - GAS ESTIMATE
    it('Should get gas estimates for valid NFT transfer', async () => {
        stubGasEstimateSuccess();
        spyOnNFTNote();
        const rsp = await (0, tx_transfer_1.gasEstimateForUnprovenTransfer)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MEMO, [], // erc20AmountRecipients
        mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, // nftAmountRecipients
        mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false);
        expect(nftNoteSpy.called).to.be.true;
        expect(nftNoteSpy.args.length).to.equal(4); // Number of calls - 2 for each of 2 broadcaster fee iterations
        expect(nftNoteSpy.args[0][0].tokenSubID).to.equal('0x01'); // nft1
        expect(nftNoteSpy.args[1][0].tokenSubID).to.equal('0x02'); // nft2
        expect(nftNoteSpy.args[2][0].tokenSubID).to.equal('0x01'); // nft1
        expect(nftNoteSpy.args[3][0].tokenSubID).to.equal('0x02'); // nft2
        expect(rsp.broadcasterFeeCommitment).to.not.be.undefined;
        expect(rsp.broadcasterFeeCommitment?.commitmentCiphertext).to.deep.equal((0, helper_test_1.isV2Test)()
            ? mocks_test_1.MOCK_FORMATTED_BROADCASTER_FEE_COMMITMENT_CIPHERTEXT_V2
            : mocks_test_1.MOCK_FORMATTED_BROADCASTER_FEE_COMMITMENT_CIPHERTEXT_V3);
        // Add 9000 for the dummy tx variance
        expect(rsp.gasEstimate).to.equal(9000n + 200n);
    }).timeout(10000);
    it('Should get gas estimates for valid NFT transfer: public wallet', async () => {
        stubGasEstimateSuccess();
        spyOnNFTNote();
        const rsp = await (0, tx_transfer_1.gasEstimateForUnprovenTransfer)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MEMO, [], // erc20AmountRecipients
        mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, true);
        expect(nftNoteSpy.called).to.be.true;
        expect(nftNoteSpy.args.length).to.equal(2); // Number of calls (without broadcaster fees)
        expect(nftNoteSpy.args[0][0].tokenSubID).to.equal('0x01'); // nft1
        expect(nftNoteSpy.args[1][0].tokenSubID).to.equal('0x02'); // nft2
        expect(rsp.broadcasterFeeCommitment).to.be.undefined;
        // Add 9000 for the dummy tx variance
        expect(rsp.gasEstimate).to.equal(9000n + 200n);
    }).timeout(10000);
    it('Should error on gas estimates for invalid NFT transfer', async () => {
        stubGasEstimateSuccess();
        await expect((0, tx_transfer_1.gasEstimateForUnprovenTransfer)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MEMO, [], // erc20AmountRecipients
        MOCK_NFT_AMOUNT_RECIPIENTS_INVALID, mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false)).rejectedWith('Invalid RAILGUN address.');
    });
    // TRANSFER ERC20 - PROVE AND SEND
    it('Should populate tx for valid transfer', async () => {
        stubGasEstimateSuccess();
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        spyOnERC20Note();
        spyOnNFTNote();
        await (0, tx_proof_transfer_1.generateTransferProof)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, true, // showSenderAddressToRecipient
        mocks_test_1.MOCK_MEMO, MOCK_TOKEN_AMOUNT_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, () => { });
        expect(erc20NoteSpy.called).to.be.true;
        expect(erc20NoteSpy.args[0][0].amount).to.equal(mocks_test_1.MOCK_TOKEN_FEE.amount);
        expect(nftNoteSpy.called).to.be.true;
        expect(nftNoteSpy.args[0][0].nftAddress).to.equal(mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS[0].nftAddress);
        const populateResponse = await (0, tx_transfer_1.populateProvedTransfer)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, true, // showSenderAddressToRecipient
        mocks_test_1.MOCK_MEMO, MOCK_TOKEN_AMOUNT_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails);
        expect(populateResponse.nullifiers).to.deep.equal([
            '0x0000000000000000000000000000000000000000000000000000000000000001',
            '0x0000000000000000000000000000000000000000000000000000000000000002',
        ]);
        const { transaction } = populateResponse;
        expect(transaction.nonce).to.equal(undefined);
        expect(transaction.gasPrice?.toString()).to.equal('4096');
        expect(transaction.gasLimit).to.equal(1200n);
        expect(transaction.value?.toString()).to.equal(undefined);
        expect(transaction.data).to.equal('0x0123');
        expect(transaction.to).to.equal(undefined);
        expect(transaction.chainId).to.equal(undefined);
        expect(transaction.type).to.equal(1);
    });
    it('Should error on populate transfer tx for unproved transaction', async () => {
        stubGasEstimateSuccess();
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        await expect((0, tx_transfer_1.populateProvedTransfer)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, false, // showSenderAddressToRecipient
        mocks_test_1.MOCK_MEMO, MOCK_TOKEN_AMOUNT_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails)).rejectedWith('Invalid proof for this transaction');
    });
    it('Should error on populate transfer tx when params changed (invalid cached proof)', async () => {
        stubGasEstimateSuccess();
        await (0, tx_proof_transfer_1.generateTransferProof)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, true, // showSenderAddressToRecipient
        mocks_test_1.MOCK_MEMO, MOCK_TOKEN_AMOUNT_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, () => { });
        await expect((0, tx_transfer_1.populateProvedTransfer)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, true, // showSenderAddressToRecipient
        mocks_test_1.MOCK_MEMO, MOCK_TOKEN_AMOUNT_RECIPIENTS_DIFFERENT, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails)).rejectedWith('Invalid proof for this transaction');
    });
});
//# sourceMappingURL=tx-transfer.test.js.map