"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = __importDefault(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const sinon_1 = __importDefault(require("sinon"));
const engine_1 = require("@railgun-community/engine");
const shared_models_1 = require("@railgun-community/shared-models");
const setup_test_1 = require("../../../tests/setup.test");
const mocks_test_1 = require("../../../tests/mocks.test");
const tx_unshield_1 = require("../tx-unshield");
const tx_proof_unshield_1 = require("../tx-proof-unshield");
const txGasDetailsModule = __importStar(require("../tx-gas-details"));
const wallets_1 = require("../../railgun/wallets/wallets");
const proof_cache_1 = require("../proof-cache");
const engine_stubs_test_1 = require("../../../tests/stubs/engine-stubs.test");
const helper_test_1 = require("../../../tests/helper.test");
let gasEstimateStub;
let railProveStub;
let railDummyProveStub;
let railTransactStub;
let relayAdaptPopulateUnshieldBaseToken;
let addUnshieldDataSpy;
let erc20NoteSpy;
let railgunWallet;
let broadcasterFeeERC20AmountRecipient;
const polygonRelayAdaptContract = shared_models_1.NETWORK_CONFIG[shared_models_1.NetworkName.Polygon].relayAdaptContract;
chai_1.default.use(chai_as_promised_1.default);
const { expect } = chai_1.default;
const txidVersion = (0, helper_test_1.getTestTXIDVersion)();
const mockERC20TokenData0 = (0, engine_1.getTokenDataERC20)(mocks_test_1.MOCK_TOKEN_AMOUNTS[0].tokenAddress);
const mockERC20TokenData1 = (0, engine_1.getTokenDataERC20)(mocks_test_1.MOCK_TOKEN_AMOUNTS[1].tokenAddress);
const mockNFTTokenData0 = (0, engine_1.getTokenDataNFT)(mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS_UNSHIELD[0].nftAddress, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS_UNSHIELD[0].nftTokenType, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS_UNSHIELD[0].tokenSubID);
const mockNFTTokenData1 = (0, engine_1.getTokenDataNFT)(mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS_UNSHIELD[1].nftAddress, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS_UNSHIELD[1].nftTokenType, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS_UNSHIELD[1].tokenSubID);
const MOCK_TOKEN_AMOUNTS_DIFFERENT = [
    {
        tokenAddress: mocks_test_1.MOCK_TOKEN_ADDRESS,
        amount: BigInt(0x0100),
    },
    {
        tokenAddress: mocks_test_1.MOCK_TOKEN_ADDRESS_2,
        amount: BigInt(0x0300),
    },
];
const overallBatchMinGasPrice = BigInt('0x1000');
const gasDetails = {
    evmGasType: shared_models_1.EVMGasType.Type1,
    gasEstimate: 1000n,
    gasPrice: overallBatchMinGasPrice,
};
const gasDetailsType2 = {
    evmGasType: shared_models_1.EVMGasType.Type2,
    gasEstimate: 1000n,
    maxFeePerGas: overallBatchMinGasPrice,
    maxPriorityFeePerGas: overallBatchMinGasPrice,
};
const MOCK_TOKEN_AMOUNT_RECIPIENTS_INVALID = mocks_test_1.MOCK_TOKEN_AMOUNTS.map(erc20Amount => ({
    ...erc20Amount,
    recipientAddress: mocks_test_1.MOCK_RAILGUN_WALLET_ADDRESS,
}));
const MOCK_TOKEN_AMOUNT_RECIPIENTS = mocks_test_1.MOCK_TOKEN_AMOUNTS.map(erc20Amount => ({
    ...erc20Amount,
    recipientAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
}));
const MOCK_TOKEN_AMOUNT_RECIPIENTS_DIFFERENT = MOCK_TOKEN_AMOUNTS_DIFFERENT.map(erc20Amount => ({
    ...erc20Amount,
    recipientAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
}));
const stubGasEstimateSuccess = () => {
    gasEstimateStub = sinon_1.default.stub(txGasDetailsModule, 'getGasEstimate').resolves(BigInt('200'));
};
const stubGasEstimateFailure = () => {
    gasEstimateStub = sinon_1.default.stub(txGasDetailsModule, 'getGasEstimate').rejects(new Error('test rejection - gas estimate'));
};
const spyOnSetUnshield = () => {
    addUnshieldDataSpy = sinon_1.default.spy(engine_1.TransactionBatch.prototype, 'addUnshieldData');
};
describe('tx-unshield', () => {
    before(async function run() {
        this.timeout(60000);
        await (0, setup_test_1.initTestEngine)();
        await (0, setup_test_1.initTestEngineNetworks)();
        const railgunWalletInfo = await (0, wallets_1.createRailgunWallet)(mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MNEMONIC, undefined);
        if (!(0, shared_models_1.isDefined)(railgunWalletInfo)) {
            throw new Error('Expected railgunWalletInfo');
        }
        railgunWallet = (0, wallets_1.fullWalletForID)(railgunWalletInfo.id);
        const broadcasterWalletInfo = await (0, wallets_1.createRailgunWallet)(mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MNEMONIC, undefined);
        if (!(0, shared_models_1.isDefined)(broadcasterWalletInfo)) {
            throw new Error('Expected broadcasterWalletInfo');
        }
        const broadcasterRailgunAddress = broadcasterWalletInfo.railgunAddress;
        broadcasterFeeERC20AmountRecipient = {
            ...mocks_test_1.MOCK_TOKEN_FEE,
            recipientAddress: broadcasterRailgunAddress,
        };
        railProveStub = sinon_1.default.stub(engine_1.TransactionBatch.prototype, 'generateTransactions').resolves({
            provedTransactions: [
                {
                    nullifiers: mocks_test_1.MOCK_NULLIFIERS,
                },
            ],
            preTransactionPOIsPerTxidLeafPerList: {},
        });
        railDummyProveStub = sinon_1.default.stub(engine_1.TransactionBatch.prototype, 'generateDummyTransactions').resolves([
            {
                txidVersion,
                commitments: mocks_test_1.MOCK_COMMITMENTS,
                boundParams: (0, helper_test_1.isV2Test)() ? mocks_test_1.MOCK_BOUND_PARAMS_V2 : mocks_test_1.MOCK_BOUND_PARAMS_V3,
                nullifiers: mocks_test_1.MOCK_NULLIFIERS,
            },
        ]);
        railTransactStub = sinon_1.default.stub(engine_1.RailgunVersionedSmartContracts, 'generateTransact').resolves({ data: '0x0123' });
        relayAdaptPopulateUnshieldBaseToken = sinon_1.default.stub(engine_1.RelayAdaptVersionedSmartContracts, 'populateUnshieldBaseToken').resolves({ data: '0x0123' });
        // For Unshield To Origin
        await (0, engine_stubs_test_1.createEngineWalletBalancesStub)(railgunWallet.addressKeys, mocks_test_1.MOCK_TOKEN_ADDRESS, 0);
    });
    afterEach(() => {
        gasEstimateStub?.restore();
        addUnshieldDataSpy?.restore();
        erc20NoteSpy?.restore();
    });
    after(async () => {
        railProveStub.restore();
        railDummyProveStub.restore();
        railTransactStub.restore();
        relayAdaptPopulateUnshieldBaseToken.restore();
        (0, engine_stubs_test_1.restoreEngineStubs)();
        await (0, setup_test_1.closeTestEngine)();
    });
    // UNSHIELD - GAS ESTIMATE
    it('Should get gas estimates for valid Unshield', async () => {
        stubGasEstimateSuccess();
        spyOnSetUnshield();
        const rsp = await (0, tx_unshield_1.gasEstimateForUnprovenUnshield)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, MOCK_TOKEN_AMOUNT_RECIPIENTS, [], // nftAmountRecipients
        mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false);
        expect(rsp.broadcasterFeeCommitment).to.not.be.undefined;
        expect(rsp.broadcasterFeeCommitment?.commitmentCiphertext).to.deep.equal((0, helper_test_1.isV2Test)()
            ? mocks_test_1.MOCK_FORMATTED_BROADCASTER_FEE_COMMITMENT_CIPHERTEXT_V2
            : mocks_test_1.MOCK_FORMATTED_BROADCASTER_FEE_COMMITMENT_CIPHERTEXT_V3);
        expect(addUnshieldDataSpy.called).to.be.true;
        expect(addUnshieldDataSpy.args).to.deep.equal([
            [
                {
                    toAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
                    tokenData: mockERC20TokenData1,
                    value: BigInt('0x0200'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
                    tokenData: mockERC20TokenData1,
                    value: BigInt('0x0200'),
                    allowOverride: false,
                },
            ], // run 2 - token 2
        ]);
        // Add 9000 for the dummy tx variance
        expect(rsp.gasEstimate).to.equal(9000n + 200n);
    }).timeout(30000);
    it('Should get gas estimates for valid Unshield To Origin', async () => {
        stubGasEstimateSuccess();
        spyOnSetUnshield();
        const rsp = await (0, tx_unshield_1.gasEstimateForUnprovenUnshieldToOrigin)(engine_stubs_test_1.MOCK_SHIELD_TXID_FOR_BALANCES, // originalShieldTxid
        txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, [
            {
                tokenAddress: mocks_test_1.MOCK_TOKEN_ADDRESS,
                amount: engine_stubs_test_1.MOCK_TOKEN_BALANCE,
                recipientAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
            },
        ], []);
        expect(rsp.broadcasterFeeCommitment).to.be.undefined;
        expect(addUnshieldDataSpy.called).to.be.true;
        expect(addUnshieldDataSpy.args).to.deep.equal([
            [
                {
                    toAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
                    tokenData: mockERC20TokenData0,
                    value: engine_stubs_test_1.MOCK_TOKEN_BALANCE,
                    allowOverride: false,
                },
            ],
        ]);
        // Add 9000 for the dummy tx variance
        expect(rsp.gasEstimate).to.equal(9000n + 200n);
    }).timeout(30000);
    it('Should error on gas estimates for invalid Unshield', async () => {
        stubGasEstimateSuccess();
        await expect((0, tx_unshield_1.gasEstimateForUnprovenUnshield)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, MOCK_TOKEN_AMOUNT_RECIPIENTS_INVALID, [], // nftAmountRecipients
        mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false)).rejectedWith('Invalid wallet address.');
    });
    it('Should error on unshield gas estimate for ethers rejections', async () => {
        stubGasEstimateFailure();
        await expect((0, tx_unshield_1.gasEstimateForUnprovenUnshield)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, MOCK_TOKEN_AMOUNT_RECIPIENTS, [], // nftAmountRecipients
        mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false)).rejectedWith('test rejection - gas estimate');
    });
    // UNSHIELD BASE TOKEN - GAS ESTIMATE
    it('Should get gas estimates for valid Unshield base token', async () => {
        stubGasEstimateSuccess();
        spyOnSetUnshield();
        const rsp = await (0, tx_unshield_1.gasEstimateForUnprovenUnshieldBaseToken)(txidVersion, shared_models_1.NetworkName.Polygon, mocks_test_1.MOCK_ETH_WALLET_ADDRESS, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS[0], mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false);
        expect(rsp.broadcasterFeeCommitment).to.not.be.undefined;
        expect(rsp.broadcasterFeeCommitment?.commitmentCiphertext).to.deep.equal((0, helper_test_1.isV2Test)()
            ? mocks_test_1.MOCK_FORMATTED_BROADCASTER_FEE_COMMITMENT_CIPHERTEXT_V2
            : mocks_test_1.MOCK_FORMATTED_BROADCASTER_FEE_COMMITMENT_CIPHERTEXT_V3);
        expect(addUnshieldDataSpy.called).to.be.true;
        expect(addUnshieldDataSpy.args).to.deep.equal([
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
        ]);
        // Add 9000 for the dummy tx variance
        expect(rsp.gasEstimate).to.equal(9000n + 200n);
    }).timeout(30000);
    it('Should get gas estimates for valid Unshield base token: public wallet', async () => {
        stubGasEstimateSuccess();
        spyOnSetUnshield();
        const rsp = await (0, tx_unshield_1.gasEstimateForUnprovenUnshieldBaseToken)(txidVersion, shared_models_1.NetworkName.Polygon, mocks_test_1.MOCK_ETH_WALLET_ADDRESS, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS[0], mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, true);
        expect(rsp.broadcasterFeeCommitment).to.be.undefined;
        expect(addUnshieldDataSpy.called).to.be.true;
        expect(addUnshieldDataSpy.args).to.deep.equal([
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
        ]);
        // Add 9000 for the dummy tx variance
        expect(rsp.gasEstimate).to.equal(9000n + 200n);
    }).timeout(30000);
    it('Should error on gas estimates for invalid Unshield base token', async () => {
        stubGasEstimateSuccess();
        await expect((0, tx_unshield_1.gasEstimateForUnprovenUnshieldBaseToken)(txidVersion, shared_models_1.NetworkName.Polygon, mocks_test_1.MOCK_RAILGUN_WALLET_ADDRESS, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS[0], mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false)).rejectedWith('Invalid wallet address.');
    });
    it('Should error on unshield base token gas estimate for ethers rejections', async () => {
        stubGasEstimateFailure();
        await expect((0, tx_unshield_1.gasEstimateForUnprovenUnshieldBaseToken)(txidVersion, shared_models_1.NetworkName.Polygon, mocks_test_1.MOCK_ETH_WALLET_ADDRESS, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS[0], mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false)).rejectedWith('test rejection - gas estimate');
    });
    // UNSHIELD - PROVE AND SEND
    it('Should populate tx for valid Unshield', async () => {
        stubGasEstimateSuccess();
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        spyOnSetUnshield();
        await (0, tx_proof_unshield_1.generateUnshieldProof)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, MOCK_TOKEN_AMOUNT_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS_UNSHIELD, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, () => { });
        expect(addUnshieldDataSpy.called).to.be.true;
        expect(addUnshieldDataSpy.args).to.deep.equal([
            [
                {
                    toAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
                    tokenData: mockERC20TokenData1,
                    value: BigInt('0x0200'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
                    tokenData: mockNFTTokenData0,
                    value: BigInt(1),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
                    tokenData: mockNFTTokenData1,
                    value: BigInt(2),
                    allowOverride: false,
                },
            ], // run 1 - NFT token 2
        ]);
        const populateResponse = await (0, tx_unshield_1.populateProvedUnshield)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, MOCK_TOKEN_AMOUNT_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS_UNSHIELD, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails);
        expect(populateResponse.nullifiers).to.deep.equal([
            '0x0000000000000000000000000000000000000000000000000000000000000001',
            '0x0000000000000000000000000000000000000000000000000000000000000002',
        ]);
        const { transaction } = populateResponse;
        expect(transaction.nonce).to.equal(undefined);
        expect(transaction.gasPrice?.toString()).to.equal('4096');
        expect(transaction.gasLimit).to.equal(1200n);
        expect(transaction.value?.toString()).to.equal(undefined);
        expect(transaction.data).to.equal('0x0123');
        expect(transaction.to).to.equal(undefined);
        expect(transaction.chainId).to.equal(undefined);
        expect(transaction.type).to.equal(1);
    });
    it('Should populate tx for valid Unshield To Origin', async () => {
        stubGasEstimateSuccess();
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        spyOnSetUnshield();
        await (0, tx_proof_unshield_1.generateUnshieldToOriginProof)(engine_stubs_test_1.MOCK_SHIELD_TXID_FOR_BALANCES, // originalShieldTxid
        txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, [
            {
                tokenAddress: mocks_test_1.MOCK_TOKEN_ADDRESS,
                amount: engine_stubs_test_1.MOCK_TOKEN_BALANCE,
                recipientAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
            },
        ], [], () => { });
        expect(addUnshieldDataSpy.called).to.be.true;
        expect(addUnshieldDataSpy.args).to.deep.equal([
            [
                {
                    toAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
                    tokenData: mockERC20TokenData0,
                    value: engine_stubs_test_1.MOCK_TOKEN_BALANCE,
                    allowOverride: false,
                },
            ], // run 1 - erc20 token 1
        ]);
        const populateResponse = await (0, tx_unshield_1.populateProvedUnshieldToOrigin)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, [
            {
                tokenAddress: mocks_test_1.MOCK_TOKEN_ADDRESS,
                amount: engine_stubs_test_1.MOCK_TOKEN_BALANCE,
                recipientAddress: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
            },
        ], [], gasDetailsType2);
        expect(populateResponse.nullifiers).to.deep.equal([
            '0x0000000000000000000000000000000000000000000000000000000000000001',
            '0x0000000000000000000000000000000000000000000000000000000000000002',
        ]);
        const { transaction } = populateResponse;
        expect(transaction.nonce).to.equal(undefined);
        expect(transaction.gasLimit).to.equal(1200n);
        expect(transaction.value?.toString()).to.equal(undefined);
        expect(transaction.data).to.equal('0x0123');
        expect(transaction.to).to.equal(undefined);
        expect(transaction.chainId).to.equal(undefined);
        expect(transaction.type).to.equal(2);
    });
    it('Should error on populate tx for invalid Unshield', async () => {
        stubGasEstimateSuccess();
        await expect((0, tx_unshield_1.populateProvedUnshield)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, MOCK_TOKEN_AMOUNT_RECIPIENTS_DIFFERENT, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS_UNSHIELD, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails)).rejectedWith('Invalid proof for this transaction');
    });
    it('Should error on populate unshield tx for unproved transaction', async () => {
        stubGasEstimateSuccess();
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        await expect((0, tx_unshield_1.populateProvedUnshield)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, MOCK_TOKEN_AMOUNT_RECIPIENTS, [], // nftAmountRecipients
        broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails)).rejectedWith('Invalid proof for this transaction');
    });
    it('Should error on populate unshield tx when params changed (invalid cached proof)', async () => {
        stubGasEstimateSuccess();
        await (0, tx_proof_unshield_1.generateUnshieldProof)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, MOCK_TOKEN_AMOUNT_RECIPIENTS, [], // nftAmountRecipients
        broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, () => { });
        await expect((0, tx_unshield_1.populateProvedUnshield)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, MOCK_TOKEN_AMOUNT_RECIPIENTS_DIFFERENT, [], // nftAmountRecipients
        broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails)).rejectedWith('Invalid proof for this transaction');
    });
    // UNSHIELD BASE TOKEN - PROVE AND SEND
    it('Should populate tx for valid Unshield Base Token', async () => {
        stubGasEstimateSuccess();
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        spyOnSetUnshield();
        await (0, tx_proof_unshield_1.generateUnshieldBaseTokenProof)(txidVersion, shared_models_1.NetworkName.Polygon, mocks_test_1.MOCK_ETH_WALLET_ADDRESS, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS[0], broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, () => { });
        expect(addUnshieldDataSpy.called).to.be.true;
        expect(addUnshieldDataSpy.args).to.deep.equal([
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ], // Actual prove
        ]);
        const populateResponse = await (0, tx_unshield_1.populateProvedUnshieldBaseToken)(txidVersion, shared_models_1.NetworkName.Polygon, mocks_test_1.MOCK_ETH_WALLET_ADDRESS, railgunWallet.id, mocks_test_1.MOCK_TOKEN_AMOUNTS[0], broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails);
        const { transaction } = populateResponse;
        expect(transaction.nonce).to.equal(undefined);
        expect(transaction.gasPrice?.toString()).to.equal('4096');
        expect(transaction.gasLimit).to.equal(1200n);
        expect(transaction.value?.toString()).to.equal(undefined);
        expect(transaction.data).to.equal('0x0123');
        expect(transaction.to).to.equal(undefined);
        expect(transaction.chainId).to.equal(undefined);
        expect(transaction.type).to.equal(1);
    }).timeout(60000);
    it('Should error on populate tx for invalid Unshield Base Token', async () => {
        stubGasEstimateSuccess();
        await expect((0, tx_unshield_1.populateProvedUnshieldBaseToken)(txidVersion, shared_models_1.NetworkName.Polygon, mocks_test_1.MOCK_ETH_WALLET_ADDRESS, railgunWallet.id, MOCK_TOKEN_AMOUNTS_DIFFERENT[1], broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails)).rejectedWith('Invalid proof for this transaction');
    });
    it('Should error on populate Unshield Base Token tx for unproved transaction', async () => {
        stubGasEstimateSuccess();
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        await expect((0, tx_unshield_1.populateProvedUnshieldBaseToken)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_ETH_WALLET_ADDRESS, mocks_test_1.MOCK_TOKEN_AMOUNTS[0], broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails)).rejectedWith('Invalid proof for this transaction');
    });
    it('Should error on populate Unshield Base Token tx when params changed (invalid cached proof)', async () => {
        stubGasEstimateSuccess();
        await (0, tx_proof_unshield_1.generateUnshieldBaseTokenProof)(txidVersion, shared_models_1.NetworkName.Polygon, mocks_test_1.MOCK_ETH_WALLET_ADDRESS, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS[1], broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, () => { });
        await expect((0, tx_unshield_1.populateProvedUnshieldBaseToken)(txidVersion, shared_models_1.NetworkName.Polygon, mocks_test_1.MOCK_ETH_WALLET_ADDRESS, railgunWallet.id, MOCK_TOKEN_AMOUNTS_DIFFERENT[1], broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails)).rejectedWith('Invalid proof for this transaction');
    });
});
//# sourceMappingURL=tx-unshield.test.js.map