"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = __importDefault(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const sinon_1 = __importDefault(require("sinon"));
const engine_1 = require("@railgun-community/engine");
const shared_models_1 = require("@railgun-community/shared-models");
const setup_test_1 = require("../../../tests/setup.test");
const mocks_test_1 = require("../../../tests/mocks.test");
const wallets_1 = require("../../railgun/wallets/wallets");
const proof_cache_1 = require("../proof-cache");
const tx_cross_contract_calls_1 = require("../tx-cross-contract-calls");
const formatted_relay_adapt_error_logs_json_1 = __importDefault(require("./json/formatted-relay-adapt-error-logs.json"));
const ethers_1 = require("ethers");
const helper_test_1 = require("../../../tests/helper.test");
let gasEstimateStub;
let railProveStub;
let railDummyProveStub;
let relayAdaptPopulateCrossContractCalls;
let relayAdaptGasEstimateStub;
let addUnshieldDataSpy;
let erc20NoteSpy;
let railgunWallet;
let broadcasterFeeERC20AmountRecipient;
const polygonRelayAdaptContract = shared_models_1.NETWORK_CONFIG[shared_models_1.NetworkName.Polygon].relayAdaptContract;
chai_1.default.use(chai_as_promised_1.default);
const { expect } = chai_1.default;
const txidVersion = (0, helper_test_1.getTestTXIDVersion)();
const mockERC20TokenData0 = (0, engine_1.getTokenDataERC20)(mocks_test_1.MOCK_TOKEN_AMOUNTS[0].tokenAddress);
const mockERC20TokenData1 = (0, engine_1.getTokenDataERC20)(mocks_test_1.MOCK_TOKEN_AMOUNTS[1].tokenAddress);
const mockNFTTokenData0 = (0, tx_cross_contract_calls_1.createNFTTokenDataFromRailgunNFTAmount)(mocks_test_1.MOCK_NFT_AMOUNTS[0]);
const mockNFTTokenData1 = (0, tx_cross_contract_calls_1.createNFTTokenDataFromRailgunNFTAmount)(mocks_test_1.MOCK_NFT_AMOUNTS[1]);
const mockCrossContractCalls = [
    {
        to: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
        data: '0x0789',
        value: BigInt('0x01'),
    },
    {
        to: mocks_test_1.MOCK_ETH_WALLET_ADDRESS,
        data: '0x9789',
        value: BigInt('0x02'),
    },
];
const MOCK_TOKEN_AMOUNTS_DIFFERENT = [
    {
        tokenAddress: mocks_test_1.MOCK_TOKEN_ADDRESS,
        amount: 100n,
    },
    {
        tokenAddress: mocks_test_1.MOCK_TOKEN_ADDRESS_2,
        amount: 300n,
    },
];
const overallBatchMinGasPrice = BigInt('0x1000');
const minGasLimit = engine_1.MINIMUM_RELAY_ADAPT_CROSS_CONTRACT_CALLS_GAS_LIMIT_V2;
const gasDetails = {
    evmGasType: shared_models_1.EVMGasType.Type1,
    gasEstimate: 2000n,
    gasPrice: overallBatchMinGasPrice,
};
const stubRelayAdaptGasEstimate = () => {
    relayAdaptGasEstimateStub = sinon_1.default.stub(engine_1.RelayAdaptVersionedSmartContracts, 'estimateGasWithErrorHandler').resolves(BigInt('200'));
};
const stubGasEstimateSuccess = () => {
    gasEstimateStub = sinon_1.default.stub(ethers_1.FallbackProvider.prototype, 'estimateGas').resolves(BigInt('200'));
};
const stubRelayAdaptGasEstimateFailure = () => {
    relayAdaptGasEstimateStub = sinon_1.default.stub(engine_1.RelayAdaptVersionedSmartContracts, 'estimateGasWithErrorHandler').rejects(new Error('RelayAdapt multicall failed at index UNKNOWN.'));
};
const spyOnSetUnshield = () => {
    addUnshieldDataSpy = sinon_1.default.spy(engine_1.TransactionBatch.prototype, 'addUnshieldData');
};
describe('tx-cross-contract-calls', () => {
    before(async function run() {
        this.timeout(60000);
        await (0, setup_test_1.initTestEngine)();
        await (0, setup_test_1.initTestEngineNetworks)(shared_models_1.NetworkName.Polygon, mocks_test_1.MOCK_FALLBACK_PROVIDER_JSON_CONFIG_POLYGON);
        const railgunWalletInfo = await (0, wallets_1.createRailgunWallet)(mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MNEMONIC, undefined);
        if (!(0, shared_models_1.isDefined)(railgunWalletInfo)) {
            throw new Error('Expected railgunWalletInfo');
        }
        railgunWallet = (0, wallets_1.fullWalletForID)(railgunWalletInfo.id);
        const broadcasterWalletInfo = await (0, wallets_1.createRailgunWallet)(mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_MNEMONIC, undefined);
        if (!(0, shared_models_1.isDefined)(broadcasterWalletInfo)) {
            throw new Error('Expected broadcasterWalletInfo');
        }
        const broadcasterRailgunAddress = broadcasterWalletInfo.railgunAddress;
        broadcasterFeeERC20AmountRecipient = {
            ...mocks_test_1.MOCK_TOKEN_FEE,
            recipientAddress: broadcasterRailgunAddress,
        };
        railProveStub = sinon_1.default.stub(engine_1.TransactionBatch.prototype, 'generateTransactions').resolves({
            provedTransactions: [
                {
                    nullifiers: mocks_test_1.MOCK_NULLIFIERS,
                },
            ],
            preTransactionPOIsPerTxidLeafPerList: {},
        });
        railDummyProveStub = sinon_1.default.stub(engine_1.TransactionBatch.prototype, 'generateDummyTransactions').resolves([
            {
                txidVersion,
                commitments: mocks_test_1.MOCK_COMMITMENTS,
                boundParams: (0, helper_test_1.isV2Test)() ? mocks_test_1.MOCK_BOUND_PARAMS_V2 : mocks_test_1.MOCK_BOUND_PARAMS_V3,
                nullifiers: mocks_test_1.MOCK_NULLIFIERS,
            },
        ]);
        relayAdaptPopulateCrossContractCalls = sinon_1.default.stub(engine_1.RelayAdaptVersionedSmartContracts, 'populateCrossContractCalls').resolves({ data: '0x0123' });
    });
    afterEach(() => {
        gasEstimateStub?.restore();
        addUnshieldDataSpy?.restore();
        erc20NoteSpy?.restore();
        relayAdaptGasEstimateStub?.restore();
    });
    after(async () => {
        railProveStub.restore();
        railDummyProveStub.restore();
        relayAdaptPopulateCrossContractCalls.restore();
        await (0, setup_test_1.closeTestEngine)();
    });
    // GAS ESTIMATE
    it('Should get gas estimates for valid cross contract calls', async () => {
        stubRelayAdaptGasEstimate();
        spyOnSetUnshield();
        const rsp = await (0, tx_cross_contract_calls_1.gasEstimateForUnprovenCrossContractCalls)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS, mocks_test_1.MOCK_NFT_AMOUNTS, mocks_test_1.MOCK_ERC20_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, mockCrossContractCalls, mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false, // sendWithPublicWallet
        minGasLimit);
        expect(rsp.broadcasterFeeCommitment).to.not.be.undefined;
        expect(rsp.broadcasterFeeCommitment?.commitmentCiphertext).to.deep.equal((0, helper_test_1.isV2Test)()
            ? mocks_test_1.MOCK_FORMATTED_BROADCASTER_FEE_COMMITMENT_CIPHERTEXT_V2
            : mocks_test_1.MOCK_FORMATTED_BROADCASTER_FEE_COMMITMENT_CIPHERTEXT_V3);
        expect(addUnshieldDataSpy.called).to.be.true;
        expect(addUnshieldDataSpy.args).to.deep.equal([
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData1,
                    value: BigInt('0x0200'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockNFTTokenData0,
                    value: BigInt('1'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockNFTTokenData1,
                    value: BigInt('2'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData1,
                    value: BigInt('0x0200'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockNFTTokenData0,
                    value: BigInt('1'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockNFTTokenData1,
                    value: BigInt('2'),
                    allowOverride: false,
                },
            ], // run 2 - nft 1
        ]);
        // Add 9000 for the dummy tx variance
        // expect(rsp.gasEstimate).to.equal(9000n + 280n);
        expect(rsp.gasEstimate).to.equal(3200000n); // Cross Contract Minimum
    }).timeout(10000);
    it('Should get gas estimates for valid cross contract calls, public wallet', async () => {
        stubRelayAdaptGasEstimate();
        spyOnSetUnshield();
        const rsp = await (0, tx_cross_contract_calls_1.gasEstimateForUnprovenCrossContractCalls)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS, mocks_test_1.MOCK_NFT_AMOUNTS, mocks_test_1.MOCK_ERC20_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, mockCrossContractCalls, mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, true, // sendWithPublicWallet
        minGasLimit);
        expect(rsp.broadcasterFeeCommitment).to.be.undefined;
        expect(addUnshieldDataSpy.called).to.be.true;
        expect(addUnshieldDataSpy.args).to.deep.equal([
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData1,
                    value: BigInt('0x0200'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockNFTTokenData0,
                    value: BigInt('1'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockNFTTokenData1,
                    value: BigInt('2'),
                    allowOverride: false,
                },
            ], // run 1 - nft 1
        ]);
        // Add 9000 for the dummy tx variance
        // expect(rsp.gasEstimate).to.equal(9000n + 280n);
        expect(rsp.gasEstimate).to.equal(3200000n); // Cross Contract Minimum
    }).timeout(10000);
    it('Should error on gas estimates for invalid cross contract calls', async () => {
        stubGasEstimateSuccess();
        await expect((0, tx_cross_contract_calls_1.gasEstimateForUnprovenCrossContractCalls)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS, mocks_test_1.MOCK_NFT_AMOUNTS, mocks_test_1.MOCK_ERC20_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, [{ data: 'abc' }], // Invalid
        mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false, // sendWithPublicWallet
        minGasLimit)).rejectedWith(`Cross-contract calls require to and data fields.`);
    });
    it('Should error on cross contract calls gas estimate for ethers rejections', async () => {
        stubRelayAdaptGasEstimateFailure();
        await expect((0, tx_cross_contract_calls_1.gasEstimateForUnprovenCrossContractCalls)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS, mocks_test_1.MOCK_NFT_AMOUNTS, mocks_test_1.MOCK_ERC20_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, mockCrossContractCalls, mocks_test_1.MOCK_TRANSACTION_GAS_DETAILS_SERIALIZED_TYPE_2, mocks_test_1.MOCK_FEE_TOKEN_DETAILS, false, // sendWithPublicWallet
        minGasLimit)).rejectedWith('RelayAdapt multicall failed at index UNKNOWN.');
    });
    // PROVE AND SEND
    it('Should populate tx for valid cross contract calls', async () => {
        stubGasEstimateSuccess();
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        spyOnSetUnshield();
        await (0, tx_cross_contract_calls_1.generateCrossContractCallsProof)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS, mocks_test_1.MOCK_NFT_AMOUNTS, mocks_test_1.MOCK_ERC20_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, mockCrossContractCalls, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, minGasLimit, () => { });
        expect(addUnshieldDataSpy.called).to.be.true;
        expect(addUnshieldDataSpy.args).to.deep.equal([
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData1,
                    value: BigInt('0x0200'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockNFTTokenData0,
                    value: BigInt('1'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockNFTTokenData1,
                    value: BigInt('2'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData0,
                    value: BigInt('0x0100'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockERC20TokenData1,
                    value: BigInt('0x0200'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockNFTTokenData0,
                    value: BigInt('1'),
                    allowOverride: false,
                },
            ],
            [
                {
                    toAddress: polygonRelayAdaptContract,
                    tokenData: mockNFTTokenData1,
                    value: BigInt('2'),
                    allowOverride: false,
                },
            ], // actual proof - nft 1
        ]);
        const populateResponse = await (0, tx_cross_contract_calls_1.populateProvedCrossContractCalls)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_TOKEN_AMOUNTS, mocks_test_1.MOCK_NFT_AMOUNTS, mocks_test_1.MOCK_ERC20_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, mockCrossContractCalls, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails);
        expect(populateResponse.nullifiers).to.deep.equal([
            '0x0000000000000000000000000000000000000000000000000000000000000001',
            '0x0000000000000000000000000000000000000000000000000000000000000002',
        ]);
        const { transaction } = populateResponse;
        expect(transaction.nonce).to.equal(undefined);
        expect(transaction.gasPrice?.toString()).to.equal('4096');
        expect(transaction.gasLimit).to.equal(2400n);
        expect(transaction.value?.toString()).to.equal(undefined);
        expect(transaction.data).to.equal('0x0123');
        expect(transaction.to).to.equal(undefined);
        expect(transaction.chainId).to.equal(undefined);
        expect(transaction.type).to.equal(1);
    });
    it('Should error on populate tx for invalid cross contract calls', async () => {
        stubGasEstimateSuccess();
        await expect((0, tx_cross_contract_calls_1.populateProvedCrossContractCalls)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, MOCK_TOKEN_AMOUNTS_DIFFERENT, mocks_test_1.MOCK_NFT_AMOUNTS, mocks_test_1.MOCK_ERC20_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, [{ data: '123' }], // Invalid
        broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails)).rejectedWith('Invalid proof for this transaction');
    });
    it('Should error on populate cross contract calls tx for unproved transaction', async () => {
        stubGasEstimateSuccess();
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        await expect((0, tx_cross_contract_calls_1.populateProvedCrossContractCalls)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_TOKEN_AMOUNTS, mocks_test_1.MOCK_NFT_AMOUNTS, mocks_test_1.MOCK_ERC20_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, mockCrossContractCalls, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails)).rejectedWith('Invalid proof for this transaction');
    });
    it('Should error on populate cross contract calls tx when params changed (invalid cached proof)', async () => {
        stubGasEstimateSuccess();
        await (0, tx_cross_contract_calls_1.generateCrossContractCallsProof)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, mocks_test_1.MOCK_DB_ENCRYPTION_KEY, mocks_test_1.MOCK_TOKEN_AMOUNTS, mocks_test_1.MOCK_NFT_AMOUNTS, mocks_test_1.MOCK_ERC20_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, mockCrossContractCalls, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, minGasLimit, () => { });
        await expect((0, tx_cross_contract_calls_1.populateProvedCrossContractCalls)(txidVersion, shared_models_1.NetworkName.Polygon, railgunWallet.id, MOCK_TOKEN_AMOUNTS_DIFFERENT, mocks_test_1.MOCK_NFT_AMOUNTS, mocks_test_1.MOCK_ERC20_RECIPIENTS, mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS, mockCrossContractCalls, broadcasterFeeERC20AmountRecipient, false, // sendWithPublicWallet
        overallBatchMinGasPrice, gasDetails)).rejectedWith('Invalid proof for this transaction');
    });
    it('Should decode and parse relay adapt error logs (from failed Sushi V2 LP removal)', () => {
        const transactionError = (0, tx_cross_contract_calls_1.getRelayAdaptTransactionError)(txidVersion, formatted_relay_adapt_error_logs_json_1.default);
        expect(transactionError).to.equal('ds-math-sub-underflow');
    });
    it('Should parse relay adapt log revert data', () => {
        const transactionError = (0, tx_cross_contract_calls_1.parseRelayAdaptReturnValue)(txidVersion, `0x5c0dee5d00000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006408c379a00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000001564732d6d6174682d7375622d756e646572666c6f77000000000000000000000000000000000000000000000000000000000000000000000000000000`);
        expect(transactionError).to.equal('ds-math-sub-underflow');
    });
    it('Should parse relay adapt revert data from railgun cookbook', () => {
        const transactionError = (0, tx_cross_contract_calls_1.parseRelayAdaptReturnValue)(txidVersion, `0x5c0dee5d00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000002d52656c617941646170743a205265667573696e6720746f2063616c6c205261696c67756e20636f6e747261637400000000000000000000000000000000000000`);
        expect(transactionError).to.equal('RelayAdapt: Refusing to call Railgun contract');
    });
});
//# sourceMappingURL=tx-cross-contract-calls.test.js.map