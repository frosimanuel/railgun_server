"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = __importDefault(require("chai"));
const chai_as_promised_1 = __importDefault(require("chai-as-promised"));
const shared_models_1 = require("@railgun-community/shared-models");
const mocks_test_1 = require("../../../tests/mocks.test");
const proof_cache_1 = require("../proof-cache");
const helper_test_1 = require("../../../tests/helper.test");
chai_1.default.use(chai_as_promised_1.default);
const { expect } = chai_1.default;
const networkName = shared_models_1.NetworkName.BNBChain;
const txidVersion = (0, helper_test_1.getTestTXIDVersion)();
const railgunWalletID = '123';
const showSenderAddressToRecipient = true;
const memoText = 'Some memo';
const recipientAddress = '0x12345';
const erc20AmountRecipients = mocks_test_1.MOCK_TOKEN_AMOUNTS.map(erc20Amount => ({
    ...erc20Amount,
    recipientAddress,
}));
const nftAmountRecipients = mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS;
const broadcasterFeeERC20AmountRecipient = {
    ...mocks_test_1.MOCK_TOKEN_FEE,
    recipientAddress: mocks_test_1.MOCK_RAILGUN_WALLET_ADDRESS,
};
const crossContractCalls = [
    { to: '0x4567', data: '0x' },
];
const relayAdaptShieldERC20Recipients = [
    { tokenAddress: '0x123', recipientAddress: mocks_test_1.MOCK_RAILGUN_WALLET_ADDRESS },
];
const relayAdaptUnshieldERC20Amounts = [mocks_test_1.MOCK_TOKEN_FEE];
const relayAdaptUnshieldNFTAmounts = mocks_test_1.MOCK_NFT_AMOUNTS;
const relayAdaptShieldNFTRecipients = mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS;
const nullifiers = ['0x1234'];
const sendWithPublicWallet = false;
const overallBatchMinGasPrice = BigInt('0x1000');
const preTransactionPOIsPerTxidLeafPerList = {};
const setCached = (proofType) => {
    (0, proof_cache_1.setCachedProvedTransaction)({
        proofType,
        txidVersion,
        transaction: {},
        showSenderAddressToRecipient,
        memoText,
        railgunWalletID,
        erc20AmountRecipients,
        nftAmountRecipients,
        relayAdaptUnshieldERC20Amounts,
        relayAdaptUnshieldNFTAmounts,
        relayAdaptShieldERC20Recipients,
        relayAdaptShieldNFTRecipients,
        crossContractCalls,
        broadcasterFeeERC20AmountRecipient,
        sendWithPublicWallet: false,
        preTransactionPOIsPerTxidLeafPerList,
        overallBatchMinGasPrice,
        nullifiers,
    });
};
describe('proof-cache', () => {
    it('Should validate cached transaction correctly', () => {
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('No proof found.');
        setCached(shared_models_1.ProofType.CrossContractCalls);
        // Same same
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.not.throw();
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        'something else', networkName, shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: txidVersion.');
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.Unshield, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: proofType.');
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.Transfer, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: proofType.');
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.CrossContractCalls, '987', showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: railgunWalletID.');
        // Set new for Transfer proof type
        setCached(shared_models_1.ProofType.Transfer);
        // Requires ProofType.Transfer
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.Transfer, railgunWalletID, false, // showSenderAddressToRecipient
        memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: showSenderAddressToRecipient.');
        // Requires ProofType.Transfer
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.Transfer, railgunWalletID, showSenderAddressToRecipient, 'different memo', erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: memoText.');
        // Requires ProofType.Transfer
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.Transfer, railgunWalletID, showSenderAddressToRecipient, memoText, [
            {
                tokenAddress: '0x765',
                amount: 100n,
                recipientAddress: '0x123',
            },
        ], nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: erc20AmountRecipients.');
        setCached(shared_models_1.ProofType.CrossContractCalls);
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, [mocks_test_1.MOCK_NFT_AMOUNT_RECIPIENTS[0]], relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: nftAmountRecipients.');
        // Note: requires ProofType.CrossContractCalls
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, [
            {
                tokenAddress: '0x765',
                amount: 100n,
            },
        ], relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: relayAdaptUnshieldERC20Amounts.');
        // Note: requires ProofType.CrossContractCalls
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, [mocks_test_1.MOCK_NFT_AMOUNTS[0]], relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: relayAdaptUnshieldNFTAmounts.');
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, 
        // proofType (ProofType.Transfer) will not validate relayAdaptUnshieldERC20Amounts.. requires ProofType.CrossContractCalls
        shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, [
            {
                tokenAddress: 'test',
                recipientAddress: mocks_test_1.MOCK_RAILGUN_WALLET_ADDRESS,
            },
        ], relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: relayAdaptShieldERC20Recipients.');
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, 
        // proofType (ProofType.Transfer) will not validate relayAdaptUnshieldERC20Amounts.. requires ProofType.CrossContractCalls
        shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, [], relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: relayAdaptShieldERC20Recipients.');
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, 
        // proofType (ProofType.Transfer) will not validate relayAdaptUnshieldERC20Amounts.. requires ProofType.CrossContractCalls
        shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, [mocks_test_1.MOCK_NFT_AMOUNTS[0]], crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: relayAdaptShieldNFTRecipients.');
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, 
        // proofType (ProofType.Transfer) will not validate relayAdaptUnshieldERC20Amounts.. requires ProofType.CrossContractCalls
        shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, [{ to: 'test', data: '0x' }], broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: crossContractCalls.');
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, {
            tokenAddress: '0x765',
            amount: 100n,
            recipientAddress: '0x1233',
        }, sendWithPublicWallet, overallBatchMinGasPrice)).to.throw('Mismatch: broadcasterFeeERC20AmountRecipient.');
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, true, // sendWithPublicWallet
        overallBatchMinGasPrice)).to.throw('Mismatch: sendWithPublicWallet.');
        expect(() => (0, proof_cache_1.validateCachedProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.CrossContractCalls, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, BigInt('0x2000'))).to.throw('Mismatch: overallBatchMinGasPrice.');
    });
});
//# sourceMappingURL=proof-cache.test.js.map