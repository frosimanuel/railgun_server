"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateUnshieldBaseTokenProof = exports.generateUnshieldToOriginProof = exports.generateUnshieldProof = void 0;
const shared_models_1 = require("@railgun-community/shared-models");
const tx_generator_1 = require("./tx-generator");
const wallets_1 = require("../railgun/wallets/wallets");
const proof_cache_1 = require("./proof-cache");
const engine_1 = require("@railgun-community/engine");
const blocked_address_1 = require("../../utils/blocked-address");
const tx_cross_contract_calls_1 = require("./tx-cross-contract-calls");
const error_1 = require("../../utils/error");
const generateUnshieldProof = async (txidVersion, networkName, railgunWalletID, encryptionKey, erc20AmountRecipients, nftAmountRecipients, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice, progressCallback) => {
    try {
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        const { provedTransactions, preTransactionPOIsPerTxidLeafPerList } = await (0, tx_generator_1.generateProofTransactions)(shared_models_1.ProofType.Unshield, networkName, railgunWalletID, txidVersion, encryptionKey, false, // showSenderAddressToRecipient
        undefined, // memoText
        erc20AmountRecipients, nftAmountRecipients, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, undefined, // relayAdaptID
        false, // useDummyProof
        overallBatchMinGasPrice, progressCallback);
        const transaction = await (0, tx_generator_1.generateTransact)(txidVersion, provedTransactions, networkName);
        const nullifiers = (0, tx_generator_1.nullifiersForTransactions)(provedTransactions);
        (0, proof_cache_1.setCachedProvedTransaction)({
            proofType: shared_models_1.ProofType.Unshield,
            txidVersion,
            railgunWalletID,
            showSenderAddressToRecipient: false,
            memoText: undefined,
            erc20AmountRecipients,
            nftAmountRecipients,
            relayAdaptUnshieldERC20Amounts: undefined,
            relayAdaptUnshieldNFTAmounts: undefined,
            relayAdaptShieldERC20Recipients: undefined,
            relayAdaptShieldNFTRecipients: undefined,
            crossContractCalls: undefined,
            broadcasterFeeERC20AmountRecipient,
            transaction,
            sendWithPublicWallet,
            preTransactionPOIsPerTxidLeafPerList,
            overallBatchMinGasPrice,
            nullifiers,
        });
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.generateUnshieldProof.name, err);
    }
};
exports.generateUnshieldProof = generateUnshieldProof;
const generateUnshieldToOriginProof = async (originalShieldTxid, txidVersion, networkName, railgunWalletID, encryptionKey, erc20AmountRecipients, nftAmountRecipients, progressCallback) => {
    try {
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        const { provedTransactions, preTransactionPOIsPerTxidLeafPerList } = await (0, tx_generator_1.generateProofTransactions)(shared_models_1.ProofType.Unshield, networkName, railgunWalletID, txidVersion, encryptionKey, false, // showSenderAddressToRecipient
        undefined, // memoText
        erc20AmountRecipients, nftAmountRecipients, undefined, // broadcasterFeeERC20AmountRecipient
        true, // sendWithPublicWallet
        undefined, // relayAdaptID
        false, // useDummyProof
        undefined, // overallBatchMinGasPrice
        progressCallback, originalShieldTxid);
        const transaction = await (0, tx_generator_1.generateTransact)(txidVersion, provedTransactions, networkName);
        const nullifiers = (0, tx_generator_1.nullifiersForTransactions)(provedTransactions);
        (0, proof_cache_1.setCachedProvedTransaction)({
            proofType: shared_models_1.ProofType.Unshield,
            txidVersion,
            railgunWalletID,
            showSenderAddressToRecipient: false,
            memoText: undefined,
            erc20AmountRecipients,
            nftAmountRecipients,
            relayAdaptUnshieldERC20Amounts: undefined,
            relayAdaptUnshieldNFTAmounts: undefined,
            relayAdaptShieldERC20Recipients: undefined,
            relayAdaptShieldNFTRecipients: undefined,
            crossContractCalls: undefined,
            broadcasterFeeERC20AmountRecipient: undefined,
            transaction,
            sendWithPublicWallet: true,
            preTransactionPOIsPerTxidLeafPerList,
            overallBatchMinGasPrice: undefined,
            nullifiers,
        });
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.generateUnshieldProof.name, err);
    }
};
exports.generateUnshieldToOriginProof = generateUnshieldToOriginProof;
const generateUnshieldBaseTokenProof = async (txidVersion, networkName, publicWalletAddress, railgunWalletID, encryptionKey, wrappedERC20Amount, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice, progressCallback) => {
    try {
        (0, blocked_address_1.assertNotBlockedAddress)(publicWalletAddress);
        (0, wallets_1.assertValidEthAddress)(publicWalletAddress);
        (0, proof_cache_1.setCachedProvedTransaction)(undefined);
        const erc20AmountRecipients = [
            {
                ...wrappedERC20Amount,
                recipientAddress: publicWalletAddress,
            },
        ];
        const relayAdaptUnshieldERC20Amounts = [
            wrappedERC20Amount,
        ];
        const relayAdaptUnshieldERC20AmountRecipients = (0, tx_cross_contract_calls_1.createRelayAdaptUnshieldERC20AmountRecipients)(txidVersion, networkName, [
            wrappedERC20Amount,
        ]);
        // Empty NFT recipients.
        const nftAmountRecipients = [];
        const relayAdaptUnshieldNFTAmountRecipients = [];
        // Generate dummy txs for relay adapt params.
        const dummyTxs = await (0, tx_generator_1.generateDummyProofTransactions)(shared_models_1.ProofType.UnshieldBaseToken, networkName, railgunWalletID, txidVersion, encryptionKey, false, // showSenderAddressToRecipient
        undefined, // memoText
        relayAdaptUnshieldERC20AmountRecipients, relayAdaptUnshieldNFTAmountRecipients, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice);
        const { chain } = shared_models_1.NETWORK_CONFIG[networkName];
        const relayAdaptParamsRandom = engine_1.ByteUtils.randomHex(31);
        const relayAdaptParams = await engine_1.RelayAdaptVersionedSmartContracts.getRelayAdaptParamsUnshieldBaseToken(txidVersion, chain, dummyTxs, publicWalletAddress, relayAdaptParamsRandom, sendWithPublicWallet);
        const relayAdaptContract = engine_1.RelayAdaptVersionedSmartContracts.getRelayAdaptContract(txidVersion, chain);
        const relayAdaptID = {
            contract: relayAdaptContract.address,
            parameters: relayAdaptParams,
        };
        const showSenderAddressToRecipient = false;
        const memoText = undefined;
        // Generate final txs with relay adapt ID.
        const { provedTransactions, preTransactionPOIsPerTxidLeafPerList } = await (0, tx_generator_1.generateProofTransactions)(shared_models_1.ProofType.UnshieldBaseToken, networkName, railgunWalletID, txidVersion, encryptionKey, showSenderAddressToRecipient, memoText, relayAdaptUnshieldERC20AmountRecipients, relayAdaptUnshieldNFTAmountRecipients, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, relayAdaptID, false, // useDummyProof
        overallBatchMinGasPrice, progressCallback);
        const transaction = await (0, tx_generator_1.generateUnshieldBaseToken)(txidVersion, provedTransactions, networkName, publicWalletAddress, relayAdaptParamsRandom, sendWithPublicWallet);
        const nullifiers = (0, tx_generator_1.nullifiersForTransactions)(provedTransactions);
        (0, proof_cache_1.setCachedProvedTransaction)({
            proofType: shared_models_1.ProofType.UnshieldBaseToken,
            txidVersion,
            railgunWalletID,
            showSenderAddressToRecipient,
            memoText,
            erc20AmountRecipients,
            nftAmountRecipients,
            relayAdaptUnshieldERC20Amounts,
            relayAdaptUnshieldNFTAmounts: undefined,
            relayAdaptShieldERC20Recipients: undefined,
            relayAdaptShieldNFTRecipients: undefined,
            crossContractCalls: undefined,
            broadcasterFeeERC20AmountRecipient,
            sendWithPublicWallet,
            transaction,
            preTransactionPOIsPerTxidLeafPerList,
            overallBatchMinGasPrice,
            nullifiers,
        });
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.generateUnshieldBaseTokenProof.name, err);
    }
};
exports.generateUnshieldBaseTokenProof = generateUnshieldBaseTokenProof;
//# sourceMappingURL=tx-proof-unshield.js.map