"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateUnshieldBaseToken = exports.generateTransact = exports.generateDummyProofTransactions = exports.createDummyBroadcasterFeeERC20Amount = exports.nullifiersForTransactions = exports.generateProofTransactions = exports.DUMMY_FROM_ADDRESS = void 0;
const engine_1 = require("@railgun-community/engine");
const shared_models_1 = require("@railgun-community/shared-models");
const tx_notes_1 = require("./tx-notes");
const prover_1 = require("../railgun/core/prover");
const wallets_1 = require("../railgun/wallets/wallets");
const blocked_address_1 = require("../../utils/blocked-address");
const gas_price_1 = require("../../utils/gas-price");
const poi_required_1 = require("../poi/poi-required");
const DUMMY_AMOUNT = 0n;
exports.DUMMY_FROM_ADDRESS = '0x000000000000000000000000000000000000dEaD';
const generateProofTransactions = async (proofType, networkName, railgunWalletID, txidVersion, encryptionKey, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, relayAdaptID, useDummyProof, overallBatchMinGasPrice, progressCallback, originShieldTxidForSpendabilityOverride) => {
    const railgunWallet = (0, wallets_1.fullWalletForID)(railgunWalletID);
    const txs = await transactionsFromERC20Amounts(proofType, erc20AmountRecipients, nftAmountRecipients, railgunWallet, txidVersion, encryptionKey, showSenderAddressToRecipient, memoText, networkName, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, relayAdaptID, useDummyProof, overallBatchMinGasPrice, progressCallback, originShieldTxidForSpendabilityOverride);
    return txs;
};
exports.generateProofTransactions = generateProofTransactions;
const nullifiersForTransactions = (transactions) => {
    return transactions
        .map(transaction => transaction.nullifiers)
        .flat();
};
exports.nullifiersForTransactions = nullifiersForTransactions;
const createDummyBroadcasterFeeERC20Amount = (feeTokenAddress) => {
    const broadcasterFeeERC20Amount = {
        tokenAddress: feeTokenAddress,
        amount: DUMMY_AMOUNT,
    };
    return broadcasterFeeERC20Amount;
};
exports.createDummyBroadcasterFeeERC20Amount = createDummyBroadcasterFeeERC20Amount;
const generateDummyProofTransactions = async (proofType, networkName, railgunWalletID, txidVersion, encryptionKey, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, broadcasterFeeERC20Amount, sendWithPublicWallet, overallBatchMinGasPrice, originShieldTxidForSpendabilityOverride) => {
    if (!broadcasterFeeERC20Amount && !sendWithPublicWallet) {
        throw new Error('Must send with broadcaster or public wallet.');
    }
    const railgunWallet = (0, wallets_1.walletForID)(railgunWalletID);
    // Use self-wallet as dummy broadcaster address.
    const broadcasterRailgunAddress = railgunWallet.getAddress(undefined);
    const broadcasterFeeERC20AmountRecipient = broadcasterFeeERC20Amount
        ? {
            ...broadcasterFeeERC20Amount,
            recipientAddress: broadcasterRailgunAddress,
        }
        : undefined;
    return (await (0, exports.generateProofTransactions)(proofType, networkName, railgunWalletID, txidVersion, encryptionKey, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, undefined, // relayAdaptID
    true, // useDummyProof
    overallBatchMinGasPrice, () => { }, // progressCallback (not necessary for dummy txs)
    originShieldTxidForSpendabilityOverride)).provedTransactions;
};
exports.generateDummyProofTransactions = generateDummyProofTransactions;
const generateTransact = async (txidVersion, txs, networkName, useDummyProof = false) => {
    const chain = shared_models_1.NETWORK_CONFIG[networkName].chain;
    const transaction = await engine_1.RailgunVersionedSmartContracts.generateTransact(txidVersion, chain, txs);
    if (useDummyProof) {
        return {
            ...transaction,
            from: exports.DUMMY_FROM_ADDRESS,
        };
    }
    return transaction;
};
exports.generateTransact = generateTransact;
const generateUnshieldBaseToken = async (txidVersion, txs, networkName, toWalletAddress, relayAdaptParamsRandom, useDummyProof = false) => {
    (0, wallets_1.assertValidEthAddress)(toWalletAddress);
    (0, blocked_address_1.assertNotBlockedAddress)(toWalletAddress);
    const chain = shared_models_1.NETWORK_CONFIG[networkName].chain;
    const transaction = await engine_1.RelayAdaptVersionedSmartContracts.populateUnshieldBaseToken(txidVersion, chain, txs, toWalletAddress, relayAdaptParamsRandom, useDummyProof);
    if (useDummyProof) {
        return {
            ...transaction,
            from: exports.DUMMY_FROM_ADDRESS,
        };
    }
    return transaction;
};
exports.generateUnshieldBaseToken = generateUnshieldBaseToken;
const transactionsFromERC20Amounts = async (proofType, erc20AmountRecipients, nftAmountRecipients, railgunWallet, txidVersion, encryptionKey, showSenderAddressToRecipient, memoText, networkName, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, relayAdaptID, useDummyProof, overallBatchMinGasPrice, progressCallback, originShieldTxidForSpendabilityOverride) => {
    const network = shared_models_1.NETWORK_CONFIG[networkName];
    const { chain } = network;
    // Removes overallBatchMinGasPrice for L2 networks and non-Broadcaster transactions.
    const validatedOverallBatchMinGasPrice = (0, gas_price_1.shouldSetOverallBatchMinGasPriceForNetwork)(sendWithPublicWallet, networkName)
        ? BigInt(overallBatchMinGasPrice ?? 0)
        : BigInt(0);
    const transactionBatch = new engine_1.TransactionBatch(chain, validatedOverallBatchMinGasPrice);
    if (relayAdaptID) {
        transactionBatch.setAdaptID(relayAdaptID);
    }
    if (broadcasterFeeERC20AmountRecipient && !sendWithPublicWallet) {
        (0, wallets_1.assertValidRailgunAddress)(broadcasterFeeERC20AmountRecipient.recipientAddress);
        // Add Broadcaster Fee - must be first transaction in the batch, and first output for the transaction.
        transactionBatch.addOutput((0, tx_notes_1.erc20NoteFromERC20AmountRecipient)(broadcasterFeeERC20AmountRecipient, railgunWallet, engine_1.OutputType.BroadcasterFee, false, // showSenderAddressToRecipient - never show sender for Broadcaster fees
        undefined));
    }
    erc20AmountRecipients.forEach((erc20AmountRecipient) => {
        addTransactionOutputsERC20(proofType, transactionBatch, erc20AmountRecipient, railgunWallet, showSenderAddressToRecipient, memoText);
    });
    nftAmountRecipients.forEach((nftAmountRecipient) => {
        addTransactionOutputsNFT(proofType, transactionBatch, nftAmountRecipient, railgunWallet, showSenderAddressToRecipient, memoText);
    });
    const shouldGeneratePreTransactionPOIs = !sendWithPublicWallet &&
        (await poi_required_1.POIRequired.isRequiredForNetwork(networkName));
    const txBatches = await generateAllProofs(transactionBatch, railgunWallet, txidVersion, encryptionKey, useDummyProof, progressCallback, shouldGeneratePreTransactionPOIs, originShieldTxidForSpendabilityOverride);
    return txBatches;
};
const addTransactionOutputsERC20 = (proofType, transactionBatch, erc20AmountRecipient, railgunWallet, showSenderAddressToRecipient, memoText) => {
    switch (proofType) {
        case shared_models_1.ProofType.Transfer: {
            addTransactionOutputsTransferERC20(transactionBatch, erc20AmountRecipient, railgunWallet, showSenderAddressToRecipient, memoText);
            break;
        }
        case shared_models_1.ProofType.CrossContractCalls:
        case shared_models_1.ProofType.UnshieldBaseToken:
        case shared_models_1.ProofType.Unshield: {
            addTransactionOutputsUnshieldERC20(transactionBatch, erc20AmountRecipient, false);
            break;
        }
    }
};
const addTransactionOutputsNFT = (proofType, transactionBatch, nftAmountRecipient, railgunWallet, showSenderAddressToRecipient, memoText) => {
    switch (proofType) {
        case shared_models_1.ProofType.Transfer: {
            addTransactionOutputsTransferNFT(transactionBatch, nftAmountRecipient, railgunWallet, showSenderAddressToRecipient, memoText);
            break;
        }
        case shared_models_1.ProofType.CrossContractCalls:
        case shared_models_1.ProofType.UnshieldBaseToken:
        case shared_models_1.ProofType.Unshield: {
            addTransactionOutputsUnshieldNFT(transactionBatch, nftAmountRecipient, false);
            break;
        }
    }
};
const addTransactionOutputsTransferERC20 = (transactionBatch, erc20AmountRecipient, railgunWallet, showSenderAddressToRecipient, memoText) => {
    (0, wallets_1.assertValidRailgunAddress)(erc20AmountRecipient.recipientAddress);
    transactionBatch.addOutput((0, tx_notes_1.erc20NoteFromERC20AmountRecipient)(erc20AmountRecipient, railgunWallet, engine_1.OutputType.Transfer, showSenderAddressToRecipient, memoText));
};
const addTransactionOutputsUnshieldERC20 = (transactionBatch, erc20AmountRecipient, allowOverride) => {
    const { recipientAddress, amount } = erc20AmountRecipient;
    (0, wallets_1.assertValidEthAddress)(recipientAddress);
    (0, blocked_address_1.assertNotBlockedAddress)(recipientAddress);
    const tokenData = (0, engine_1.getTokenDataERC20)(erc20AmountRecipient.tokenAddress);
    transactionBatch.addUnshieldData({
        toAddress: erc20AmountRecipient.recipientAddress,
        value: amount,
        tokenData,
        allowOverride,
    });
};
const addTransactionOutputsTransferNFT = (transactionBatch, nftAmountRecipient, railgunWallet, showSenderAddressToRecipient, memoText) => {
    (0, wallets_1.assertValidRailgunAddress)(nftAmountRecipient.recipientAddress);
    transactionBatch.addOutput((0, tx_notes_1.nftNoteFromNFTAmountRecipient)(nftAmountRecipient, railgunWallet, showSenderAddressToRecipient, memoText));
};
const addTransactionOutputsUnshieldNFT = (transactionBatch, nftAmountRecipient, allowOverride) => {
    const { recipientAddress, nftAddress, tokenSubID, nftTokenType, amount } = nftAmountRecipient;
    (0, wallets_1.assertValidEthAddress)(recipientAddress);
    (0, blocked_address_1.assertNotBlockedAddress)(recipientAddress);
    const tokenData = (0, engine_1.getTokenDataNFT)(nftAddress, nftTokenType, tokenSubID);
    const value = nftTokenType === shared_models_1.NFTTokenType.ERC721 ? engine_1.ERC721_NOTE_VALUE : amount;
    transactionBatch.addUnshieldData({
        toAddress: recipientAddress,
        value,
        tokenData,
        allowOverride,
    });
};
const generateAllProofs = async (transactionBatch, railgunWallet, txidVersion, encryptionKey, useDummyProof, progressCallback, shouldGeneratePreTransactionPOIs, originShieldTxidForSpendabilityOverride) => {
    const prover = (0, prover_1.getProver)();
    if (useDummyProof) {
        return {
            provedTransactions: await transactionBatch.generateDummyTransactions(prover, railgunWallet, txidVersion, encryptionKey, originShieldTxidForSpendabilityOverride),
            preTransactionPOIsPerTxidLeafPerList: {},
        };
    }
    return transactionBatch.generateTransactions(prover, railgunWallet, txidVersion, encryptionKey, progressCallback, shouldGeneratePreTransactionPOIs, originShieldTxidForSpendabilityOverride);
};
//# sourceMappingURL=tx-generator.js.map