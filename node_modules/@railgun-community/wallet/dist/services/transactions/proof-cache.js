"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateCachedProvedTransaction = exports.getCachedProvedTransaction = exports.setCachedProvedTransaction = exports.populateProvedTransaction = void 0;
const shared_models_1 = require("@railgun-community/shared-models");
const gas_price_1 = require("../../utils/gas-price");
const utils_1 = require("../../utils/utils");
const tx_gas_details_1 = require("./tx-gas-details");
const tx_notes_1 = require("./tx-notes");
let cachedProvedTransaction;
const populateProvedTransaction = async (txidVersion, networkName, proofType, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice, gasDetails) => {
    try {
        (0, exports.validateCachedProvedTransaction)(txidVersion, networkName, proofType, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice);
    }
    catch (cause) {
        if (!(cause instanceof Error)) {
            throw new Error('Non-error thrown from populateProvedTransaction', {
                cause,
            });
        }
        throw new Error(`Invalid proof for this transaction`, { cause });
    }
    const { transaction, nullifiers, preTransactionPOIsPerTxidLeafPerList } = (0, exports.getCachedProvedTransaction)();
    (0, tx_gas_details_1.setGasDetailsForTransaction)(networkName, transaction, gasDetails, sendWithPublicWallet);
    return { transaction, nullifiers, preTransactionPOIsPerTxidLeafPerList };
};
exports.populateProvedTransaction = populateProvedTransaction;
const setCachedProvedTransaction = (tx) => {
    if ((0, shared_models_1.isDefined)(tx?.transaction?.from)) {
        throw new Error(`Cannot cache a transaction with a 'from' address.`);
    }
    cachedProvedTransaction = tx;
};
exports.setCachedProvedTransaction = setCachedProvedTransaction;
const getCachedProvedTransaction = () => {
    return cachedProvedTransaction;
};
exports.getCachedProvedTransaction = getCachedProvedTransaction;
const shouldValidateERC20AmountRecipients = (proofType) => {
    switch (proofType) {
        case shared_models_1.ProofType.CrossContractCalls:
            // Skip validation for erc20AmountRecipients, which is not used
            // in this transaction type.
            return false;
        case shared_models_1.ProofType.Transfer:
        case shared_models_1.ProofType.Unshield:
        case shared_models_1.ProofType.UnshieldBaseToken:
            return true;
    }
};
const shouldValidateRelayAdaptAmounts = (proofType) => {
    switch (proofType) {
        case shared_models_1.ProofType.CrossContractCalls:
        case shared_models_1.ProofType.UnshieldBaseToken:
            // Only validate for Cross Contract and Unshield Base Token proofs.
            return true;
        case shared_models_1.ProofType.Transfer:
        case shared_models_1.ProofType.Unshield:
            return false;
    }
};
const shouldValidateCrossContractCalls = (proofType) => {
    switch (proofType) {
        case shared_models_1.ProofType.CrossContractCalls:
            // Only validate for Cross Contract proofs.
            return true;
        case shared_models_1.ProofType.Transfer:
        case shared_models_1.ProofType.Unshield:
        case shared_models_1.ProofType.UnshieldBaseToken:
            return false;
    }
};
const validateCachedProvedTransaction = (txidVersion, networkName, proofType, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, relayAdaptUnshieldERC20Amounts, relayAdaptUnshieldNFTAmounts, relayAdaptShieldERC20Recipients, relayAdaptShieldNFTRecipients, crossContractCalls, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice) => {
    if (!cachedProvedTransaction) {
        throw new Error('No proof found.');
    }
    else if (cachedProvedTransaction.txidVersion !== txidVersion) {
        throw new Error('Mismatch: txidVersion.');
    }
    else if (cachedProvedTransaction.proofType !== proofType) {
        throw new Error('Mismatch: proofType.');
    }
    else if (cachedProvedTransaction.railgunWalletID !== railgunWalletID) {
        throw new Error('Mismatch: railgunWalletID.');
    }
    else if (proofType === shared_models_1.ProofType.Transfer &&
        cachedProvedTransaction.showSenderAddressToRecipient !==
            showSenderAddressToRecipient) {
        throw new Error('Mismatch: showSenderAddressToRecipient.');
    }
    else if (proofType === shared_models_1.ProofType.Transfer &&
        cachedProvedTransaction.memoText !== memoText) {
        throw new Error('Mismatch: memoText.');
    }
    else if (shouldValidateERC20AmountRecipients(proofType) &&
        !(0, tx_notes_1.compareERC20AmountRecipientArrays)(erc20AmountRecipients, cachedProvedTransaction.erc20AmountRecipients)) {
        throw new Error('Mismatch: erc20AmountRecipients.');
    }
    else if (!(0, tx_notes_1.compareNFTAmountRecipientArrays)(nftAmountRecipients, cachedProvedTransaction.nftAmountRecipients)) {
        throw new Error('Mismatch: nftAmountRecipients.');
    }
    else if (shouldValidateRelayAdaptAmounts(proofType) &&
        !(0, tx_notes_1.compareERC20AmountArrays)(relayAdaptUnshieldERC20Amounts, cachedProvedTransaction.relayAdaptUnshieldERC20Amounts)) {
        throw new Error('Mismatch: relayAdaptUnshieldERC20Amounts.');
    }
    else if (shouldValidateRelayAdaptAmounts(proofType) &&
        !(0, tx_notes_1.compareNFTAmountArrays)(relayAdaptUnshieldNFTAmounts, cachedProvedTransaction.relayAdaptUnshieldNFTAmounts)) {
        throw new Error('Mismatch: relayAdaptUnshieldNFTAmounts.');
    }
    else if (shouldValidateRelayAdaptAmounts(proofType) &&
        !(0, tx_notes_1.compareERC20RecipientArrays)(relayAdaptShieldERC20Recipients, cachedProvedTransaction.relayAdaptShieldERC20Recipients)) {
        throw new Error('Mismatch: relayAdaptShieldERC20Recipients.');
    }
    else if (shouldValidateRelayAdaptAmounts(proofType) &&
        !(0, tx_notes_1.compareNFTAmountArrays)(relayAdaptShieldNFTRecipients, cachedProvedTransaction.relayAdaptShieldNFTRecipients)) {
        throw new Error('Mismatch: relayAdaptShieldNFTRecipients.');
    }
    else if (shouldValidateCrossContractCalls(proofType) &&
        !(0, utils_1.compareContractTransactionArrays)(crossContractCalls, cachedProvedTransaction.crossContractCalls)) {
        throw new Error('Mismatch: crossContractCalls.');
    }
    else if (!(0, tx_notes_1.compareERC20AmountRecipients)(cachedProvedTransaction.broadcasterFeeERC20AmountRecipient, broadcasterFeeERC20AmountRecipient)) {
        throw new Error('Mismatch: broadcasterFeeERC20AmountRecipient.');
    }
    else if (sendWithPublicWallet !== cachedProvedTransaction.sendWithPublicWallet) {
        throw new Error('Mismatch: sendWithPublicWallet.');
    }
    else if ((0, gas_price_1.shouldSetOverallBatchMinGasPriceForNetwork)(cachedProvedTransaction.sendWithPublicWallet, networkName) &&
        overallBatchMinGasPrice !== cachedProvedTransaction.overallBatchMinGasPrice) {
        throw new Error('Mismatch: overallBatchMinGasPrice.');
    }
};
exports.validateCachedProvedTransaction = validateCachedProvedTransaction;
//# sourceMappingURL=proof-cache.js.map