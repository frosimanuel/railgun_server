"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setGasDetailsForTransaction = exports.gasEstimateResponse = exports.getGasEstimate = void 0;
const shared_models_1 = require("@railgun-community/shared-models");
const railgun_1 = require("../railgun");
const error_1 = require("../../utils/error");
const engine_1 = require("@railgun-community/engine");
const getGasEstimate = async (txidVersion, networkName, transaction, fromWalletAddress, sendWithPublicWallet, isCrossContractCall) => {
    const evmGasType = (0, shared_models_1.getEVMGasTypeForTransaction)(networkName, sendWithPublicWallet);
    // Add 'from' field, which is required, as a mock address.
    // Note that DEPOSIT needs a real address, as it checks the balance for transfer.
    const estimateGasTransactionRequest = {
        ...transaction,
        from: fromWalletAddress,
        type: evmGasType,
    };
    if (shouldRemoveGasLimitForL2GasEstimate(networkName)) {
        delete estimateGasTransactionRequest.gasLimit;
    }
    try {
        return estimateGas(txidVersion, networkName, estimateGasTransactionRequest, isCrossContractCall);
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.getGasEstimate.name, err);
    }
};
exports.getGasEstimate = getGasEstimate;
const estimateGas = (txidVersion, networkName, transaction, isCrossContractCall) => {
    const provider = (0, railgun_1.getFallbackProviderForNetwork)(networkName);
    if (isCrossContractCall) {
        // Includes custom error handler for relay-adapt transactions.
        return engine_1.RelayAdaptVersionedSmartContracts.estimateGasWithErrorHandler(txidVersion, provider, transaction);
    }
    return provider.estimateGas(transaction);
};
/**
 * Gas estimates can fail for relay-adapt transactions on L2s like Arbitrum.
 * This occurs on cross-contract calls (relay-adapt) which have a manual minimum gas limit set by Railgun Engine.
 */
const shouldRemoveGasLimitForL2GasEstimate = (networkName) => {
    switch (networkName) {
        case shared_models_1.NetworkName.Arbitrum:
            return true;
        case shared_models_1.NetworkName.Ethereum:
        case shared_models_1.NetworkName.BNBChain:
        case shared_models_1.NetworkName.Polygon:
        case shared_models_1.NetworkName.PolygonAmoy:
        case shared_models_1.NetworkName.EthereumRopsten_DEPRECATED:
        case shared_models_1.NetworkName.EthereumGoerli_DEPRECATED:
        case shared_models_1.NetworkName.ArbitrumGoerli_DEPRECATED:
        case shared_models_1.NetworkName.PolygonMumbai_DEPRECATED:
        case shared_models_1.NetworkName.EthereumSepolia:
        case shared_models_1.NetworkName.Hardhat:
        default:
            return false;
    }
};
const gasEstimateResponse = (gasEstimate, broadcasterFeeCommitment, isGasEstimateWithDummyProof) => {
    // TODO: This variance will be different on L2s.
    // However, it's small enough that it shouldn't matter very much.
    const gasEstimateWithDummyProofVariance = isGasEstimateWithDummyProof
        ? gasEstimate + BigInt(engine_1.GAS_ESTIMATE_VARIANCE_DUMMY_TO_ACTUAL_TRANSACTION)
        : gasEstimate;
    const response = {
        gasEstimate: gasEstimateWithDummyProofVariance,
        broadcasterFeeCommitment,
    };
    return response;
};
exports.gasEstimateResponse = gasEstimateResponse;
const setGasDetailsForTransaction = (networkName, transaction, gasDetails, sendWithPublicWallet) => {
    const { gasEstimate } = gasDetails;
    // eslint-disable-next-line no-param-reassign
    transaction.gasLimit = (0, shared_models_1.calculateGasLimit)(gasEstimate);
    const evmGasType = (0, shared_models_1.getEVMGasTypeForTransaction)(networkName, sendWithPublicWallet);
    if (gasDetails.evmGasType !== evmGasType) {
        const transactionType = sendWithPublicWallet
            ? 'self-signed'
            : 'Broadcaster';
        throw new Error(`Invalid evmGasType for ${networkName} (${transactionType}): expected Type${evmGasType}, received Type${gasDetails.evmGasType} in gasDetails. Retrieve appropriate gas type with getEVMGasTypeForTransaction (@railgun-community/shared-models).`);
    }
    // eslint-disable-next-line no-param-reassign
    transaction.type = gasDetails.evmGasType;
    switch (gasDetails.evmGasType) {
        case shared_models_1.EVMGasType.Type0: {
            // eslint-disable-next-line no-param-reassign
            transaction.gasPrice = gasDetails.gasPrice;
            // eslint-disable-next-line no-param-reassign
            delete transaction.accessList;
            break;
        }
        case shared_models_1.EVMGasType.Type1: {
            // eslint-disable-next-line no-param-reassign
            transaction.gasPrice = gasDetails.gasPrice;
            break;
        }
        case shared_models_1.EVMGasType.Type2: {
            // eslint-disable-next-line no-param-reassign
            transaction.maxFeePerGas = gasDetails.maxFeePerGas;
            // eslint-disable-next-line no-param-reassign
            transaction.maxPriorityFeePerGas = gasDetails.maxPriorityFeePerGas;
            break;
        }
    }
};
exports.setGasDetailsForTransaction = setGasDetailsForTransaction;
//# sourceMappingURL=tx-gas-details.js.map