"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gasEstimateForUnprovenTransfer = exports.populateProvedTransfer = void 0;
const shared_models_1 = require("@railgun-community/shared-models");
const tx_generator_1 = require("./tx-generator");
const proof_cache_1 = require("./proof-cache");
const tx_gas_broadcaster_fee_estimator_1 = require("./tx-gas-broadcaster-fee-estimator");
const error_1 = require("../../utils/error");
const populateProvedTransfer = async (txidVersion, networkName, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice, gasDetails) => {
    try {
        const { transaction, nullifiers, preTransactionPOIsPerTxidLeafPerList } = await (0, proof_cache_1.populateProvedTransaction)(txidVersion, networkName, shared_models_1.ProofType.Transfer, railgunWalletID, showSenderAddressToRecipient, memoText, erc20AmountRecipients, nftAmountRecipients, undefined, // relayAdaptUnshieldERC20AmountRecipients
        undefined, // relayAdaptUnshieldNFTAmounts
        undefined, // relayAdaptShieldERC20Recipients
        undefined, // relayAdaptShieldNFTRecipients
        undefined, // crossContractCalls
        broadcasterFeeERC20AmountRecipient, sendWithPublicWallet, overallBatchMinGasPrice, gasDetails);
        return {
            nullifiers,
            transaction,
            preTransactionPOIsPerTxidLeafPerList,
        };
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.populateProvedTransfer.name, err);
    }
};
exports.populateProvedTransfer = populateProvedTransfer;
const gasEstimateForUnprovenTransfer = async (txidVersion, networkName, railgunWalletID, encryptionKey, memoText, erc20AmountRecipients, nftAmountRecipients, originalGasDetails, feeTokenDetails, sendWithPublicWallet) => {
    try {
        const overallBatchMinGasPrice = 0n;
        const response = await (0, tx_gas_broadcaster_fee_estimator_1.gasEstimateResponseDummyProofIterativeBroadcasterFee)((broadcasterFeeERC20Amount) => (0, tx_generator_1.generateDummyProofTransactions)(shared_models_1.ProofType.Transfer, networkName, railgunWalletID, txidVersion, encryptionKey, false, // showSenderAddressToRecipient - doesn't matter for gas estimate.
        memoText, erc20AmountRecipients, nftAmountRecipients, broadcasterFeeERC20Amount, sendWithPublicWallet, overallBatchMinGasPrice), (txs) => (0, tx_generator_1.generateTransact)(txidVersion, txs, networkName, true), txidVersion, networkName, railgunWalletID, erc20AmountRecipients, originalGasDetails, feeTokenDetails, sendWithPublicWallet, false);
        return response;
    }
    catch (err) {
        throw (0, error_1.reportAndSanitizeError)(exports.gasEstimateForUnprovenTransfer.name, err);
    }
};
exports.gasEstimateForUnprovenTransfer = gasEstimateForUnprovenTransfer;
//# sourceMappingURL=tx-transfer.js.map