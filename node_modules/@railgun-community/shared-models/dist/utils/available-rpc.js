"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAvailableProviderJSONs = void 0;
/// <reference types="../types/global" />
const ethers_1 = require("ethers");
const median_1 = require("./median");
const promises_1 = require("./promises");
const BLOCK_NUMBER_TIMEOUT_MS = 5000;
/**
 * Health checks ProviderJson inputs, and returns an array of available RPC providers.
 * Available means that they respond to getBlockNumber(), and they are +/- 100 blocks from the median.
 */
const getAvailableProviderJSONs = async (chainId, providerJsons, logError) => {
    const blockNumbers = await Promise.all(providerJsons.map(async (providerJson) => await getBlockNumber(chainId, providerJson.provider, logError)));
    const nonZeroBlockNumbers = blockNumbers.filter(blockNumber => blockNumber != null && blockNumber > 0);
    const medianBlockNumber = (0, median_1.getUpperBoundMedian)(nonZeroBlockNumbers);
    const lowerBoundRange = medianBlockNumber - 100;
    const upperBoundRange = medianBlockNumber + 100;
    return providerJsons.filter((providerJson, index) => {
        const blockNumber = blockNumbers[index];
        if (blockNumber == null) {
            logError(`RPC Health Check failed for ${providerJson.provider}: No Block Number`);
            return false;
        }
        if (blockNumber < lowerBoundRange) {
            logError(`RPC Health Check failed for ${providerJson.provider}: Block Number -${medianBlockNumber - blockNumber} from median`);
            return false;
        }
        if (blockNumber > upperBoundRange) {
            logError(`RPC Health Check failed for ${providerJson.provider}: Block Number +${blockNumber - medianBlockNumber} from median`);
            return false;
        }
        return true;
    });
};
exports.getAvailableProviderJSONs = getAvailableProviderJSONs;
const getBlockNumber = async (chainId, provider, logError) => {
    const network = ethers_1.Network.from(chainId);
    const rpcProvider = new ethers_1.JsonRpcProvider(provider, network, {
        staticNetwork: network,
    });
    try {
        const block = await (0, promises_1.promiseTimeout)(rpcProvider.getBlock('latest'), BLOCK_NUMBER_TIMEOUT_MS);
        if (block == null) {
            throw new Error('Block is null');
        }
        return block.number;
    }
    catch (cause) {
        if (!(cause instanceof Error)) {
            throw new Error('Non-error thrown from getBlockNumber', { cause });
        }
        rpcProvider.destroy();
        logError(cause.message);
        return undefined;
    }
};
//# sourceMappingURL=available-rpc.js.map