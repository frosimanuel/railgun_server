"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFallbackProviderFromJsonConfig = void 0;
const ethers_1 = require("ethers");
const configured_json_rpc_provider_1 = require("./configured-json-rpc-provider");
const createFallbackProviderFromJsonConfig = (config) => {
    try {
        const totalWeight = config.providers.reduce((acc, { weight }) => acc + weight, 0);
        if (totalWeight < 2) {
            throw new Error('Total weight across providers must be >= 2 for fallback quorum.');
        }
        const network = ethers_1.Network.from(Number(config.chainId));
        const providers = config.providers.map(({ provider: providerURL, priority, weight, stallTimeout, maxLogsPerBatch, }) => {
            const isWebsocket = providerURL.startsWith('wss');
            const provider = isWebsocket
                ? new ethers_1.WebSocketProvider(providerURL, network)
                : new configured_json_rpc_provider_1.ConfiguredJsonRpcProvider(providerURL, network, maxLogsPerBatch);
            const fallbackProviderConfig = {
                provider,
                priority,
                weight,
                stallTimeout,
            };
            return fallbackProviderConfig;
        });
        return new ethers_1.FallbackProvider(providers, network);
    }
    catch (cause) {
        if (!(cause instanceof Error)) {
            throw new Error('Non-error thrown from createFallbackProviderFromJsonConfig', { cause });
        }
        throw new Error(`Invalid fallback provider config for chain ${config.chainId}`, { cause });
    }
};
exports.createFallbackProviderFromJsonConfig = createFallbackProviderFromJsonConfig;
//# sourceMappingURL=fallback-provider.js.map