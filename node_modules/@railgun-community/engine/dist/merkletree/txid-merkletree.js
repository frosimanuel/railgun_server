"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TXIDMerkletree = void 0;
const merkletree_types_1 = require("../models/merkletree-types");
const merkletree_1 = require("./merkletree");
const bytes_1 = require("../utils/bytes");
const is_defined_1 = require("../utils/is-defined");
const debugger_1 = __importDefault(require("../debugger/debugger"));
const merkle_proof_1 = require("./merkle-proof");
const poi_1 = require("../poi/poi");
class TXIDMerkletree extends merkletree_1.Merkletree {
    // DO NOT MODIFY
    merkletreePrefix = 'railgun-transaction-ids';
    merkletreeType = 'TXID';
    shouldStoreMerkleroots;
    shouldSavePOILaunchSnapshot;
    savedPOILaunchSnapshot;
    constructor(db, chain, txidVersion, merklerootValidator, isPOINode) {
        // For Txid merkletree on POI Nodes, we will calculate for every Single tree update, in order to capture its merkleroot.
        const commitmentProcessingGroupSize = isPOINode
            ? merkletree_types_1.CommitmentProcessingGroupSize.Single
            : merkletree_types_1.CommitmentProcessingGroupSize.XXXLarge;
        super(db, chain, txidVersion, merklerootValidator, commitmentProcessingGroupSize);
        // For Txid merkletree on POI Nodes, store all merkleroots.
        this.shouldStoreMerkleroots = isPOINode;
        this.shouldSavePOILaunchSnapshot = !isPOINode;
    }
    /**
     * Wallet validates merkleroots against POI Nodes.
     */
    static async createForWallet(db, chain, txidVersion, merklerootValidator) {
        const merkletree = new TXIDMerkletree(db, chain, txidVersion, merklerootValidator, false);
        await merkletree.init();
        return merkletree;
    }
    /**
     * POI Node is the source of truth, so it will not validate merkleroots.
     * Instead, it will process every tree update individually, and store each in the database.
     */
    static async createForPOINode(db, chain, txidVersion) {
        // Assume all merkleroots are valid.
        const merklerootValidator = async () => true;
        const merkletree = new TXIDMerkletree(db, chain, txidVersion, merklerootValidator, true);
        await merkletree.init();
        return merkletree;
    }
    /**
     * Gets Railgun Transaction data from txid tree.
     */
    async getRailgunTransaction(tree, index) {
        try {
            if (tree < 0 || index < 0) {
                return undefined;
            }
            return await this.getData(tree, index);
        }
        catch (err) {
            debugger_1.default.log('Error getting railgun transaction');
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
            debugger_1.default.error(err);
            return undefined;
        }
    }
    async getGlobalUTXOTreePositionForRailgunTransactionCommitment(tree, index, commitmentHash) {
        const railgunTransaction = await this.getRailgunTransaction(tree, index);
        if (!railgunTransaction) {
            throw new Error('Railgun transaction for tree/index not found');
        }
        const commitmentIndex = railgunTransaction.commitments
            .map((c) => bytes_1.ByteUtils.formatToByteLength(c, bytes_1.ByteLength.UINT_256))
            .indexOf(bytes_1.ByteUtils.formatToByteLength(commitmentHash, bytes_1.ByteLength.UINT_256));
        if (commitmentIndex < 0) {
            throw new Error('Could not find commitmentHash for RailgunTransaction');
        }
        return railgunTransaction.utxoBatchStartPositionOut + commitmentIndex;
    }
    async getRailgunTxidCurrentMerkletreeData(railgunTxid) {
        const txidIndex = await this.getTxidIndexByRailgunTxid(railgunTxid);
        if (!(0, is_defined_1.isDefined)(txidIndex)) {
            throw new Error(`tree/index not found: railgun txid ${railgunTxid}`);
        }
        const { tree, index } = merkletree_1.Merkletree.getTreeAndIndexFromGlobalPosition(txidIndex);
        const railgunTransaction = await this.getRailgunTransaction(tree, index);
        if (!(0, is_defined_1.isDefined)(railgunTransaction)) {
            throw new Error('railgun transaction not found');
        }
        // Use the snapshot if this is a legacy transaction, and we have a snapshot.
        // (Ie., after POI has launched for this chain).
        const poiLaunchBlock = poi_1.POI.launchBlocks.get(null, this.chain);
        const useSnapshot = (0, is_defined_1.isDefined)(poiLaunchBlock) &&
            this.shouldSavePOILaunchSnapshot &&
            railgunTransaction.blockNumber < poiLaunchBlock &&
            (await this.hasSavedPOILaunchSnapshot());
        if (useSnapshot) {
            const snapshotLeaf = await this.getPOILaunchSnapshotNode(0);
            if (!(0, is_defined_1.isDefined)(snapshotLeaf)) {
                throw new Error('POI Launch snapshot not found');
            }
            const currentMerkleProofForTree = await this.getMerkleProofWithSnapshot(snapshotLeaf, tree, index);
            if (!(0, merkle_proof_1.verifyMerkleProof)(currentMerkleProofForTree)) {
                throw new Error('Invalid merkle proof for snapshot');
            }
            return {
                railgunTransaction,
                currentMerkleProofForTree,
                currentTxidIndexForTree: snapshotLeaf.index,
            };
        }
        const currentMerkleProofForTree = await this.getMerkleProof(tree, index);
        if (!(0, merkle_proof_1.verifyMerkleProof)(currentMerkleProofForTree)) {
            throw new Error('Invalid merkle proof');
        }
        const currentIndex = await this.getLatestIndexForTree(tree);
        const currentTxidIndexForTree = TXIDMerkletree.getGlobalPosition(tree, currentIndex);
        return {
            railgunTransaction,
            currentMerkleProofForTree,
            currentTxidIndexForTree,
        };
    }
    async getMerkleProofWithSnapshot(snapshotLeaf, tree, index) {
        const leaf = await this.getNodeHash(tree, 0, index);
        const rightmostIndices = TXIDMerkletree.getRightmostNonzeroIndices(snapshotLeaf.index);
        // Get indexes of path elements to fetch
        const elementsIndices = [index ^ 1];
        // Loop through each level and calculate index
        while (elementsIndices.length < merkletree_types_1.TREE_DEPTH) {
            // Shift right and flip last bit
            elementsIndices.push((elementsIndices[elementsIndices.length - 1] >> 1) ^ 1);
        }
        // Fetch path elements
        const elements = await Promise.all(elementsIndices.map(async (elementIndex, level) => {
            const snapshotIndexAtLevel = rightmostIndices[level];
            if (elementIndex > snapshotIndexAtLevel) {
                // Get snapshot node hash (exact value)
                return this.zeros[level];
            }
            if (elementIndex === snapshotIndexAtLevel) {
                // Get snapshot node hash (exact value)
                const node = await this.getPOILaunchSnapshotNode(level);
                if (!(0, is_defined_1.isDefined)(node)) {
                    throw new Error('POI Launch snapshot node not found');
                }
                return node.hash;
            }
            // Get current node hash (always same as snapshot)
            return this.getNodeHash(tree, level, elementIndex);
        }));
        // Convert index to bytes data, the binary representation is the indices of the merkle path
        // Pad to 32 bytes
        const indices = bytes_1.ByteUtils.nToHex(BigInt(index), bytes_1.ByteLength.UINT_256);
        const rootNode = await this.getPOILaunchSnapshotNode(merkletree_types_1.TREE_DEPTH);
        if (!(0, is_defined_1.isDefined)(rootNode)) {
            throw new Error('POI Launch snapshot root not found');
        }
        const root = rootNode.hash;
        return {
            leaf,
            elements,
            indices,
            root,
        };
    }
    async railgunTxidOccurredBeforeBlockNumber(tree, index, blockNumber) {
        const railgunTransaction = await this.getRailgunTransaction(tree, index);
        if (!railgunTransaction) {
            throw new Error(`Railgun transaction at Txid tree ${tree} and index ${index} not found.`);
        }
        return railgunTransaction.blockNumber < blockNumber;
    }
    async getLatestRailgunTransaction() {
        const { tree, index } = await this.getLatestTreeAndIndex();
        return this.getRailgunTransaction(tree, index);
    }
    async queueRailgunTransactions(railgunTransactionsWithTxids, maxTxidIndex) {
        if (!railgunTransactionsWithTxids.length) {
            return;
        }
        const { tree: latestTree, index: latestIndex } = await this.getLatestTreeAndIndex();
        let nextTree = latestTree;
        let nextIndex = latestIndex;
        const railgunTxidIndexLookupBatch = [];
        for (const railgunTransactionWithTxid of railgunTransactionsWithTxids) {
            const { tree, index } = TXIDMerkletree.nextTreeAndIndex(nextTree, nextIndex);
            nextTree = tree;
            nextIndex = index;
            if (TXIDMerkletree.isOutOfBounds(nextTree, nextIndex, maxTxidIndex)) {
                break;
            }
            const txidIndex = TXIDMerkletree.getGlobalPosition(nextTree, nextIndex);
            // TODO-V3: We need a way to verify the txid tree position.
            // The following won't work, because the UTXO start position includes shields, and the TXID position doesn't have shields.
            // if (
            //   railgunTransactionWithTxid.version === RailgunTransactionVersion.V3 &&
            //   railgunTransactionWithTxid.txidTreeVerificationGlobalIndex !== txidIndex
            // ) {
            //   const isUnshieldOnly =
            //     isDefined(railgunTransactionWithTxid.unshield) &&
            //     railgunTransactionWithTxid.commitments.length === 1;
            //   if (isUnshieldOnly) {
            //     EngineDebug.log(
            //       `Warning: Skipping railgun transaction queueing: potentially out of order. Tried to insert ${railgunTransactionWithTxid.txidTreeVerificationGlobalIndex} at position ${txidIndex}. This is an unshield-only - if there are 2 unshield-onlys in a row, this is expected, because these events don't technically have a global UTXO tree position.`,
            //     );
            //   } else {
            //     EngineDebug.error(
            //       new Error(
            //         `Skipping railgun transaction queueing: out of order. Tried to insert ${railgunTransactionWithTxid.txidTreeVerificationGlobalIndex} at position ${txidIndex}`,
            //       ),
            //     );
            //     return;
            //   }
            // }
            const { railgunTxid } = railgunTransactionWithTxid;
            const latestLeafIndex = nextIndex - 1;
            // eslint-disable-next-line no-await-in-loop
            await this.savePOILaunchSnapshotIfNecessary(railgunTransactionWithTxid, latestLeafIndex);
            // eslint-disable-next-line no-await-in-loop
            await this.queueLeaves(nextTree, nextIndex, [railgunTransactionWithTxid]);
            railgunTxidIndexLookupBatch.push({
                type: 'put',
                key: this.getRailgunTxidLookupDBPath(railgunTxid).join(':'),
                value: String(txidIndex),
            });
        }
        await this.db.batch(railgunTxidIndexLookupBatch, 'utf8');
    }
    static isOutOfBounds(tree, index, maxTxidIndex) {
        if (!(0, is_defined_1.isDefined)(maxTxidIndex)) {
            return false;
        }
        return TXIDMerkletree.getGlobalPosition(tree, index) > maxTxidIndex;
    }
    static nextTreeAndIndex(tree, index) {
        if (index + 1 >= merkletree_types_1.TREE_MAX_ITEMS) {
            return { tree: tree + 1, index: 0 };
        }
        return { tree, index: index + 1 };
    }
    async savePOILaunchSnapshotIfNecessary(railgunTransactionWithTxid, latestLeafIndex) {
        if (!this.shouldSavePOILaunchSnapshot) {
            return;
        }
        const poiLaunchBlock = poi_1.POI.launchBlocks.get(null, this.chain);
        if (!(0, is_defined_1.isDefined)(poiLaunchBlock)) {
            return;
        }
        if (railgunTransactionWithTxid.blockNumber < poiLaunchBlock) {
            return;
        }
        const shouldSavePOILaunchSnapshot = !(await this.hasSavedPOILaunchSnapshot());
        if (shouldSavePOILaunchSnapshot) {
            // Make sure trees have fully updated data.
            await this.updateTreesFromWriteQueue();
            // eslint-disable-next-line no-await-in-loop
            await this.savePOILaunchSnapshot(latestLeafIndex);
        }
    }
    async hasSavedPOILaunchSnapshot() {
        if (this.savedPOILaunchSnapshot === true) {
            return this.savedPOILaunchSnapshot;
        }
        const level = 0;
        const node = await this.getPOILaunchSnapshotNode(level);
        return (0, is_defined_1.isDefined)(node);
    }
    async getPOILaunchSnapshotNode(level) {
        try {
            return (await this.db.get(this.getPOILaunchSnapshotNodeDBPath(level), 'json'));
        }
        catch (cause) {
            if (!(cause instanceof Error)) {
                throw new Error('Non-error thrown in getPOILaunchSnapshotNode', { cause });
            }
            return undefined;
        }
    }
    static getRightmostNonzeroIndices(latestLeafIndex) {
        const rightmostIndices = [latestLeafIndex];
        while (rightmostIndices.length < merkletree_types_1.TREE_DEPTH + 1) {
            rightmostIndices.push(rightmostIndices[rightmostIndices.length - 1] >> 1);
        }
        return rightmostIndices;
    }
    async savePOILaunchSnapshot(latestLeafIndex) {
        if (!this.shouldSavePOILaunchSnapshot) {
            return;
        }
        const snapshotNodeWriteBatch = [];
        const indicesPerLevel = TXIDMerkletree.getRightmostNonzeroIndices(latestLeafIndex);
        for (let level = 0; level < merkletree_types_1.TREE_DEPTH + 1; level += 1) {
            const index = indicesPerLevel[level];
            // eslint-disable-next-line no-await-in-loop
            const hash = await this.getNodeHash(0, level, index);
            const node = { hash, index };
            snapshotNodeWriteBatch.push({
                type: 'put',
                key: this.getPOILaunchSnapshotNodeDBPath(level).join(':'),
                value: node,
            });
        }
        await this.db.batch(snapshotNodeWriteBatch, 'json');
        if (!(await this.hasSavedPOILaunchSnapshot())) {
            throw new Error('Error saving POI launch snapshot');
        }
        this.savedPOILaunchSnapshot = true;
    }
    async clearLeavesForInvalidVerificationHash(numLeavesToClear) {
        const { tree: latestTree, index: latestIndex } = await this.getLatestTreeAndIndex();
        const latestTxidIndex = TXIDMerkletree.getGlobalPosition(latestTree, latestIndex);
        const clearToTxidIndex = Math.max(-1, latestTxidIndex - numLeavesToClear);
        await this.clearLeavesAfterTxidIndex(clearToTxidIndex);
    }
    async clearLeavesAfterTxidIndex(txidIndex) {
        const lock = this.acquireUpdatesLock();
        try {
            // Remove any queued items
            this.writeQueue = [];
            const { tree, index } = TXIDMerkletree.getTreeAndIndexFromGlobalPosition(txidIndex);
            const { tree: latestTree, index: latestIndex } = await this.getLatestTreeAndIndex();
            for (let currentTree = tree; currentTree <= latestTree; currentTree += 1) {
                const startIndex = currentTree === tree ? index + 1 : 0;
                const max = currentTree === latestTree ? latestIndex : merkletree_types_1.TREE_MAX_ITEMS - 1;
                for (let currentIndex = startIndex; currentIndex <= max; currentIndex += 1) {
                    // eslint-disable-next-line no-await-in-loop
                    await this.db.del(this.getHistoricalMerklerootDBPath(currentTree, currentIndex));
                    // eslint-disable-next-line no-await-in-loop
                    await this.db.del(this.getDataDBPath(currentTree, currentIndex));
                }
                // eslint-disable-next-line no-await-in-loop
                await this.clearAllNodeHashes(currentTree);
            }
            for (let currentTree = tree; currentTree <= latestTree; currentTree += 1) {
                // eslint-disable-next-line no-await-in-loop
                await this.rebuildAndWriteTree(currentTree, lock);
                // eslint-disable-next-line no-await-in-loop
                await this.resetTreeLength(currentTree);
                // eslint-disable-next-line no-await-in-loop
                await this.updateStoredMerkletreesMetadata(currentTree);
            }
        }
        finally {
            this.releaseUpdatesLock();
        }
    }
    async getCurrentTxidIndex() {
        const { tree, index } = await this.getLatestTreeAndIndex();
        return TXIDMerkletree.getGlobalPosition(tree, index);
    }
    // eslint-disable-next-line class-methods-use-this
    validRootCallback() {
        // Unused for Txid merkletree
        return Promise.resolve();
    }
    // eslint-disable-next-line class-methods-use-this
    invalidRootCallback() {
        // Unused for Txid merkletree
        return Promise.resolve();
    }
    getPOILaunchSnapshotNodeDBPath(level) {
        const snapshotPrefix = (0, bytes_1.fromUTF8String)('poi-launch-snapshot');
        return [...this.getMerkletreeDBPrefix(), snapshotPrefix, level].map((el) => bytes_1.ByteUtils.formatToByteLength(el, bytes_1.ByteLength.UINT_256));
    }
    getRailgunTxidLookupDBPath(railgunTxid) {
        const railgunTxidPrefix = (0, bytes_1.fromUTF8String)('railgun-txid-lookup');
        return [...this.getMerkletreeDBPrefix(), railgunTxidPrefix, railgunTxid].map((el) => bytes_1.ByteUtils.formatToByteLength(el, bytes_1.ByteLength.UINT_256));
    }
    async getTxidIndexByRailgunTxid(railgunTxid) {
        try {
            return Number(await this.db.get(this.getRailgunTxidLookupDBPath(railgunTxid), 'utf8'));
        }
        catch (err) {
            return undefined;
        }
    }
    async getRailgunTransactionByTxid(railgunTxid) {
        try {
            const txidIndex = await this.getTxidIndexByRailgunTxid(railgunTxid);
            if (!(0, is_defined_1.isDefined)(txidIndex)) {
                return undefined;
            }
            const { tree, index } = TXIDMerkletree.getTreeAndIndexFromGlobalPosition(txidIndex);
            return await this.getData(tree, index);
        }
        catch (err) {
            debugger_1.default.log('Error getting railgun txid index');
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access
            debugger_1.default.error(err);
            return undefined;
        }
    }
    getHistoricalMerklerootDBPath(tree, index) {
        const merklerootPrefix = (0, bytes_1.fromUTF8String)('merkleroots');
        return [
            ...this.getMerkletreeDBPrefix(),
            merklerootPrefix,
            bytes_1.ByteUtils.hexlify(tree),
            bytes_1.ByteUtils.hexlify(index),
        ].map((el) => bytes_1.ByteUtils.formatToByteLength(el, bytes_1.ByteLength.UINT_256));
    }
    async newLeafRootTrigger(tree, index, leaf, merkleroot) {
        if (!this.shouldStoreMerkleroots) {
            return;
        }
        await this.db.put(this.getHistoricalMerklerootDBPath(tree, index), merkleroot);
    }
    async getHistoricalMerkleroot(tree, index) {
        try {
            const merkleroot = (await this.db.get(this.getHistoricalMerklerootDBPath(tree, index)));
            return merkleroot;
        }
        catch (cause) {
            if (!(cause instanceof Error)) {
                throw new Error('Non-error thrown in getHistoricalMerkleroot', { cause });
            }
            return undefined;
        }
    }
    async getHistoricalMerklerootForTxidIndex(txidIndex) {
        const { tree, index } = TXIDMerkletree.getTreeAndIndexFromGlobalPosition(txidIndex);
        return this.getHistoricalMerkleroot(tree, index);
    }
}
exports.TXIDMerkletree = TXIDMerkletree;
//# sourceMappingURL=txid-merkletree.js.map