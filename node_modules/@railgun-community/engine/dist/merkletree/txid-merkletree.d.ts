import { Database } from '../database/database';
import { Chain } from '../models/engine-types';
import { MerklerootValidator } from '../models/merkletree-types';
import { Merkletree } from './merkletree';
import { TXIDMerkletreeData, RailgunTransactionWithHash, MerkleProof } from '../models/formatted-types';
import { TXIDVersion } from '../models';
type POILaunchSnapshotNode = {
    hash: string;
    index: number;
};
export declare class TXIDMerkletree extends Merkletree<RailgunTransactionWithHash> {
    protected merkletreePrefix: string;
    protected merkletreeType: string;
    shouldStoreMerkleroots: boolean;
    shouldSavePOILaunchSnapshot: boolean;
    savedPOILaunchSnapshot: Optional<boolean>;
    private constructor();
    /**
     * Wallet validates merkleroots against POI Nodes.
     */
    static createForWallet(db: Database, chain: Chain, txidVersion: TXIDVersion, merklerootValidator: MerklerootValidator): Promise<TXIDMerkletree>;
    /**
     * POI Node is the source of truth, so it will not validate merkleroots.
     * Instead, it will process every tree update individually, and store each in the database.
     */
    static createForPOINode(db: Database, chain: Chain, txidVersion: TXIDVersion): Promise<TXIDMerkletree>;
    /**
     * Gets Railgun Transaction data from txid tree.
     */
    getRailgunTransaction(tree: number, index: number): Promise<Optional<RailgunTransactionWithHash>>;
    getGlobalUTXOTreePositionForRailgunTransactionCommitment(tree: number, index: number, commitmentHash: string): Promise<number>;
    getRailgunTxidCurrentMerkletreeData(railgunTxid: string): Promise<TXIDMerkletreeData>;
    getMerkleProofWithSnapshot(snapshotLeaf: POILaunchSnapshotNode, tree: number, index: number): Promise<MerkleProof>;
    railgunTxidOccurredBeforeBlockNumber(tree: number, index: number, blockNumber: number): Promise<boolean>;
    getLatestRailgunTransaction(): Promise<Optional<RailgunTransactionWithHash>>;
    queueRailgunTransactions(railgunTransactionsWithTxids: RailgunTransactionWithHash[], maxTxidIndex: Optional<number>): Promise<void>;
    static isOutOfBounds(tree: number, index: number, maxTxidIndex?: number): boolean;
    static nextTreeAndIndex(tree: number, index: number): {
        tree: number;
        index: number;
    };
    private savePOILaunchSnapshotIfNecessary;
    private hasSavedPOILaunchSnapshot;
    getPOILaunchSnapshotNode(level: number): Promise<Optional<POILaunchSnapshotNode>>;
    private static getRightmostNonzeroIndices;
    private savePOILaunchSnapshot;
    clearLeavesForInvalidVerificationHash(numLeavesToClear: number): Promise<void>;
    clearLeavesAfterTxidIndex(txidIndex: number): Promise<void>;
    getCurrentTxidIndex(): Promise<number>;
    protected validRootCallback(): Promise<void>;
    protected invalidRootCallback(): Promise<void>;
    private getPOILaunchSnapshotNodeDBPath;
    private getRailgunTxidLookupDBPath;
    getTxidIndexByRailgunTxid(railgunTxid: string): Promise<Optional<number>>;
    getRailgunTransactionByTxid(railgunTxid: string): Promise<Optional<RailgunTransactionWithHash>>;
    private getHistoricalMerklerootDBPath;
    protected newLeafRootTrigger(tree: number, index: number, leaf: string, merkleroot: string): Promise<void>;
    getHistoricalMerkleroot(tree: number, index: number): Promise<Optional<string>>;
    getHistoricalMerklerootForTxidIndex(txidIndex: number): Promise<Optional<string>>;
}
export {};
