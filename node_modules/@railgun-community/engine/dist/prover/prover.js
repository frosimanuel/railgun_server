"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Prover = void 0;
const debugger_1 = __importDefault(require("../debugger/debugger"));
const bytes_1 = require("../utils/bytes");
const stringify_1 = require("../utils/stringify");
const proof_cache_1 = require("./proof-cache");
const proof_cache_poi_1 = require("./proof-cache-poi");
const merkletree_types_1 = require("../models/merkletree-types");
const is_defined_1 = require("../utils/is-defined");
const progress_service_1 = require("./progress-service");
const ZERO_VALUE_POI = merkletree_types_1.MERKLE_ZERO_VALUE_BIGINT;
class Prover {
    artifactGetter;
    groth16;
    constructor(artifactGetter) {
        this.artifactGetter = artifactGetter;
    }
    /**
     * Used to set Groth16 implementation from snarkjs.min.js or snarkjs.
     */
    setSnarkJSGroth16(snarkJSGroth16) {
        const suppressDebugLogger = { debug: () => { } };
        this.groth16 = {
            fullProveRailgun: async (formattedInputs, wasm, zkey, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            _logger, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            _dat, progressCallback) => {
                const progressService = new progress_service_1.ProgressService(0, // startValue
                95, // endValue
                1500, // totalMsec
                250);
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                progressService.progressSteadily(progressCallback);
                try {
                    const proof = await snarkJSGroth16.fullProve(formattedInputs, wasm, zkey, suppressDebugLogger);
                    progressService.stop();
                    return proof;
                }
                catch (cause) {
                    progressService.stop();
                    throw new Error('SnarkJS failed to fullProveRailgun', { cause });
                }
            },
            fullProvePOI: async (formattedInputs, wasm, zkey, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            _logger, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            _dat, progressCallback) => {
                const progressService = new progress_service_1.ProgressService(0, // startValue
                95, // endValue
                3000, // totalMsec
                250);
                // eslint-disable-next-line @typescript-eslint/no-floating-promises
                progressService.progressSteadily(progressCallback);
                try {
                    const proof = await snarkJSGroth16.fullProve(formattedInputs, wasm, zkey, suppressDebugLogger);
                    progressService.stop();
                    return proof;
                }
                catch (cause) {
                    progressService.stop();
                    throw new Error('SnarkJS failed to fullProvePOI', { cause });
                }
            },
            verify: snarkJSGroth16.verify,
        };
    }
    /**
     * Used to set Groth16 implementation from RAILGUN Native Prover.
     */
    setNativeProverGroth16(nativeProveRailgun, nativeProvePOI, circuits) {
        const circuitIdForInputsOutputs = (inputs, outputs) => {
            const circuitString = `${inputs}X${outputs}`;
            const circuitName = `JOINSPLIT_${circuitString}`;
            const circuitId = circuits[circuitName];
            if (circuitId == null) {
                throw new Error(`No circuit found for ${circuitString.toLowerCase()}`);
            }
            return circuitId;
        };
        const fullProveRailgun = (formattedInputs, _wasm, zkey, logger, dat, progressCallback) => {
            try {
                if (!dat) {
                    throw new Error('DAT artifact is required.');
                }
                const inputs = formattedInputs.nullifiers.length;
                const outputs = formattedInputs.commitmentsOut.length;
                const circuitId = circuitIdForInputsOutputs(inputs, outputs);
                const stringInputs = (0, stringify_1.stringifySafe)(formattedInputs);
                logger.debug(stringInputs);
                const jsonInputs = JSON.parse(stringInputs);
                const datBuffer = dat;
                const zkeyBuffer = zkey;
                const start = Date.now();
                const proof = nativeProveRailgun(circuitId, datBuffer, zkeyBuffer, jsonInputs, progressCallback);
                logger.debug(`Proof lapsed ${Date.now() - start} ms`);
                return Promise.resolve({ proof });
            }
            catch (cause) {
                if (!(cause instanceof Error)) {
                    throw new Error('Non-error thrown by native prover fullProveRailgun', { cause });
                }
                logger.debug(cause.message);
                throw new Error('Native-prover failed to fullProveRailgun', { cause });
            }
        };
        const circuitIdForInputsOutputsPOI = (inputs, outputs) => {
            const circuitString = `${inputs}X${outputs}`;
            const circuitName = `POI_${inputs}X${outputs}`;
            const circuitId = circuits[circuitName];
            if (circuitId == null) {
                throw new Error(`No circuit found for ${circuitString.toLowerCase()}`);
            }
            return circuitId;
        };
        const fullProvePOI = (formattedInputs, _wasm, zkey, logger, dat, progressCallback) => {
            try {
                if (!dat) {
                    throw new Error('DAT artifact is required.');
                }
                const stringInputs = (0, stringify_1.stringifySafe)(formattedInputs);
                logger.debug(stringInputs);
                const jsonInputs = JSON.parse(stringInputs);
                const datBuffer = dat;
                const zkeyBuffer = zkey;
                const start = Date.now();
                const inputs = formattedInputs.nullifiers.length;
                const outputs = formattedInputs.commitmentsOut.length;
                const circuitId = circuitIdForInputsOutputsPOI(inputs, outputs);
                const proof = nativeProvePOI(circuitId, datBuffer, zkeyBuffer, jsonInputs, progressCallback);
                logger.debug(`Proof lapsed ${Date.now() - start} ms`);
                return Promise.resolve({ proof });
            }
            catch (cause) {
                if (!(cause instanceof Error)) {
                    throw new Error('Non-error thrown by native prover fullProvePOI', { cause });
                }
                logger.debug(cause.message);
                throw new Error('Native-prover failed to fullProvePOI', { cause });
            }
        };
        this.groth16 = {
            fullProveRailgun,
            fullProvePOI,
            // Proof will be verified during gas estimate, and on-chain.
            verify: undefined,
        };
    }
    async verifyRailgunProof(publicInputs, proof, artifacts) {
        if (!this.groth16) {
            throw new Error('Requires groth16 implementation');
        }
        if (!this.groth16.verify) {
            // Wallet-side verification is a fail-safe.
            // Snark verification will occur during gas estimate (and on-chain) regardless.
            return true;
        }
        // Return output of groth16 verify
        const publicSignals = [
            publicInputs.merkleRoot,
            publicInputs.boundParamsHash,
            ...publicInputs.nullifiers,
            ...publicInputs.commitmentsOut,
        ];
        return this.groth16.verify(artifacts.vkey, publicSignals, proof);
    }
    async verifyPOIProof(publicInputs, proof, maxInputs, maxOutputs) {
        if (!this.groth16) {
            throw new Error('Requires groth16 implementation');
        }
        if (!this.groth16.verify) {
            // Wallet-side verification is a fail-safe.
            // Snark verification will occur during gas estimate (and on-chain) regardless.
            return true;
        }
        const artifacts = await this.artifactGetter.getArtifactsPOI(maxInputs, maxOutputs);
        // MUST MATCH THE ORDER OF PUBLIC SIGNALS FROM CIRCUIT
        const publicSignals = [
            ...publicInputs.blindedCommitmentsOut,
            publicInputs.anyRailgunTxidMerklerootAfterTransaction,
            publicInputs.railgunTxidIfHasUnshield,
            ...publicInputs.poiMerkleroots,
        ];
        return this.groth16.verify(artifacts.vkey, publicSignals, proof);
    }
    static get zeroProof() {
        const zero = bytes_1.ByteUtils.nToHex(BigInt(0), bytes_1.ByteLength.UINT_8);
        // prettier-ignore
        return {
            pi_a: [zero, zero],
            pi_b: [[zero, zero], [zero, zero]],
            pi_c: [zero, zero],
        };
    }
    dummyProveRailgun(publicInputs) {
        // Make sure we have valid artifacts for this number of inputs.
        // Note that the artifacts are not used in the dummy proof.
        this.artifactGetter.assertArtifactExists(publicInputs.nullifiers.length, publicInputs.commitmentsOut.length);
        return Prover.zeroProof;
    }
    async proveRailgun(txidVersion, unprovedTransactionInputs, progressCallback) {
        if (!this.groth16) {
            throw new Error('Requires groth16 full prover implementation');
        }
        const { publicInputs } = unprovedTransactionInputs;
        const existingProof = proof_cache_1.ProofCache.get(unprovedTransactionInputs);
        if (existingProof) {
            return { proof: existingProof, publicInputs };
        }
        // 1-2  1-3  2-2  2-3  8-2 [nullifiers, commitments]
        // Fetch artifacts
        progressCallback(5);
        const artifacts = await this.artifactGetter.getArtifacts(publicInputs);
        if (!artifacts.wasm && !artifacts.dat) {
            throw new Error('Requires WASM or DAT prover artifact');
        }
        // Get formatted inputs
        const formattedInputs = Prover.formatRailgunInputs(unprovedTransactionInputs);
        // Generate proof: Progress from 20 - 99%
        const initialProgressProof = 20;
        const finalProgressProof = 99;
        progressCallback(initialProgressProof);
        const { proof } = await this.groth16.fullProveRailgun(formattedInputs, artifacts.wasm, artifacts.zkey, { debug: (msg) => debugger_1.default.log(msg) }, artifacts.dat, (progress) => {
            progressCallback((progress * (finalProgressProof - initialProgressProof)) / 100 + initialProgressProof);
        });
        progressCallback(finalProgressProof);
        // Throw if proof is invalid
        if (!(await this.verifyRailgunProof(publicInputs, proof, artifacts))) {
            throw new Error('Proof verification failed');
        }
        proof_cache_1.ProofCache.store(unprovedTransactionInputs, proof);
        progressCallback(100);
        // Return proof with inputs
        return {
            proof,
            publicInputs,
        };
    }
    // eslint-disable-next-line class-methods-use-this
    getPublicInputsPOI(anyRailgunTxidMerklerootAfterTransaction, blindedCommitmentsOut, poiMerkleroots, railgunTxidIfHasUnshield, maxInputs, maxOutputs) {
        const publicInputs = {
            blindedCommitmentsOut: Prover.padWithZerosToMax(blindedCommitmentsOut.map((x) => bytes_1.ByteUtils.hexToBigInt(x)), maxOutputs, 0n),
            railgunTxidIfHasUnshield: bytes_1.ByteUtils.hexToBigInt(railgunTxidIfHasUnshield),
            anyRailgunTxidMerklerootAfterTransaction: bytes_1.ByteUtils.hexToBigInt(anyRailgunTxidMerklerootAfterTransaction),
            poiMerkleroots: Prover.padWithZerosToMax(poiMerkleroots.map((x) => bytes_1.ByteUtils.hexToBigInt(x)), maxInputs),
        };
        return publicInputs;
    }
    // eslint-disable-next-line class-methods-use-this
    static getMaxInputsOutputsForPOI(inputs) {
        if (inputs.nullifiers.length <= 3 && inputs.commitmentsOut.length <= 3) {
            // "Mini" POI circuit
            return { maxInputs: 3, maxOutputs: 3 };
        }
        // "Full" POI circuit
        return { maxInputs: 13, maxOutputs: 13 };
    }
    async provePOI(inputs, listKey, blindedCommitmentsIn, blindedCommitmentsOut, progressCallback) {
        const { maxInputs, maxOutputs } = Prover.getMaxInputsOutputsForPOI(inputs);
        return this.provePOIForInputsOutputs(inputs, listKey, blindedCommitmentsIn, blindedCommitmentsOut, maxInputs, maxOutputs, progressCallback);
    }
    async provePOIForInputsOutputs(inputs, listKey, blindedCommitmentsIn, blindedCommitmentsOut, maxInputs, maxOutputs, progressCallback) {
        if (!this.groth16) {
            throw new Error('Requires groth16 full prover implementation');
        }
        const publicInputs = this.getPublicInputsPOI(inputs.anyRailgunTxidMerklerootAfterTransaction, blindedCommitmentsOut, inputs.poiMerkleroots, inputs.railgunTxidIfHasUnshield, maxInputs, maxOutputs);
        const existingProof = proof_cache_poi_1.ProofCachePOI.get(listKey, inputs.anyRailgunTxidMerklerootAfterTransaction, blindedCommitmentsOut, inputs.poiMerkleroots, inputs.railgunTxidIfHasUnshield);
        if (existingProof &&
            (await this.verifyPOIProof(publicInputs, existingProof, maxInputs, maxOutputs))) {
            return { proof: existingProof, publicInputs };
        }
        progressCallback(5);
        const artifacts = await this.artifactGetter.getArtifactsPOI(maxInputs, maxOutputs);
        if (!artifacts.wasm && !artifacts.dat) {
            throw new Error('Requires WASM or DAT prover artifact');
        }
        const formattedInputs = Prover.formatPOIInputs(inputs, maxInputs, maxOutputs);
        // Generate proof: Progress from 10 - 95%
        const initialProgressProof = 10;
        const finalProgressProof = 95;
        progressCallback(initialProgressProof);
        try {
            const proofData = await this.groth16.fullProvePOI(formattedInputs, artifacts.wasm, artifacts.zkey, { debug: (msg) => debugger_1.default.log(msg) }, artifacts.dat, (progress) => {
                progressCallback((progress * (finalProgressProof - initialProgressProof)) / 100 + initialProgressProof);
            });
            const { proof, publicSignals } = proofData;
            if ((0, is_defined_1.isDefined)(publicSignals)) {
                // snarkjs will provide publicSignals for validation
                for (let i = 0; i < blindedCommitmentsOut.length; i += 1) {
                    const blindedCommitmentOutString = publicInputs.blindedCommitmentsOut[i].toString();
                    if (blindedCommitmentOutString !== publicSignals[i]) {
                        throw new Error(`Invalid blindedCommitmentOut value: expected ${publicSignals[i]}, got ${blindedCommitmentOutString}`);
                    }
                }
            }
            progressCallback(finalProgressProof);
            // For some reason, the proof returned by snarkjs contains extra fields.
            // Trim them off.
            const snarkProof = {
                pi_a: [proof.pi_a[0], proof.pi_a[1]],
                pi_b: [proof.pi_b[0], proof.pi_b[1]],
                pi_c: [proof.pi_c[0], proof.pi_c[1]],
            };
            // Throw if proof is invalid
            if (!(await this.verifyPOIProof(publicInputs, snarkProof, maxInputs, maxOutputs))) {
                // eslint-disable-next-line no-console
                throw new Error('POI proof verification failed');
            }
            proof_cache_poi_1.ProofCachePOI.store(listKey, inputs.anyRailgunTxidMerklerootAfterTransaction, blindedCommitmentsOut, inputs.poiMerkleroots, inputs.railgunTxidIfHasUnshield, snarkProof);
            progressCallback(100);
            // Return proof with inputs
            return {
                proof: snarkProof,
                publicInputs,
            };
        }
        catch (cause) {
            if (!(cause instanceof Error)) {
                throw new Error('Non-error thrown by provePOIForInputsOutputs', { cause });
            }
            debugger_1.default.log('Formatted POI proof inputs:');
            debugger_1.default.log((0, stringify_1.stringifySafe)(formattedInputs));
            debugger_1.default.log('blindedCommitmentsIn');
            debugger_1.default.log(JSON.stringify(blindedCommitmentsIn));
            debugger_1.default.log('blindedCommitmentsOut');
            debugger_1.default.log(JSON.stringify(blindedCommitmentsOut));
            throw new Error('Unable to generate POI proof', { cause });
        }
    }
    static formatProof(proof) {
        return {
            a: {
                x: BigInt(proof.pi_a[0]),
                y: BigInt(proof.pi_a[1]),
            },
            b: {
                x: [BigInt(proof.pi_b[0][1]), BigInt(proof.pi_b[0][0])],
                y: [BigInt(proof.pi_b[1][1]), BigInt(proof.pi_b[1][0])],
            },
            c: {
                x: BigInt(proof.pi_c[0]),
                y: BigInt(proof.pi_c[1]),
            },
        };
    }
    static formatRailgunInputs(transactionInputs) {
        const { publicInputs, privateInputs } = transactionInputs;
        return {
            merkleRoot: publicInputs.merkleRoot,
            boundParamsHash: publicInputs.boundParamsHash,
            nullifiers: publicInputs.nullifiers,
            commitmentsOut: publicInputs.commitmentsOut,
            token: privateInputs.tokenAddress,
            publicKey: privateInputs.publicKey,
            signature: transactionInputs.signature,
            randomIn: privateInputs.randomIn,
            valueIn: privateInputs.valueIn,
            pathElements: privateInputs.pathElements.flat(2),
            leavesIndices: privateInputs.leavesIndices,
            nullifyingKey: privateInputs.nullifyingKey,
            npkOut: privateInputs.npkOut,
            valueOut: privateInputs.valueOut,
        };
    }
    static padWithZerosToMax(array, max, zeroValue = ZERO_VALUE_POI) {
        const padded = [...array];
        while (padded.length < max) {
            padded.push(zeroValue);
        }
        return padded;
    }
    static padWithArraysOfZerosToMaxAndLength(doubleArray, max, length, zeroValue = ZERO_VALUE_POI) {
        const padded = [...doubleArray];
        while (padded.length < max) {
            padded.push(new Array(length).fill(zeroValue));
        }
        return padded;
    }
    static formatPOIInputs(proofInputs, maxInputs, maxOutputs) {
        return {
            anyRailgunTxidMerklerootAfterTransaction: bytes_1.ByteUtils.hexToBigInt(proofInputs.anyRailgunTxidMerklerootAfterTransaction),
            boundParamsHash: bytes_1.ByteUtils.hexToBigInt(proofInputs.boundParamsHash),
            nullifiers: this.padWithZerosToMax(proofInputs.nullifiers.map((x) => bytes_1.ByteUtils.hexToBigInt(x)), maxInputs),
            commitmentsOut: this.padWithZerosToMax(proofInputs.commitmentsOut.map((x) => bytes_1.ByteUtils.hexToBigInt(x)), maxOutputs),
            spendingPublicKey: proofInputs.spendingPublicKey,
            nullifyingKey: proofInputs.nullifyingKey,
            token: bytes_1.ByteUtils.hexToBigInt(proofInputs.token),
            randomsIn: this.padWithZerosToMax(proofInputs.randomsIn.map((x) => bytes_1.ByteUtils.hexToBigInt(x)), maxInputs),
            valuesIn: this.padWithZerosToMax(proofInputs.valuesIn, maxOutputs, 0n),
            utxoPositionsIn: this.padWithZerosToMax(proofInputs.utxoPositionsIn.map(BigInt), maxInputs),
            utxoTreeIn: BigInt(proofInputs.utxoTreeIn),
            npksOut: this.padWithZerosToMax(proofInputs.npksOut, maxOutputs),
            valuesOut: this.padWithZerosToMax(proofInputs.valuesOut, maxOutputs, 0n),
            utxoBatchGlobalStartPositionOut: BigInt(proofInputs.utxoBatchGlobalStartPositionOut),
            railgunTxidIfHasUnshield: BigInt(proofInputs.railgunTxidIfHasUnshield),
            railgunTxidMerkleProofIndices: bytes_1.ByteUtils.hexToBigInt(proofInputs.railgunTxidMerkleProofIndices),
            railgunTxidMerkleProofPathElements: proofInputs.railgunTxidMerkleProofPathElements.map((x) => bytes_1.ByteUtils.hexToBigInt(x)),
            poiMerkleroots: this.padWithZerosToMax(proofInputs.poiMerkleroots.map((x) => bytes_1.ByteUtils.hexToBigInt(x)), maxInputs),
            poiInMerkleProofIndices: this.padWithZerosToMax(proofInputs.poiInMerkleProofIndices.map((x) => bytes_1.ByteUtils.hexToBigInt(x)), maxInputs, 0n),
            poiInMerkleProofPathElements: this.padWithArraysOfZerosToMaxAndLength(proofInputs.poiInMerkleProofPathElements.map((pathElements) => pathElements.map((x) => bytes_1.ByteUtils.hexToBigInt(x))), maxInputs, 16),
        };
    }
}
exports.Prover = Prover;
//# sourceMappingURL=prover.js.map