"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.POI = exports.POIListType = void 0;
const poi_types_1 = require("../models/poi-types");
const txo_types_1 = require("../models/txo-types");
const is_defined_1 = require("../utils/is-defined");
const models_1 = require("../models");
const commitment_1 = require("../utils/commitment");
const registry_1 = require("../utils/registry");
var POIListType;
(function (POIListType) {
    POIListType["Active"] = "Active";
    POIListType["Gather"] = "Gather";
})(POIListType || (exports.POIListType = POIListType = {}));
class POI {
    static lists;
    static nodeInterface;
    static launchBlocks = new registry_1.Registry();
    static init(lists, nodeInterface) {
        this.lists = lists;
        this.nodeInterface = nodeInterface;
    }
    static getAllListKeys() {
        return this.lists.map((list) => list.key);
    }
    static getActiveListKeys() {
        return this.lists.filter((list) => list.type === POIListType.Active).map((list) => list.key);
    }
    static getBalanceBucket(txo) {
        if (txo.spendtxid !== false) {
            return txo_types_1.WalletBalanceBucket.Spent;
        }
        const pois = txo.poisPerList;
        const isChange = txo.note.outputType === models_1.OutputType.Change;
        const activeListKeys = POI.getActiveListKeys();
        if (!pois || !this.hasAllKeys(pois, activeListKeys)) {
            if ((0, commitment_1.isShieldCommitmentType)(txo.commitmentType)) {
                return txo_types_1.WalletBalanceBucket.ShieldPending;
            }
            return isChange
                ? txo_types_1.WalletBalanceBucket.MissingInternalPOI
                : txo_types_1.WalletBalanceBucket.MissingExternalPOI;
        }
        if (POI.hasValidPOIsActiveLists(pois)) {
            return txo_types_1.WalletBalanceBucket.Spendable;
        }
        const anyPOIIsShieldBlocked = activeListKeys.some((listKey) => {
            return pois[listKey] === poi_types_1.TXOPOIListStatus.ShieldBlocked;
        });
        if (anyPOIIsShieldBlocked) {
            return txo_types_1.WalletBalanceBucket.ShieldBlocked;
        }
        if ((0, commitment_1.isShieldCommitmentType)(txo.commitmentType)) {
            return txo_types_1.WalletBalanceBucket.ShieldPending;
        }
        const anyPOIIsProofSubmitted = activeListKeys.some((listKey) => {
            return pois[listKey] === poi_types_1.TXOPOIListStatus.ProofSubmitted;
        });
        if (anyPOIIsProofSubmitted) {
            return txo_types_1.WalletBalanceBucket.ProofSubmitted;
        }
        return isChange
            ? txo_types_1.WalletBalanceBucket.MissingInternalPOI
            : txo_types_1.WalletBalanceBucket.MissingExternalPOI;
    }
    static validatePOIStatusForAllLists(pois, listKeys, statuses) {
        if (!this.hasAllKeys(pois, listKeys)) {
            return false;
        }
        for (const listKey of listKeys) {
            if (!statuses.includes(pois[listKey])) {
                return false;
            }
        }
        return true;
    }
    static hasValidPOIsAllLists(pois) {
        const listKeys = this.getAllListKeys();
        return this.validatePOIStatusForAllLists(pois, listKeys, [poi_types_1.TXOPOIListStatus.Valid]);
    }
    static hasValidPOIsActiveLists(pois) {
        if (!pois) {
            return false;
        }
        const listKeys = this.getActiveListKeys();
        return this.validatePOIStatusForAllLists(pois, listKeys, [poi_types_1.TXOPOIListStatus.Valid]);
    }
    static getAllListKeysWithValidInputPOIs(inputPOIsPerList) {
        const listKeys = this.getAllListKeys();
        const listKeysShouldGenerateSpentPOIs = [];
        for (const listKey of listKeys) {
            const everyInputPOIValid = inputPOIsPerList.every((poisPerList) => {
                return poisPerList[listKey] === poi_types_1.TXOPOIListStatus.Valid;
            });
            if (everyInputPOIValid) {
                listKeysShouldGenerateSpentPOIs.push(listKey);
            }
        }
        return listKeysShouldGenerateSpentPOIs;
    }
    static findListsForNewPOIs(poisPerList) {
        const listKeys = this.getAllListKeys();
        if (!(0, is_defined_1.isDefined)(poisPerList)) {
            return listKeys;
        }
        const submittedStatuses = [poi_types_1.TXOPOIListStatus.ProofSubmitted, poi_types_1.TXOPOIListStatus.Valid];
        const needsSpendPOI = [];
        for (const listKey of listKeys) {
            const isUnsubmitted = !(0, is_defined_1.isDefined)(poisPerList[listKey]) || !submittedStatuses.includes(poisPerList[listKey]);
            if (isUnsubmitted) {
                needsSpendPOI.push(listKey);
            }
        }
        return needsSpendPOI;
    }
    static hasAllKeys(obj, keys) {
        return keys.every((key) => Object.prototype.hasOwnProperty.call(obj, key));
    }
    static getListKeysCanGenerateSpentPOIs(spentTXOs, sentCommitments, unshieldEvents, isLegacyPOIProof) {
        if (!sentCommitments.length && !unshieldEvents.length) {
            return [];
        }
        const inputPOIsPerList = (0, is_defined_1.removeUndefineds)(spentTXOs.map((txo) => txo.poisPerList));
        const listKeysWithValidInputPOIs = isLegacyPOIProof
            ? POI.getAllListKeys()
            : POI.getAllListKeysWithValidInputPOIs(inputPOIsPerList);
        const validStatuses = [poi_types_1.TXOPOIListStatus.Valid, poi_types_1.TXOPOIListStatus.ProofSubmitted];
        return listKeysWithValidInputPOIs.filter((listKey) => {
            // If all statuses are valid, then no need to generate new POIs.
            const allSentCommitmentZeroOrPOIsValid = sentCommitments.every((sentCommitment) => {
                if (sentCommitment.note.value === 0n) {
                    // If sentCommitment value is 0, then no need to generate new POIs.
                    return true;
                }
                const poiStatus = sentCommitment.poisPerList?.[listKey];
                return poiStatus && validStatuses.includes(poiStatus);
            });
            const allUnshieldPOIsValid = unshieldEvents.every((unshieldEvent) => {
                const poiStatus = unshieldEvent.poisPerList?.[listKey];
                return poiStatus && validStatuses.includes(poiStatus);
            });
            const allPOIsValid = allSentCommitmentZeroOrPOIsValid && allUnshieldPOIsValid;
            return !allPOIsValid;
        });
    }
    static getListKeysCanSubmitLegacyTransactEvents(TXOs) {
        const listKeys = this.getAllListKeys();
        return listKeys.filter((listKey) => {
            return !TXOs.every((txo) => txo.poisPerList?.[listKey] === poi_types_1.TXOPOIListStatus.Valid);
        });
    }
    static isLegacyTXO(chain, txo) {
        const launchBlock = this.launchBlocks.get(null, chain);
        if (!(0, is_defined_1.isDefined)(launchBlock) || txo.blockNumber < launchBlock) {
            return true;
        }
        return false;
    }
    static shouldSubmitLegacyTransactEventsTXOs(chain, txo) {
        if (!(0, is_defined_1.isDefined)(txo.transactCreationRailgunTxid)) {
            return false;
        }
        if (!(0, is_defined_1.isDefined)(txo.blindedCommitment)) {
            return false;
        }
        if (!this.isLegacyTXO(chain, txo)) {
            return false;
        }
        if (!(0, is_defined_1.isDefined)(txo.poisPerList)) {
            return false;
        }
        if (!(0, commitment_1.isTransactCommitmentType)(txo.commitmentType)) {
            return false;
        }
        return !POI.hasValidPOIsAllLists(txo.poisPerList);
    }
    static shouldRetrieveTXOPOIs(txo) {
        if (!(0, is_defined_1.isDefined)(txo.blindedCommitment)) {
            return false;
        }
        if (!(0, is_defined_1.isDefined)(txo.poisPerList)) {
            return true;
        }
        return !POI.hasValidPOIsAllLists(txo.poisPerList);
    }
    static shouldRetrieveSentCommitmentPOIs(sentCommitment) {
        if (!(0, is_defined_1.isDefined)(sentCommitment.blindedCommitment)) {
            return false;
        }
        if (sentCommitment.note.value === 0n) {
            return false;
        }
        if (!(0, is_defined_1.isDefined)(sentCommitment.poisPerList)) {
            return true;
        }
        return !POI.hasValidPOIsAllLists(sentCommitment.poisPerList);
    }
    static shouldRetrieveUnshieldEventPOIs(unshieldEvent) {
        if (!(0, is_defined_1.isDefined)(unshieldEvent.railgunTxid)) {
            return false;
        }
        if (!(0, is_defined_1.isDefined)(unshieldEvent.poisPerList)) {
            return true;
        }
        return !POI.hasValidPOIsAllLists(unshieldEvent.poisPerList);
    }
    static shouldGenerateSpentPOIsSentCommitment(sentCommitment) {
        if (!(0, is_defined_1.isDefined)(sentCommitment.blindedCommitment)) {
            return false;
        }
        if (sentCommitment.note.value === 0n) {
            return false;
        }
        if (!(0, is_defined_1.isDefined)(sentCommitment.poisPerList)) {
            return true;
        }
        const listKeys = POI.findListsForNewPOIs(sentCommitment.poisPerList);
        return listKeys.length > 0;
    }
    static shouldGenerateSpentPOIsUnshieldEvent(unshieldEvent) {
        if (!(0, is_defined_1.isDefined)(unshieldEvent.railgunTxid)) {
            return false;
        }
        if (!(0, is_defined_1.isDefined)(unshieldEvent.poisPerList)) {
            return true;
        }
        const listKeys = POI.findListsForNewPOIs(unshieldEvent.poisPerList);
        return listKeys.length > 0;
    }
    static isActiveForChain(chain) {
        try {
            return this.nodeInterface.isActive(chain);
        }
        catch (err) {
            return false;
        }
    }
    static isRequiredForChain(chain) {
        return this.nodeInterface.isRequired(chain);
    }
    static async getSpendableBalanceBuckets(chain) {
        const poiRequired = await this.isRequiredForChain(chain);
        return poiRequired
            ? [txo_types_1.WalletBalanceBucket.Spendable]
            : // Until POI is active, all balance buckets are spendable.
                Object.values(txo_types_1.WalletBalanceBucket);
    }
    static retrievePOIsForBlindedCommitments(txidVersion, chain, blindedCommitmentDatas) {
        if (!(0, is_defined_1.isDefined)(this.nodeInterface)) {
            throw new Error('POI node interface not initialized');
        }
        if (blindedCommitmentDatas.length > 1000) {
            throw new Error('Cannot retrieve POIs for more than 1000 blinded commitments at a time');
        }
        const listKeys = this.getAllListKeys();
        return this.nodeInterface.getPOIsPerList(txidVersion, chain, listKeys, blindedCommitmentDatas);
    }
    static getPOIMerkleProofs(txidVersion, chain, listKey, blindedCommitmentsIn) {
        if (!(0, is_defined_1.isDefined)(this.nodeInterface)) {
            throw new Error('POI node interface not initialized');
        }
        return this.nodeInterface.getPOIMerkleProofs(txidVersion, chain, listKey, blindedCommitmentsIn);
    }
    static validatePOIMerkleroots(txidVersion, chain, listKey, poiMerkleroots) {
        if (!(0, is_defined_1.isDefined)(this.nodeInterface)) {
            throw new Error('POI node interface not initialized');
        }
        return this.nodeInterface.validatePOIMerkleroots(txidVersion, chain, listKey, poiMerkleroots);
    }
    static async submitPOI(txidVersion, chain, listKey, snarkProof, poiMerkleroots, txidMerkleroot, txidMerklerootIndex, blindedCommitmentsOut, railgunTxidIfHasUnshield) {
        if (!(0, is_defined_1.isDefined)(this.nodeInterface)) {
            throw new Error('POI node interface not initialized');
        }
        await this.nodeInterface.submitPOI(txidVersion, chain, listKey, snarkProof, poiMerkleroots, txidMerkleroot, txidMerklerootIndex, blindedCommitmentsOut, railgunTxidIfHasUnshield);
    }
    static async submitLegacyTransactProofs(txidVersion, chain, listKeys, legacyTransactProofDatas) {
        if (!(0, is_defined_1.isDefined)(this.nodeInterface)) {
            throw new Error('POI node interface not initialized');
        }
        await this.nodeInterface.submitLegacyTransactProofs(txidVersion, chain, listKeys, legacyTransactProofDatas);
    }
}
exports.POI = POI;
//# sourceMappingURL=poi.js.map