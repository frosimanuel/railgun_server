"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatTXOsSpentPOIStatusInfo = exports.formatTXOsReceivedPOIStatusInfo = void 0;
const merkletree_1 = require("../merkletree/merkletree");
const note_1 = require("../note");
const bytes_1 = require("../utils/bytes");
const hash_emoji_1 = require("../utils/hash-emoji");
const is_defined_1 = require("../utils/is-defined");
const poi_1 = require("./poi");
const formatTXOsReceivedPOIStatusInfo = async (TXOs) => {
    const statusInfos = [];
    await Promise.all(TXOs.map(async (txo) => {
        const { tree, position, txid } = txo;
        const statusInfo = {
            strings: {
                tree,
                position,
                txid,
                commitment: `${bytes_1.ByteUtils.nToHex(txo.note.hash, bytes_1.ByteLength.UINT_256, true)} (${txo.commitmentType})`,
                blindedCommitment: txo.blindedCommitment ?? 'Unavailable',
                poisPerList: txo.poisPerList,
            },
            emojis: {
                tree,
                position,
                txid: (0, hash_emoji_1.emojiHashForPOIStatusInfo)(txid),
                commitment: `${(0, hash_emoji_1.emojiHashForPOIStatusInfo)(bytes_1.ByteUtils.nToHex(txo.note.hash, bytes_1.ByteLength.UINT_256))} (${txo.commitmentType})`,
                blindedCommitment: (0, is_defined_1.isDefined)(txo.blindedCommitment)
                    ? (0, hash_emoji_1.emojiHashForPOIStatusInfo)(txo.blindedCommitment)
                    : 'Unavailable',
                poisPerList: txo.poisPerList,
            },
        };
        return statusInfos.push(statusInfo);
    }));
    // Sort descending by global tree/position.
    return statusInfos.sort(({ strings: stringsA }, { strings: stringsB }) => merkletree_1.Merkletree.getGlobalPosition(stringsB.tree, stringsB.position) -
        merkletree_1.Merkletree.getGlobalPosition(stringsA.tree, stringsA.position));
};
exports.formatTXOsReceivedPOIStatusInfo = formatTXOsReceivedPOIStatusInfo;
const formatTXOsSpentPOIStatusInfo = async (txidMerkletree, sentCommitments, TXOs, unshieldEvents) => {
    const txidGroups = {};
    for (const sentCommitment of sentCommitments) {
        txidGroups[sentCommitment.txid] ??= {
            sentCommitments: [],
            unshieldEvents: [],
        };
        txidGroups[sentCommitment.txid].sentCommitments.push(sentCommitment);
    }
    for (const unshieldEvent of unshieldEvents) {
        txidGroups[unshieldEvent.txid] ??= {
            sentCommitments: [],
            unshieldEvents: [],
        };
        txidGroups[unshieldEvent.txid].unshieldEvents.push(unshieldEvent);
    }
    const statusInfos = [];
    await Promise.all(Object.keys(txidGroups).map(async (txid) => {
        const txidGroup = txidGroups[txid];
        const railgunTxidGroups = {};
        for (const sentCommitment of txidGroup.sentCommitments) {
            if (!(0, is_defined_1.isDefined)(sentCommitment.railgunTxid)) {
                continue;
            }
            railgunTxidGroups[sentCommitment.railgunTxid] ??= {
                sentCommitments: [],
                unshieldEvents: [],
            };
            railgunTxidGroups[sentCommitment.railgunTxid].sentCommitments.push(sentCommitment);
        }
        for (const unshieldEvent of txidGroup.unshieldEvents) {
            if (!(0, is_defined_1.isDefined)(unshieldEvent.railgunTxid)) {
                continue;
            }
            railgunTxidGroups[unshieldEvent.railgunTxid] ??= {
                sentCommitments: [],
                unshieldEvents: [],
            };
            railgunTxidGroups[unshieldEvent.railgunTxid].unshieldEvents.push(unshieldEvent);
        }
        await Promise.all(Object.keys(railgunTxidGroups).map(async (railgunTxid) => {
            const sentCommitmentsForRailgunTxid = railgunTxidGroups[railgunTxid].sentCommitments;
            const unshieldEventsForRailgunTxid = railgunTxidGroups[railgunTxid].unshieldEvents;
            return statusInfos.push(await formatSpentStatusInfo(txid, railgunTxid, txidMerkletree, sentCommitmentsForRailgunTxid, unshieldEventsForRailgunTxid, TXOs));
        }));
    }));
    // Sort descending by blockNumber.
    return statusInfos.sort(({ strings: stringsA }, { strings: stringsB }) => stringsB.blockNumber - stringsA.blockNumber);
};
exports.formatTXOsSpentPOIStatusInfo = formatTXOsSpentPOIStatusInfo;
const formatSpentStatusInfo = async (txid, railgunTxid, txidMerkletree, sentCommitmentsForRailgunTxid, unshieldEventsForRailgunTxid, TXOs) => {
    const blockNumber = sentCommitmentsForRailgunTxid.length
        ? sentCommitmentsForRailgunTxid[0].note.blockNumber
        : unshieldEventsForRailgunTxid[0].blockNumber;
    const commitmentHashes = [
        ...sentCommitmentsForRailgunTxid.map((sentCommitment) => bytes_1.ByteUtils.nToHex(sentCommitment.note.hash, bytes_1.ByteLength.UINT_256, true)),
        ...unshieldEventsForRailgunTxid.map((unshieldEvent) => bytes_1.ByteUtils.nToHex((0, note_1.getUnshieldEventNoteHash)(unshieldEvent), bytes_1.ByteLength.UINT_256, true)),
    ];
    let railgunTransactionInfo;
    let railgunTransactionInfoEmoji;
    let listKeysCanGenerateSpentPOIs = [];
    let spentTXOs = [];
    if (railgunTxid && railgunTxid !== 'Missing') {
        const railgunTransaction = await txidMerkletree.getRailgunTransactionByTxid(railgunTxid);
        if (railgunTransaction) {
            const nul = railgunTransaction.nullifiers;
            const hasAllNul = nul.every((n) => TXOs.some((txo) => `0x${txo.nullifier}` === n));
            const com = railgunTransaction.commitments;
            const hasAllCom = com.every((c) => commitmentHashes.includes(c));
            railgunTransactionInfo = `${nul.length} nul: ${nul.join(', ')} (${hasAllNul ? '✓' : 'x'}), ${com.length} com/unsh: ${com.join(', ')} (${hasAllCom ? '✓' : 'x'})`;
            railgunTransactionInfoEmoji = `${nul.length} nul: ${nul
                .map((hex) => (0, hash_emoji_1.emojiHashForPOIStatusInfo)(hex))
                .join(', ')} (${hasAllNul ? '✓' : 'x'}), ${com.length} com/unsh: ${com
                .map((hex) => (0, hash_emoji_1.emojiHashForPOIStatusInfo)(hex))
                .join(', ')} (${hasAllCom ? '✓' : 'x'})`;
            const poiLaunchBlock = poi_1.POI.launchBlocks.get(null, txidMerkletree.chain);
            if (!(0, is_defined_1.isDefined)(poiLaunchBlock)) {
                throw new Error('No POI launch block for railgun txids');
            }
            const isLegacyPOIProof = railgunTransaction.blockNumber < poiLaunchBlock;
            spentTXOs = TXOs.filter((txo) => railgunTransaction.nullifiers.includes(`0x${txo.nullifier}`));
            listKeysCanGenerateSpentPOIs = poi_1.POI.getListKeysCanGenerateSpentPOIs(spentTXOs, sentCommitmentsForRailgunTxid, unshieldEventsForRailgunTxid, isLegacyPOIProof);
        }
        else {
            railgunTransactionInfo = 'Not found';
            railgunTransactionInfoEmoji = 'Not found';
        }
    }
    else {
        railgunTransactionInfo = 'Missing';
        railgunTransactionInfoEmoji = 'Missing';
    }
    const statusInfo = {
        strings: {
            blockNumber: blockNumber ?? 0,
            txid,
            railgunTxid,
            railgunTransactionInfo,
            poiStatusesSpentTXOs: spentTXOs.map((txo) => txo.poisPerList),
            sentCommitmentsBlinded: `${sentCommitmentsForRailgunTxid
                .map((sentCommitment) => sentCommitment.blindedCommitment ?? 'Unavailable')
                .join(', ')}`,
            poiStatusesSentCommitments: sentCommitmentsForRailgunTxid.map((sentCommitment) => sentCommitment.poisPerList),
            unshieldEventsBlinded: `${unshieldEventsForRailgunTxid
                .map((unshieldEvent) => unshieldEvent.railgunTxid ?? 'Unavailable')
                .join(', ')}`,
            poiStatusesUnshieldEvents: unshieldEventsForRailgunTxid.map((unshieldEvent) => unshieldEvent.poisPerList),
            listKeysCanGenerateSpentPOIs,
        },
        emojis: {
            blockNumber: blockNumber ?? 0,
            txid: (0, hash_emoji_1.emojiHashForPOIStatusInfo)(txid),
            railgunTxid: (0, hash_emoji_1.emojiHashForPOIStatusInfo)(railgunTxid),
            railgunTransactionInfo: railgunTransactionInfoEmoji,
            sentCommitmentsBlinded: `${sentCommitmentsForRailgunTxid
                .map((sentCommitment) => {
                return (0, is_defined_1.isDefined)(sentCommitment.blindedCommitment)
                    ? (0, hash_emoji_1.emojiHashForPOIStatusInfo)(sentCommitment.blindedCommitment)
                    : 'Unavailable';
            })
                .join(', ')}`,
            poiStatusesSpentTXOs: spentTXOs.map((sentCommitment) => sentCommitment.poisPerList),
            poiStatusesSentCommitments: sentCommitmentsForRailgunTxid.map((sentCommitment) => sentCommitment.poisPerList),
            unshieldEventsBlinded: `${unshieldEventsForRailgunTxid
                .map((unshieldEvent) => {
                return (0, is_defined_1.isDefined)(unshieldEvent.railgunTxid)
                    ? (0, hash_emoji_1.emojiHashForPOIStatusInfo)(unshieldEvent.railgunTxid)
                    : 'Unavailable';
            })
                .join(', ')}`,
            poiStatusesUnshieldEvents: unshieldEventsForRailgunTxid.map((unshieldEvent) => unshieldEvent.poisPerList),
            listKeysCanGenerateSpentPOIs: listKeysCanGenerateSpentPOIs.map((listKey) => (0, hash_emoji_1.emojiHashForPOIStatusInfo)(listKey)),
        },
    };
    return statusInfo;
};
//# sourceMappingURL=poi-status-formatter.js.map