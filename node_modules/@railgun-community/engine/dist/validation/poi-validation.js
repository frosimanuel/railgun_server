"use strict";
/* eslint-disable no-await-in-loop */
Object.defineProperty(exports, "__esModule", { value: true });
exports.POIValidation = void 0;
const merkle_proof_1 = require("../merkletree/merkle-proof");
const global_tree_position_1 = require("../poi/global-tree-position");
const poi_1 = require("../poi/poi");
const railgun_txid_1 = require("../transaction/railgun-txid");
const bytes_1 = require("../utils/bytes");
const is_defined_1 = require("../utils/is-defined");
const extract_transaction_data_1 = require("./extract-transaction-data");
const poi_proof_1 = require("./poi-proof");
class POIValidation {
    static validatePOIMerkleroots;
    static initForPOINode(validatePOIMerkleroots) {
        this.validatePOIMerkleroots = validatePOIMerkleroots;
    }
    static async isValidSpendableTransaction(txidVersion, chain, prover, transactionRequest, useRelayAdapt, contractAddress, preTransactionPOIs, receivingViewingPrivateKey, receivingRailgunAddressData, tokenDataGetter) {
        try {
            const extractedRailgunTransactionData = await (0, extract_transaction_data_1.extractRailgunTransactionDataFromTransactionRequest)(txidVersion, chain, transactionRequest, useRelayAdapt, contractAddress, receivingViewingPrivateKey, receivingRailgunAddressData, tokenDataGetter);
            const activeListKeys = poi_1.POI.getActiveListKeys();
            for (const listKey of activeListKeys) {
                await this.assertIsValidSpendableTXID(txidVersion, listKey, chain, prover, preTransactionPOIs, extractedRailgunTransactionData.map((data) => data.railgunTxid), extractedRailgunTransactionData.map((data) => data.utxoTreeIn));
            }
            return { isValid: true, extractedRailgunTransactionData };
        }
        catch (cause) {
            if (!(cause instanceof Error)) {
                throw new Error('Non-error thrown from isValidSpendableTransaction', { cause });
            }
            return {
                isValid: false,
                error: `Could not validate spendable TXID: ${cause.message}`,
            };
        }
    }
    static async assertIsValidSpendableTXID(txidVersion, listKey, chain, prover, preTransactionPOIs, railgunTxids, utxoTreesIn) {
        const txidLeafHashes = railgunTxids.map((railgunTxid, index) => (0, railgun_txid_1.getRailgunTxidLeafHash)(bytes_1.ByteUtils.hexToBigInt(railgunTxid), utxoTreesIn[index], (0, global_tree_position_1.getGlobalTreePositionPreTransactionPOIProof)()));
        // 1. Validate list key is present
        if (!(0, is_defined_1.isDefined)(preTransactionPOIs[listKey])) {
            throw new Error(`Missing POIs for list: ${listKey}`);
        }
        const poisForList = preTransactionPOIs[listKey];
        for (const txidLeafHash of txidLeafHashes) {
            // 2. Validate txid leaf hash
            if (!(0, is_defined_1.isDefined)(poisForList[txidLeafHash])) {
                throw new Error(`Missing POI for txidLeafHash ${txidLeafHash} for list ${listKey}`);
            }
            const { snarkProof, txidMerkleroot, poiMerkleroots, blindedCommitmentsOut, railgunTxidIfHasUnshield, } = poisForList[txidLeafHash];
            // 3. Validate txidDummyMerkleProof and txid root
            const dummyMerkleProof = (0, merkle_proof_1.createDummyMerkleProof)(txidLeafHash);
            if (dummyMerkleProof.root !== txidMerkleroot) {
                throw new Error('Invalid txid merkle proof');
            }
            // 4. Validate POI merkleroots for each list
            let validPOIMerkleroots;
            if ((0, is_defined_1.isDefined)(POIValidation.validatePOIMerkleroots)) {
                // Use supplied validator if it exists
                validPOIMerkleroots = await POIValidation.validatePOIMerkleroots(txidVersion, chain, listKey, poiMerkleroots);
            }
            else {
                // Fallback to making request through POI nodes
                validPOIMerkleroots = await poi_1.POI.validatePOIMerkleroots(txidVersion, chain, listKey, poiMerkleroots);
            }
            if (!validPOIMerkleroots) {
                throw new Error(`Invalid POI merkleroots: list ${listKey}`);
            }
            // 5. Verify snark proof for each list
            const transactProofData = {
                snarkProof,
                txidMerkleroot,
                poiMerkleroots,
                blindedCommitmentsOut,
                railgunTxidIfHasUnshield,
                txidMerklerootIndex: 0, // Unused
            };
            const validProof = await poi_proof_1.POIProof.verifyTransactProof(prover, transactProofData);
            if (!validProof) {
                throw new Error(`Could not verify POI snark proof: list ${listKey}`);
            }
        }
        return true;
    }
}
exports.POIValidation = POIValidation;
//# sourceMappingURL=poi-validation.js.map